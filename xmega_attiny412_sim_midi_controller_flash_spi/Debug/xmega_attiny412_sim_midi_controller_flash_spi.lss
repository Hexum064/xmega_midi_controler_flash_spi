
xmega_attiny412_sim_midi_controller_flash_spi.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012f6  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  0000136a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008c  00802000  00802000  0000136a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000136a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000139c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  000013dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004b67  00000000  00000000  0000149c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002a98  00000000  00000000  00006003  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000dcc  00000000  00000000  00008a9b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000308  00000000  00000000  00009868  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002f9e  00000000  00000000  00009b70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000009da  00000000  00000000  0000cb0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c8  00000000  00000000  0000d4e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
       4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
       8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
       c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      10:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      14:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      18:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      1c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      20:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      24:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      28:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      2c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      30:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      34:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      38:	0c 94 5b 08 	jmp	0x10b6	; 0x10b6 <__vector_14>
      3c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      40:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      44:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      48:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      4c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      50:	0c 94 72 08 	jmp	0x10e4	; 0x10e4 <__vector_20>
      54:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      58:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      5c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      60:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      64:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      68:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      6c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      70:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      74:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      78:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      7c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      80:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      84:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      88:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      8c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      90:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      94:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      98:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      9c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      a4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      a8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      ac:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      b0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      b4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      b8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      bc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      c0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      c4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      c8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      cc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      d4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      d8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      e0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      e4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      e8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      ec:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      f0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      f4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      f8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
      fc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     100:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     104:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     108:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     10c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     110:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     114:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     118:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     11c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     120:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     124:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     128:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     12c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     130:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     134:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     138:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     13c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     140:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     144:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     148:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     14c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     150:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     154:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     158:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     15c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     160:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     164:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     168:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     16c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     170:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     174:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     178:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     17c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     180:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     184:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     188:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     18c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     190:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     194:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     198:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     19c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1a4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1a8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1ac:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1b0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1b4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1b8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1bc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1c0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1c4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1c8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1cc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1d4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1d8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1e0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1e4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1e8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1ec:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1f0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1f4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
     1f8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>

000001fc <__ctors_end>:
     1fc:	11 24       	eor	r1, r1
     1fe:	1f be       	out	0x3f, r1	; 63
     200:	cf ef       	ldi	r28, 0xFF	; 255
     202:	cd bf       	out	0x3d, r28	; 61
     204:	df e3       	ldi	r29, 0x3F	; 63
     206:	de bf       	out	0x3e, r29	; 62
     208:	00 e0       	ldi	r16, 0x00	; 0
     20a:	0c bf       	out	0x3c, r16	; 60
     20c:	18 be       	out	0x38, r1	; 56
     20e:	19 be       	out	0x39, r1	; 57
     210:	1a be       	out	0x3a, r1	; 58
     212:	1b be       	out	0x3b, r1	; 59

00000214 <__do_clear_bss>:
     214:	20 e2       	ldi	r18, 0x20	; 32
     216:	a0 e0       	ldi	r26, 0x00	; 0
     218:	b0 e2       	ldi	r27, 0x20	; 32
     21a:	01 c0       	rjmp	.+2      	; 0x21e <.do_clear_bss_start>

0000021c <.do_clear_bss_loop>:
     21c:	1d 92       	st	X+, r1

0000021e <.do_clear_bss_start>:
     21e:	ac 38       	cpi	r26, 0x8C	; 140
     220:	b2 07       	cpc	r27, r18
     222:	e1 f7       	brne	.-8      	; 0x21c <.do_clear_bss_loop>
     224:	0e 94 35 06 	call	0xc6a	; 0xc6a <main>
     228:	0c 94 79 09 	jmp	0x12f2	; 0x12f2 <_exit>

0000022c <__bad_interrupt>:
     22c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000230 <sendMidi>:
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
}

uint8_t sendMidi(uint8_t data)
{
	while(!(USARTD0.STATUS & USART_DREIF_bm)) {}
     230:	90 91 a1 09 	lds	r25, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
     234:	95 ff       	sbrs	r25, 5
     236:	fc cf       	rjmp	.-8      	; 0x230 <sendMidi>
		
	USARTD0.DATA = data;
     238:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
}
     23c:	08 95       	ret

0000023e <stopMidi>:
	TIMER_ENABLE();
}

static void  stopMidi()
{
	sendMidi(MIDI_STOP);
     23e:	8c ef       	ldi	r24, 0xFC	; 252
     240:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	TIMER_DISABLE();
     244:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
     248:	08 95       	ret

0000024a <startMidi>:

//The following static inline methods are made inline so less stack space is used, better performance, and have no internal variables. They are broken out for readability. May have to remove inline if code space is needed

static void  startMidi()
{
	sendMidi(MIDI_START);
     24a:	8a ef       	ldi	r24, 0xFA	; 250
     24c:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	sendMidi((_fileIndex >> 8));
     250:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     254:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     258:	89 2f       	mov	r24, r25
     25a:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	sendMidi(_fileIndex);
     25e:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     262:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     266:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	TIMER_ENABLE();
     26a:	83 e0       	ldi	r24, 0x03	; 3
     26c:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
     270:	08 95       	ret

00000272 <sendSPI>:
	USARTD0.DATA = data;
}

uint8_t sendSPI(uint8_t data)
{
	SPIC.DATA = data;
     272:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	
	while(!(SPIC.STATUS & SPI_IF_bm)) {}
     276:	80 91 c2 08 	lds	r24, 0x08C2	; 0x8008c2 <__TEXT_REGION_LENGTH__+0x7008c2>
     27a:	87 ff       	sbrs	r24, 7
     27c:	fc cf       	rjmp	.-8      	; 0x276 <sendSPI+0x4>
	
	return SPIC.DATA;
     27e:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	
}
     282:	08 95       	ret

00000284 <sendDummy>:

static inline uint8_t sendDummy()
{
	return sendSPI(0x00);
     284:	80 e0       	ldi	r24, 0x00	; 0
     286:	0c 94 39 01 	jmp	0x272	; 0x272 <sendSPI>

0000028a <memSendAddress>:
}

void memSendAddress(uint32_t address)
{
     28a:	cf 93       	push	r28
     28c:	df 93       	push	r29
     28e:	00 d0       	rcall	.+0      	; 0x290 <memSendAddress+0x6>
     290:	1f 92       	push	r1
     292:	cd b7       	in	r28, 0x3d	; 61
     294:	de b7       	in	r29, 0x3e	; 62
     296:	69 83       	std	Y+1, r22	; 0x01
     298:	7a 83       	std	Y+2, r23	; 0x02
     29a:	8b 83       	std	Y+3, r24	; 0x03
     29c:	9c 83       	std	Y+4, r25	; 0x04
	//sendSPI((uint8_t)((address >> 16) & 0xFF));
	//sendSPI((uint8_t)((address >> 8) & 0xFF));
	//sendSPI((uint8_t)((address >> 0) & 0xFF));
	uint8_t *ptr = &address;
	
	sendSPI(*ptr);
     29e:	86 2f       	mov	r24, r22
     2a0:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
	sendSPI(*(ptr + 1));
     2a4:	8a 81       	ldd	r24, Y+2	; 0x02
     2a6:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
	sendSPI(*(ptr + 2));
     2aa:	8b 81       	ldd	r24, Y+3	; 0x03
     2ac:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
}
     2b0:	24 96       	adiw	r28, 0x04	; 4
     2b2:	cd bf       	out	0x3d, r28	; 61
     2b4:	de bf       	out	0x3e, r29	; 62
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <getMemStatus>:

uint8_t getMemStatus()
{
     2bc:	1f 93       	push	r17
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
	uint8_t out;
	CS_DISABLE();
     2c2:	c0 e4       	ldi	r28, 0x40	; 64
     2c4:	d6 e0       	ldi	r29, 0x06	; 6
     2c6:	10 e1       	ldi	r17, 0x10	; 16
     2c8:	1d 83       	std	Y+5, r17	; 0x05
	CS_ENABLE();
     2ca:	1e 83       	std	Y+6, r17	; 0x06
	
	sendSPI(MEM_READ_STATUS);
     2cc:	85 e0       	ldi	r24, 0x05	; 5
     2ce:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
	out = sendDummy();
     2d2:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
	CS_DISABLE();
     2d6:	1d 83       	std	Y+5, r17	; 0x05
	return out;
}
     2d8:	df 91       	pop	r29
     2da:	cf 91       	pop	r28
     2dc:	1f 91       	pop	r17
     2de:	08 95       	ret

000002e0 <waitForNotBusy>:

void waitForNotBusy()
{
	while((getMemStatus() & MEM_STAT_BUSY)) {}
     2e0:	0e 94 5e 01 	call	0x2bc	; 0x2bc <getMemStatus>
     2e4:	80 fd       	sbrc	r24, 0
     2e6:	fc cf       	rjmp	.-8      	; 0x2e0 <waitForNotBusy>
}
     2e8:	08 95       	ret

000002ea <memReadToBuffer>:


void memReadToBuffer(uint32_t address, void *buff, uint8_t len)
{
     2ea:	cf 92       	push	r12
     2ec:	df 92       	push	r13
     2ee:	ef 92       	push	r14
     2f0:	ff 92       	push	r15
     2f2:	1f 93       	push	r17
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	1f 92       	push	r1
     2fa:	1f 92       	push	r1
     2fc:	cd b7       	in	r28, 0x3d	; 61
     2fe:	de b7       	in	r29, 0x3e	; 62
     300:	6b 01       	movw	r12, r22
     302:	7c 01       	movw	r14, r24
     304:	14 2f       	mov	r17, r20
	uint8_t *ptr = buff;
	waitForNotBusy();
     306:	29 83       	std	Y+1, r18	; 0x01
     308:	5a 83       	std	Y+2, r21	; 0x02
     30a:	0e 94 70 01 	call	0x2e0	; 0x2e0 <waitForNotBusy>

	CS_DISABLE();
     30e:	80 e1       	ldi	r24, 0x10	; 16
     310:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	CS_ENABLE();
     314:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
	
	sendSPI(MEM_READ);
     318:	83 e0       	ldi	r24, 0x03	; 3
     31a:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
	memSendAddress(address);
     31e:	c7 01       	movw	r24, r14
     320:	b6 01       	movw	r22, r12
     322:	0e 94 45 01 	call	0x28a	; 0x28a <memSendAddress>
     326:	e1 2e       	mov	r14, r17
     328:	5a 81       	ldd	r21, Y+2	; 0x02
     32a:	f5 2e       	mov	r15, r21
     32c:	29 81       	ldd	r18, Y+1	; 0x01
     32e:	12 0f       	add	r17, r18
	
	do
	{
		*(ptr++) = sendDummy();
     330:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     334:	f7 01       	movw	r30, r14
     336:	81 93       	st	Z+, r24
     338:	7f 01       	movw	r14, r30
	}while(--len);
     33a:	1e 13       	cpse	r17, r30
     33c:	f9 cf       	rjmp	.-14     	; 0x330 <memReadToBuffer+0x46>
	
	CS_DISABLE();
     33e:	80 e1       	ldi	r24, 0x10	; 16
     340:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	return;
	
}
     344:	0f 90       	pop	r0
     346:	0f 90       	pop	r0
     348:	df 91       	pop	r29
     34a:	cf 91       	pop	r28
     34c:	1f 91       	pop	r17
     34e:	ff 90       	pop	r15
     350:	ef 90       	pop	r14
     352:	df 90       	pop	r13
     354:	cf 90       	pop	r12
     356:	08 95       	ret

00000358 <getFileCount>:

}

//Sets _fileCount
void getFileCount()
{
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	1f 92       	push	r1
     35e:	1f 92       	push	r1
     360:	cd b7       	in	r28, 0x3d	; 61
     362:	de b7       	in	r29, 0x3e	; 62
	uint8_t data[2];
	memReadToBuffer(FILE_COUNT_ADDR, data, 2);
     364:	22 e0       	ldi	r18, 0x02	; 2
     366:	ae 01       	movw	r20, r28
     368:	4f 5f       	subi	r20, 0xFF	; 255
     36a:	5f 4f       	sbci	r21, 0xFF	; 255
     36c:	64 e0       	ldi	r22, 0x04	; 4
     36e:	70 e1       	ldi	r23, 0x10	; 16
     370:	80 e0       	ldi	r24, 0x00	; 0
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 75 01 	call	0x2ea	; 0x2ea <memReadToBuffer>
	_fileCount = ((uint16_t)data[0] << 8) + (uint16_t)data[1];	
     378:	89 81       	ldd	r24, Y+1	; 0x01
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	98 2f       	mov	r25, r24
     37e:	88 27       	eor	r24, r24
     380:	2a 81       	ldd	r18, Y+2	; 0x02
     382:	82 0f       	add	r24, r18
     384:	91 1d       	adc	r25, r1
     386:	80 93 09 20 	sts	0x2009, r24	; 0x802009 <_fileCount>
     38a:	90 93 0a 20 	sts	0x200A, r25	; 0x80200a <_fileCount+0x1>
}
     38e:	0f 90       	pop	r0
     390:	0f 90       	pop	r0
     392:	df 91       	pop	r29
     394:	cf 91       	pop	r28
     396:	08 95       	ret

00000398 <moveToFile>:

//Uses _fileIndex
//Sets _fileAddressOffset
//Since we don't need the file names, we will automatically add the name length to the offset
void moveToFile()
{
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	00 d0       	rcall	.+0      	; 0x3aa <moveToFile+0x12>
     3aa:	1f 92       	push	r1
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
	
	uint8_t data[4];
	uint32_t address = FILE_COUNT_ADDR + 2; //starting address for lookup table is 2 bytes after the size of the total data section.
	_fileAddressOffset = address + (uint32_t)(_fileCount * 4); //first file address is the address of the first lookup table entry + all entries (Which are each 4 bytes)
     3b0:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
     3b4:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
     3b8:	88 0f       	add	r24, r24
     3ba:	99 1f       	adc	r25, r25
     3bc:	88 0f       	add	r24, r24
     3be:	99 1f       	adc	r25, r25
     3c0:	a0 e0       	ldi	r26, 0x00	; 0
     3c2:	b0 e0       	ldi	r27, 0x00	; 0
     3c4:	8a 5f       	subi	r24, 0xFA	; 250
     3c6:	9f 4e       	sbci	r25, 0xEF	; 239
     3c8:	af 4f       	sbci	r26, 0xFF	; 255
     3ca:	bf 4f       	sbci	r27, 0xFF	; 255
     3cc:	80 93 03 20 	sts	0x2003, r24	; 0x802003 <_fileAddressOffset>
     3d0:	90 93 04 20 	sts	0x2004, r25	; 0x802004 <_fileAddressOffset+0x1>
     3d4:	a0 93 05 20 	sts	0x2005, r26	; 0x802005 <_fileAddressOffset+0x2>
     3d8:	b0 93 06 20 	sts	0x2006, r27	; 0x802006 <_fileAddressOffset+0x3>
	
	//if the index we are looking for is 0 or the file count is 0, then we can leave the address we initialized _fileAddressOffset to
	if (_fileIndex > 0 && _fileCount > 0)
     3dc:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     3e0:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     3e4:	89 2b       	or	r24, r25
     3e6:	f1 f5       	brne	.+124    	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
			_fileAddressOffset += ((uint32_t)data[0] << 24) + ((uint32_t)data[1] << 16) + ((uint32_t)data[2] << 8) + ((uint32_t)data[3] << 0);
		}
	}
	
	//As a convenience, here we add file name length to offset.
	memReadToBuffer(_fileAddressOffset, data, 2);
     3e8:	60 91 03 20 	lds	r22, 0x2003	; 0x802003 <_fileAddressOffset>
     3ec:	70 91 04 20 	lds	r23, 0x2004	; 0x802004 <_fileAddressOffset+0x1>
     3f0:	80 91 05 20 	lds	r24, 0x2005	; 0x802005 <_fileAddressOffset+0x2>
     3f4:	90 91 06 20 	lds	r25, 0x2006	; 0x802006 <_fileAddressOffset+0x3>
     3f8:	22 e0       	ldi	r18, 0x02	; 2
     3fa:	ae 01       	movw	r20, r28
     3fc:	4f 5f       	subi	r20, 0xFF	; 255
     3fe:	5f 4f       	sbci	r21, 0xFF	; 255
     400:	0e 94 75 01 	call	0x2ea	; 0x2ea <memReadToBuffer>
	_fileAddressOffset +=  ((uint32_t)data[0] << 8) + ((uint32_t)data[1] << 0) + 2; //+ 2 for the name length bytes
     404:	80 91 03 20 	lds	r24, 0x2003	; 0x802003 <_fileAddressOffset>
     408:	90 91 04 20 	lds	r25, 0x2004	; 0x802004 <_fileAddressOffset+0x1>
     40c:	a0 91 05 20 	lds	r26, 0x2005	; 0x802005 <_fileAddressOffset+0x2>
     410:	b0 91 06 20 	lds	r27, 0x2006	; 0x802006 <_fileAddressOffset+0x3>
     414:	02 96       	adiw	r24, 0x02	; 2
     416:	a1 1d       	adc	r26, r1
     418:	b1 1d       	adc	r27, r1
     41a:	2a 81       	ldd	r18, Y+2	; 0x02
     41c:	82 0f       	add	r24, r18
     41e:	91 1d       	adc	r25, r1
     420:	a1 1d       	adc	r26, r1
     422:	b1 1d       	adc	r27, r1
     424:	49 81       	ldd	r20, Y+1	; 0x01
     426:	50 e0       	ldi	r21, 0x00	; 0
     428:	60 e0       	ldi	r22, 0x00	; 0
     42a:	70 e0       	ldi	r23, 0x00	; 0
     42c:	76 2f       	mov	r23, r22
     42e:	65 2f       	mov	r22, r21
     430:	54 2f       	mov	r21, r20
     432:	44 27       	eor	r20, r20
     434:	84 0f       	add	r24, r20
     436:	95 1f       	adc	r25, r21
     438:	a6 1f       	adc	r26, r22
     43a:	b7 1f       	adc	r27, r23
     43c:	80 93 03 20 	sts	0x2003, r24	; 0x802003 <_fileAddressOffset>
     440:	90 93 04 20 	sts	0x2004, r25	; 0x802004 <_fileAddressOffset+0x1>
     444:	a0 93 05 20 	sts	0x2005, r26	; 0x802005 <_fileAddressOffset+0x2>
     448:	b0 93 06 20 	sts	0x2006, r27	; 0x802006 <_fileAddressOffset+0x3>
	
}
     44c:	24 96       	adiw	r28, 0x04	; 4
     44e:	cd bf       	out	0x3d, r28	; 61
     450:	de bf       	out	0x3e, r29	; 62
     452:	df 91       	pop	r29
     454:	cf 91       	pop	r28
     456:	1f 91       	pop	r17
     458:	0f 91       	pop	r16
     45a:	ff 90       	pop	r15
     45c:	ef 90       	pop	r14
     45e:	df 90       	pop	r13
     460:	cf 90       	pop	r12
     462:	08 95       	ret
	uint8_t data[4];
	uint32_t address = FILE_COUNT_ADDR + 2; //starting address for lookup table is 2 bytes after the size of the total data section.
	_fileAddressOffset = address + (uint32_t)(_fileCount * 4); //first file address is the address of the first lookup table entry + all entries (Which are each 4 bytes)
	
	//if the index we are looking for is 0 or the file count is 0, then we can leave the address we initialized _fileAddressOffset to
	if (_fileIndex > 0 && _fileCount > 0)
     464:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
     468:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
     46c:	89 2b       	or	r24, r25
     46e:	09 f4       	brne	.+2      	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
     470:	bb cf       	rjmp	.-138    	; 0x3e8 <moveToFile+0x50>
	{
		//Make sure the index is not larger than the file count
		if (_fileIndex >= _fileCount)
     472:	20 91 07 20 	lds	r18, 0x2007	; 0x802007 <_fileIndex>
     476:	30 91 08 20 	lds	r19, 0x2008	; 0x802008 <_fileIndex+0x1>
     47a:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
     47e:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
     482:	28 17       	cp	r18, r24
     484:	39 07       	cpc	r19, r25
     486:	48 f0       	brcs	.+18     	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
		{
			_fileIndex = _fileCount - 1;
     488:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
     48c:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
     490:	01 97       	sbiw	r24, 0x01	; 1
     492:	80 93 07 20 	sts	0x2007, r24	; 0x802007 <_fileIndex>
     496:	90 93 08 20 	sts	0x2008, r25	; 0x802008 <_fileIndex+0x1>

//Uses _fileIndex
//Sets _fileAddressOffset
//Since we don't need the file names, we will automatically add the name length to the offset
void moveToFile()
{
     49a:	00 e0       	ldi	r16, 0x00	; 0
     49c:	10 e0       	ldi	r17, 0x00	; 0
     49e:	f6 e0       	ldi	r31, 0x06	; 6
     4a0:	cf 2e       	mov	r12, r31
     4a2:	f0 e1       	ldi	r31, 0x10	; 16
     4a4:	df 2e       	mov	r13, r31
     4a6:	e1 2c       	mov	r14, r1
     4a8:	f1 2c       	mov	r15, r1
		{
			_fileIndex = _fileCount - 1;
		}	
		
		//We are basically summing up all of the file sizes until we reach our file index
		for(uint16_t i = 0; i < _fileIndex; i++)
     4aa:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     4ae:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     4b2:	08 17       	cp	r16, r24
     4b4:	19 07       	cpc	r17, r25
     4b6:	08 f0       	brcs	.+2      	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
     4b8:	97 cf       	rjmp	.-210    	; 0x3e8 <moveToFile+0x50>
		{
			//read file sizes and add them too the offsets			
			memReadToBuffer(address, data, 4);
     4ba:	24 e0       	ldi	r18, 0x04	; 4
     4bc:	ae 01       	movw	r20, r28
     4be:	4f 5f       	subi	r20, 0xFF	; 255
     4c0:	5f 4f       	sbci	r21, 0xFF	; 255
     4c2:	c7 01       	movw	r24, r14
     4c4:	b6 01       	movw	r22, r12
     4c6:	0e 94 75 01 	call	0x2ea	; 0x2ea <memReadToBuffer>
			address += 4;
     4ca:	84 e0       	ldi	r24, 0x04	; 4
     4cc:	c8 0e       	add	r12, r24
     4ce:	d1 1c       	adc	r13, r1
     4d0:	e1 1c       	adc	r14, r1
     4d2:	f1 1c       	adc	r15, r1
			_fileAddressOffset += ((uint32_t)data[0] << 24) + ((uint32_t)data[1] << 16) + ((uint32_t)data[2] << 8) + ((uint32_t)data[3] << 0);
     4d4:	80 91 03 20 	lds	r24, 0x2003	; 0x802003 <_fileAddressOffset>
     4d8:	90 91 04 20 	lds	r25, 0x2004	; 0x802004 <_fileAddressOffset+0x1>
     4dc:	a0 91 05 20 	lds	r26, 0x2005	; 0x802005 <_fileAddressOffset+0x2>
     4e0:	b0 91 06 20 	lds	r27, 0x2006	; 0x802006 <_fileAddressOffset+0x3>
     4e4:	2c 81       	ldd	r18, Y+4	; 0x04
     4e6:	ac 01       	movw	r20, r24
     4e8:	bd 01       	movw	r22, r26
     4ea:	42 0f       	add	r20, r18
     4ec:	51 1d       	adc	r21, r1
     4ee:	61 1d       	adc	r22, r1
     4f0:	71 1d       	adc	r23, r1
     4f2:	99 81       	ldd	r25, Y+1	; 0x01
     4f4:	89 2f       	mov	r24, r25
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	a0 e0       	ldi	r26, 0x00	; 0
     4fa:	b0 e0       	ldi	r27, 0x00	; 0
     4fc:	b8 2f       	mov	r27, r24
     4fe:	aa 27       	eor	r26, r26
     500:	99 27       	eor	r25, r25
     502:	88 27       	eor	r24, r24
     504:	84 0f       	add	r24, r20
     506:	95 1f       	adc	r25, r21
     508:	a6 1f       	adc	r26, r22
     50a:	b7 1f       	adc	r27, r23
     50c:	4a 81       	ldd	r20, Y+2	; 0x02
     50e:	50 e0       	ldi	r21, 0x00	; 0
     510:	60 e0       	ldi	r22, 0x00	; 0
     512:	70 e0       	ldi	r23, 0x00	; 0
     514:	ba 01       	movw	r22, r20
     516:	55 27       	eor	r21, r21
     518:	44 27       	eor	r20, r20
     51a:	84 0f       	add	r24, r20
     51c:	95 1f       	adc	r25, r21
     51e:	a6 1f       	adc	r26, r22
     520:	b7 1f       	adc	r27, r23
     522:	4b 81       	ldd	r20, Y+3	; 0x03
     524:	50 e0       	ldi	r21, 0x00	; 0
     526:	60 e0       	ldi	r22, 0x00	; 0
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	76 2f       	mov	r23, r22
     52c:	65 2f       	mov	r22, r21
     52e:	54 2f       	mov	r21, r20
     530:	44 27       	eor	r20, r20
     532:	84 0f       	add	r24, r20
     534:	95 1f       	adc	r25, r21
     536:	a6 1f       	adc	r26, r22
     538:	b7 1f       	adc	r27, r23
     53a:	80 93 03 20 	sts	0x2003, r24	; 0x802003 <_fileAddressOffset>
     53e:	90 93 04 20 	sts	0x2004, r25	; 0x802004 <_fileAddressOffset+0x1>
     542:	a0 93 05 20 	sts	0x2005, r26	; 0x802005 <_fileAddressOffset+0x2>
     546:	b0 93 06 20 	sts	0x2006, r27	; 0x802006 <_fileAddressOffset+0x3>
		{
			_fileIndex = _fileCount - 1;
		}	
		
		//We are basically summing up all of the file sizes until we reach our file index
		for(uint16_t i = 0; i < _fileIndex; i++)
     54a:	0f 5f       	subi	r16, 0xFF	; 255
     54c:	1f 4f       	sbci	r17, 0xFF	; 255
     54e:	ad cf       	rjmp	.-166    	; 0x4aa <__LOCK_REGION_LENGTH__+0xaa>

00000550 <getTrackCount>:
}

//Uses _fileAddressOffset
//Sets _trackCount
void getTrackCount()
{
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	1f 92       	push	r1
     556:	1f 92       	push	r1
     558:	cd b7       	in	r28, 0x3d	; 61
     55a:	de b7       	in	r29, 0x3e	; 62
	uint8_t data[2];

	memReadToBuffer(_fileAddressOffset + MIDI_HEADER_TRACk_COUNT_OFFSET, data, 2);
     55c:	80 91 03 20 	lds	r24, 0x2003	; 0x802003 <_fileAddressOffset>
     560:	90 91 04 20 	lds	r25, 0x2004	; 0x802004 <_fileAddressOffset+0x1>
     564:	a0 91 05 20 	lds	r26, 0x2005	; 0x802005 <_fileAddressOffset+0x2>
     568:	b0 91 06 20 	lds	r27, 0x2006	; 0x802006 <_fileAddressOffset+0x3>
     56c:	bc 01       	movw	r22, r24
     56e:	cd 01       	movw	r24, r26
     570:	66 5f       	subi	r22, 0xF6	; 246
     572:	7f 4f       	sbci	r23, 0xFF	; 255
     574:	8f 4f       	sbci	r24, 0xFF	; 255
     576:	9f 4f       	sbci	r25, 0xFF	; 255
     578:	22 e0       	ldi	r18, 0x02	; 2
     57a:	ae 01       	movw	r20, r28
     57c:	4f 5f       	subi	r20, 0xFF	; 255
     57e:	5f 4f       	sbci	r21, 0xFF	; 255
     580:	0e 94 75 01 	call	0x2ea	; 0x2ea <memReadToBuffer>
	_tractCount = ((uint16_t)data[0] << 8) + (uint16_t)data[1];	
     584:	8a 81       	ldd	r24, Y+2	; 0x02
     586:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <_tractCount>
	
}
     58a:	0f 90       	pop	r0
     58c:	0f 90       	pop	r0
     58e:	df 91       	pop	r29
     590:	cf 91       	pop	r28
     592:	08 95       	ret

00000594 <getTimeDivision>:


//Uses _fileAddressOffset
//Sets _division
void getTimeDivision()
{
     594:	cf 93       	push	r28
     596:	df 93       	push	r29
     598:	1f 92       	push	r1
     59a:	1f 92       	push	r1
     59c:	cd b7       	in	r28, 0x3d	; 61
     59e:	de b7       	in	r29, 0x3e	; 62
	//With this, an 8th note would have an even length (delta-time for the following Note-off event for that note) of 128 ticks, or a duration of 0.25 seconds.
	//A change in Tempo (meta-event 0xFF with an arg of 51) would effectively change the BPM.
	//For the SMPTE, the _division is calculated by multiplying the first byte by the second byte and then by -1. This means a value of 0xE7 0x28 would be the same as 0x03 0xE8 (or 1000uS, 1mS)	
	uint8_t data[2];

	memReadToBuffer(_fileAddressOffset + MIDI_HEADER_TIME_DIV_OFFSET, data, 2);
     5a0:	80 91 03 20 	lds	r24, 0x2003	; 0x802003 <_fileAddressOffset>
     5a4:	90 91 04 20 	lds	r25, 0x2004	; 0x802004 <_fileAddressOffset+0x1>
     5a8:	a0 91 05 20 	lds	r26, 0x2005	; 0x802005 <_fileAddressOffset+0x2>
     5ac:	b0 91 06 20 	lds	r27, 0x2006	; 0x802006 <_fileAddressOffset+0x3>
     5b0:	bc 01       	movw	r22, r24
     5b2:	cd 01       	movw	r24, r26
     5b4:	64 5f       	subi	r22, 0xF4	; 244
     5b6:	7f 4f       	sbci	r23, 0xFF	; 255
     5b8:	8f 4f       	sbci	r24, 0xFF	; 255
     5ba:	9f 4f       	sbci	r25, 0xFF	; 255
     5bc:	22 e0       	ldi	r18, 0x02	; 2
     5be:	ae 01       	movw	r20, r28
     5c0:	4f 5f       	subi	r20, 0xFF	; 255
     5c2:	5f 4f       	sbci	r21, 0xFF	; 255
     5c4:	0e 94 75 01 	call	0x2ea	; 0x2ea <memReadToBuffer>
	_division = ((uint16_t)data[0] << 8) + (uint16_t)data[1];
     5c8:	49 81       	ldd	r20, Y+1	; 0x01
     5ca:	2a 81       	ldd	r18, Y+2	; 0x02
     5cc:	84 2f       	mov	r24, r20
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	98 2f       	mov	r25, r24
     5d2:	88 27       	eor	r24, r24
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	82 0f       	add	r24, r18
     5d8:	93 1f       	adc	r25, r19
     5da:	80 93 0b 20 	sts	0x200B, r24	; 0x80200b <_division>
     5de:	90 93 0c 20 	sts	0x200C, r25	; 0x80200c <_division+0x1>
	
	
	
	if (_division < 0) //_division is negative so is in SMPTE format
     5e2:	80 91 0b 20 	lds	r24, 0x200B	; 0x80200b <_division>
     5e6:	90 91 0c 20 	lds	r25, 0x200C	; 0x80200c <_division+0x1>
     5ea:	97 ff       	sbrs	r25, 7
     5ec:	10 c0       	rjmp	.+32     	; 0x60e <getTimeDivision+0x7a>
	{
		_division = -1 * (int8_t)data[0] * data[1];
     5ee:	64 2f       	mov	r22, r20
     5f0:	77 27       	eor	r23, r23
     5f2:	61 95       	neg	r22
     5f4:	0c f4       	brge	.+2      	; 0x5f8 <getTimeDivision+0x64>
     5f6:	70 95       	com	r23
     5f8:	62 9f       	mul	r22, r18
     5fa:	a0 01       	movw	r20, r0
     5fc:	63 9f       	mul	r22, r19
     5fe:	50 0d       	add	r21, r0
     600:	72 9f       	mul	r23, r18
     602:	50 0d       	add	r21, r0
     604:	11 24       	eor	r1, r1
     606:	40 93 0b 20 	sts	0x200B, r20	; 0x80200b <_division>
     60a:	50 93 0c 20 	sts	0x200C, r21	; 0x80200c <_division+0x1>
	}	
	
}
     60e:	0f 90       	pop	r0
     610:	0f 90       	pop	r0
     612:	df 91       	pop	r29
     614:	cf 91       	pop	r28
     616:	08 95       	ret

00000618 <getNextEvent>:



uint8_t getNextEvent(uint8_t trackIndex)
{
     618:	2f 92       	push	r2
     61a:	3f 92       	push	r3
     61c:	4f 92       	push	r4
     61e:	5f 92       	push	r5
     620:	6f 92       	push	r6
     622:	7f 92       	push	r7
     624:	8f 92       	push	r8
     626:	9f 92       	push	r9
     628:	af 92       	push	r10
     62a:	bf 92       	push	r11
     62c:	cf 92       	push	r12
     62e:	df 92       	push	r13
     630:	ef 92       	push	r14
     632:	ff 92       	push	r15
     634:	0f 93       	push	r16
     636:	1f 93       	push	r17
     638:	cf 93       	push	r28
     63a:	df 93       	push	r29
     63c:	cd b7       	in	r28, 0x3d	; 61
     63e:	de b7       	in	r29, 0x3e	; 62
     640:	2b 97       	sbiw	r28, 0x0b	; 11
     642:	cd bf       	out	0x3d, r28	; 61
     644:	de bf       	out	0x3e, r29	; 62
	uint8_t done = 0;
	uint8_t data[4];
	uint8_t i;
	
	_tracks[trackIndex].deltaTime = 0;
     646:	28 2f       	mov	r18, r24
     648:	30 e0       	ldi	r19, 0x00	; 0
     64a:	29 87       	std	Y+9, r18	; 0x09
     64c:	3a 87       	std	Y+10, r19	; 0x0a
     64e:	3f e0       	ldi	r19, 0x0F	; 15
     650:	83 9f       	mul	r24, r19
     652:	f0 01       	movw	r30, r0
     654:	11 24       	eor	r1, r1
     656:	e3 5f       	subi	r30, 0xF3	; 243
     658:	ff 4d       	sbci	r31, 0xDF	; 223
     65a:	10 86       	std	Z+8, r1	; 0x08
     65c:	11 86       	std	Z+9, r1	; 0x09
     65e:	12 86       	std	Z+10, r1	; 0x0a
     660:	13 86       	std	Z+11, r1	; 0x0b
		data[3] = 0;

		//The last byte will not have the MSB set.
		data[0] = sendDummy();

		_tracks[trackIndex].addressOffset++;
     662:	4f 01       	movw	r8, r30
     664:	ce 01       	movw	r24, r28
     666:	01 96       	adiw	r24, 0x01	; 1
     668:	8d 83       	std	Y+5, r24	; 0x05
     66a:	9e 83       	std	Y+6, r25	; 0x06
     66c:	8c 5f       	subi	r24, 0xFC	; 252
     66e:	8b 87       	std	Y+11, r24	; 0x0b
				}
			}
		}

		//just using 'i' as a temp
		_tracks[trackIndex].deltaTime += getVariableLengthValue(data, &i);
     670:	38 96       	adiw	r30, 0x08	; 8
     672:	ef 83       	std	Y+7, r30	; 0x07
     674:	f8 87       	std	Y+8, r31	; 0x08

		i = 0;
			
		_tracks[trackIndex].eventByte = sendDummy(); // this should be the event byte
     676:	34 01       	movw	r6, r8
     678:	fc e0       	ldi	r31, 0x0C	; 12
     67a:	6f 0e       	add	r6, r31
     67c:	71 1c       	adc	r7, r1
	{

			
		//Clear data buff and determine the variable length time
		data[0] = 0;
		data[1] = 0;
     67e:	1a 82       	std	Y+2, r1	; 0x02
		data[2] = 0;
     680:	1b 82       	std	Y+3, r1	; 0x03
		data[3] = 0;
     682:	1c 82       	std	Y+4, r1	; 0x04

		//The last byte will not have the MSB set.
		data[0] = sendDummy();
     684:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     688:	89 83       	std	Y+1, r24	; 0x01

		_tracks[trackIndex].addressOffset++;
     68a:	f4 01       	movw	r30, r8
     68c:	40 81       	ld	r20, Z
     68e:	51 81       	ldd	r21, Z+1	; 0x01
     690:	62 81       	ldd	r22, Z+2	; 0x02
     692:	73 81       	ldd	r23, Z+3	; 0x03
     694:	4f 5f       	subi	r20, 0xFF	; 255
     696:	5f 4f       	sbci	r21, 0xFF	; 255
     698:	6f 4f       	sbci	r22, 0xFF	; 255
     69a:	7f 4f       	sbci	r23, 0xFF	; 255
     69c:	40 83       	st	Z, r20
     69e:	51 83       	std	Z+1, r21	; 0x01
     6a0:	62 83       	std	Z+2, r22	; 0x02
     6a2:	73 83       	std	Z+3, r23	; 0x03
		if ((data[0] & 0x80))
     6a4:	87 ff       	sbrs	r24, 7
     6a6:	33 c0       	rjmp	.+102    	; 0x70e <getNextEvent+0xf6>
		{
			data[1] = sendDummy();
     6a8:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     6ac:	8a 83       	std	Y+2, r24	; 0x02
			_tracks[trackIndex].addressOffset++;
     6ae:	f4 01       	movw	r30, r8
     6b0:	40 81       	ld	r20, Z
     6b2:	51 81       	ldd	r21, Z+1	; 0x01
     6b4:	62 81       	ldd	r22, Z+2	; 0x02
     6b6:	73 81       	ldd	r23, Z+3	; 0x03
     6b8:	4f 5f       	subi	r20, 0xFF	; 255
     6ba:	5f 4f       	sbci	r21, 0xFF	; 255
     6bc:	6f 4f       	sbci	r22, 0xFF	; 255
     6be:	7f 4f       	sbci	r23, 0xFF	; 255
     6c0:	40 83       	st	Z, r20
     6c2:	51 83       	std	Z+1, r21	; 0x01
     6c4:	62 83       	std	Z+2, r22	; 0x02
     6c6:	73 83       	std	Z+3, r23	; 0x03
			if ((data[1] & 0x80))
     6c8:	87 ff       	sbrs	r24, 7
     6ca:	21 c0       	rjmp	.+66     	; 0x70e <getNextEvent+0xf6>
			{
				data[2] = sendDummy();
     6cc:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     6d0:	8b 83       	std	Y+3, r24	; 0x03
				_tracks[trackIndex].addressOffset++;
     6d2:	f4 01       	movw	r30, r8
     6d4:	40 81       	ld	r20, Z
     6d6:	51 81       	ldd	r21, Z+1	; 0x01
     6d8:	62 81       	ldd	r22, Z+2	; 0x02
     6da:	73 81       	ldd	r23, Z+3	; 0x03
     6dc:	4f 5f       	subi	r20, 0xFF	; 255
     6de:	5f 4f       	sbci	r21, 0xFF	; 255
     6e0:	6f 4f       	sbci	r22, 0xFF	; 255
     6e2:	7f 4f       	sbci	r23, 0xFF	; 255
     6e4:	40 83       	st	Z, r20
     6e6:	51 83       	std	Z+1, r21	; 0x01
     6e8:	62 83       	std	Z+2, r22	; 0x02
     6ea:	73 83       	std	Z+3, r23	; 0x03
				if ((data[2] & 0x80))
     6ec:	87 ff       	sbrs	r24, 7
     6ee:	0f c0       	rjmp	.+30     	; 0x70e <getNextEvent+0xf6>
				{
					data[3] = sendDummy();
     6f0:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     6f4:	8c 83       	std	Y+4, r24	; 0x04
					_tracks[trackIndex].addressOffset++;
     6f6:	f4 01       	movw	r30, r8
     6f8:	80 81       	ld	r24, Z
     6fa:	91 81       	ldd	r25, Z+1	; 0x01
     6fc:	a2 81       	ldd	r26, Z+2	; 0x02
     6fe:	b3 81       	ldd	r27, Z+3	; 0x03
     700:	01 96       	adiw	r24, 0x01	; 1
     702:	a1 1d       	adc	r26, r1
     704:	b1 1d       	adc	r27, r1
     706:	80 83       	st	Z, r24
     708:	91 83       	std	Z+1, r25	; 0x01
     70a:	a2 83       	std	Z+2, r26	; 0x02
     70c:	b3 83       	std	Z+3, r27	; 0x03
}



uint8_t getNextEvent(uint8_t trackIndex)
{
     70e:	fe 01       	movw	r30, r28
     710:	31 96       	adiw	r30, 0x01	; 1
     712:	80 e0       	ldi	r24, 0x00	; 0
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	dc 01       	movw	r26, r24
	*out_numBytesUsed = 0;
	
	while(*out_numBytesUsed < 4)
	{
		
		value <<= 7;
     718:	07 e0       	ldi	r16, 0x07	; 7
     71a:	88 0f       	add	r24, r24
     71c:	99 1f       	adc	r25, r25
     71e:	aa 1f       	adc	r26, r26
     720:	bb 1f       	adc	r27, r27
     722:	0a 95       	dec	r16
     724:	d1 f7       	brne	.-12     	; 0x71a <getNextEvent+0x102>
		if ((*(first4bytes + *out_numBytesUsed) & 0x80))
     726:	21 91       	ld	r18, Z+
     728:	27 ff       	sbrs	r18, 7
     72a:	09 c0       	rjmp	.+18     	; 0x73e <getNextEvent+0x126>
		{
			value += ((uint32_t)(*(first4bytes + *out_numBytesUsed) & 0x7F));
     72c:	2f 77       	andi	r18, 0x7F	; 127
     72e:	82 0f       	add	r24, r18
     730:	91 1d       	adc	r25, r1
     732:	a1 1d       	adc	r26, r1
     734:	b1 1d       	adc	r27, r1
{
	uint32_t value = 0;
	
	*out_numBytesUsed = 0;
	
	while(*out_numBytesUsed < 4)
     736:	2b 85       	ldd	r18, Y+11	; 0x0b
     738:	2e 13       	cpse	r18, r30
     73a:	ee cf       	rjmp	.-36     	; 0x718 <getNextEvent+0x100>
     73c:	06 c0       	rjmp	.+12     	; 0x74a <getNextEvent+0x132>
		{
			value += ((uint32_t)(*(first4bytes + *out_numBytesUsed) & 0x7F));
		}
		else
		{
			value += *(first4bytes + *out_numBytesUsed);
     73e:	1c 01       	movw	r2, r24
     740:	2d 01       	movw	r4, r26
     742:	22 0e       	add	r2, r18
     744:	31 1c       	adc	r3, r1
     746:	41 1c       	adc	r4, r1
     748:	51 1c       	adc	r5, r1
				}
			}
		}

		//just using 'i' as a temp
		_tracks[trackIndex].deltaTime += getVariableLengthValue(data, &i);
     74a:	ef 81       	ldd	r30, Y+7	; 0x07
     74c:	f8 85       	ldd	r31, Y+8	; 0x08
     74e:	80 81       	ld	r24, Z
     750:	91 81       	ldd	r25, Z+1	; 0x01
     752:	a2 81       	ldd	r26, Z+2	; 0x02
     754:	b3 81       	ldd	r27, Z+3	; 0x03
     756:	82 0d       	add	r24, r2
     758:	93 1d       	adc	r25, r3
     75a:	a4 1d       	adc	r26, r4
     75c:	b5 1d       	adc	r27, r5
     75e:	80 83       	st	Z, r24
     760:	91 83       	std	Z+1, r25	; 0x01
     762:	a2 83       	std	Z+2, r26	; 0x02
     764:	b3 83       	std	Z+3, r27	; 0x03

		i = 0;
			
		_tracks[trackIndex].eventByte = sendDummy(); // this should be the event byte
     766:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     76a:	f3 01       	movw	r30, r6
     76c:	80 83       	st	Z, r24
				
		_tracks[trackIndex].addressOffset++;
     76e:	f4 01       	movw	r30, r8
     770:	80 81       	ld	r24, Z
     772:	91 81       	ldd	r25, Z+1	; 0x01
     774:	a2 81       	ldd	r26, Z+2	; 0x02
     776:	b3 81       	ldd	r27, Z+3	; 0x03
     778:	01 96       	adiw	r24, 0x01	; 1
     77a:	a1 1d       	adc	r26, r1
     77c:	b1 1d       	adc	r27, r1
     77e:	80 83       	st	Z, r24
     780:	91 83       	std	Z+1, r25	; 0x01
     782:	a2 83       	std	Z+2, r26	; 0x02
     784:	b3 83       	std	Z+3, r27	; 0x03
			
		if ((_tracks[trackIndex].eventByte & 0xF0) == MIDI_NOTE_ON_MASK || (_tracks[trackIndex].eventByte & 0xF0) == MIDI_NOTE_OFF_MASK || (_tracks[trackIndex].eventByte & 0xF0) == MIDI_PITCH_BEND_MASK)
     786:	f3 01       	movw	r30, r6
     788:	80 81       	ld	r24, Z
     78a:	80 7f       	andi	r24, 0xF0	; 240
     78c:	80 39       	cpi	r24, 0x90	; 144
     78e:	41 f0       	breq	.+16     	; 0x7a0 <getNextEvent+0x188>
     790:	80 81       	ld	r24, Z
     792:	80 7f       	andi	r24, 0xF0	; 240
     794:	80 38       	cpi	r24, 0x80	; 128
     796:	21 f0       	breq	.+8      	; 0x7a0 <getNextEvent+0x188>
     798:	80 81       	ld	r24, Z
     79a:	80 7f       	andi	r24, 0xF0	; 240
     79c:	80 3e       	cpi	r24, 0xE0	; 224
     79e:	f9 f4       	brne	.+62     	; 0x7de <getNextEvent+0x1c6>
		{
			//These are valid events that we want to handle, so capture the next two bytes and move to the next track
				
			_tracks[trackIndex].eventData1 = sendDummy();
     7a0:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     7a4:	9f e0       	ldi	r25, 0x0F	; 15
     7a6:	29 85       	ldd	r18, Y+9	; 0x09
     7a8:	3a 85       	ldd	r19, Y+10	; 0x0a
     7aa:	92 9f       	mul	r25, r18
     7ac:	80 01       	movw	r16, r0
     7ae:	93 9f       	mul	r25, r19
     7b0:	10 0d       	add	r17, r0
     7b2:	11 24       	eor	r1, r1
     7b4:	03 5f       	subi	r16, 0xF3	; 243
     7b6:	1f 4d       	sbci	r17, 0xDF	; 223
     7b8:	f8 01       	movw	r30, r16
     7ba:	85 87       	std	Z+13, r24	; 0x0d
			_tracks[trackIndex].eventData2 = sendDummy();
     7bc:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     7c0:	f8 01       	movw	r30, r16
     7c2:	86 87       	std	Z+14, r24	; 0x0e
			_tracks[trackIndex].addressOffset += 2;
     7c4:	80 81       	ld	r24, Z
     7c6:	91 81       	ldd	r25, Z+1	; 0x01
     7c8:	a2 81       	ldd	r26, Z+2	; 0x02
     7ca:	b3 81       	ldd	r27, Z+3	; 0x03
     7cc:	02 96       	adiw	r24, 0x02	; 2
     7ce:	a1 1d       	adc	r26, r1
     7d0:	b1 1d       	adc	r27, r1
     7d2:	80 83       	st	Z, r24
     7d4:	91 83       	std	Z+1, r25	; 0x01
     7d6:	a2 83       	std	Z+2, r26	; 0x02
     7d8:	b3 83       	std	Z+3, r27	; 0x03

			return 0xFF; 			
     7da:	8f ef       	ldi	r24, 0xFF	; 255
     7dc:	1f c1       	rjmp	.+574    	; 0xa1c <getNextEvent+0x404>
		}
		if ((_tracks[trackIndex].eventByte & 0xF0) == MIDI_POLY_KEY_MASK || (_tracks[trackIndex].eventByte & 0xF0) == MIDI_CTRL_CHANGE_MASK)//if the event is one of these, skip the next two bytes and continue.
     7de:	f3 01       	movw	r30, r6
     7e0:	80 81       	ld	r24, Z
     7e2:	80 7f       	andi	r24, 0xF0	; 240
     7e4:	80 3a       	cpi	r24, 0xA0	; 160
     7e6:	21 f0       	breq	.+8      	; 0x7f0 <getNextEvent+0x1d8>
     7e8:	80 81       	ld	r24, Z
     7ea:	80 7f       	andi	r24, 0xF0	; 240
     7ec:	80 3b       	cpi	r24, 0xB0	; 176
     7ee:	81 f4       	brne	.+32     	; 0x810 <getNextEvent+0x1f8>
		{
			sendDummy();
     7f0:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
			sendDummy();
     7f4:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
			_tracks[trackIndex].addressOffset += 2;
     7f8:	f4 01       	movw	r30, r8
     7fa:	80 81       	ld	r24, Z
     7fc:	91 81       	ldd	r25, Z+1	; 0x01
     7fe:	a2 81       	ldd	r26, Z+2	; 0x02
     800:	b3 81       	ldd	r27, Z+3	; 0x03
     802:	02 96       	adiw	r24, 0x02	; 2
     804:	a1 1d       	adc	r26, r1
     806:	b1 1d       	adc	r27, r1
     808:	80 83       	st	Z, r24
     80a:	91 83       	std	Z+1, r25	; 0x01
     80c:	a2 83       	std	Z+2, r26	; 0x02
     80e:	b3 83       	std	Z+3, r27	; 0x03
		}
		if ( (_tracks[trackIndex].eventByte & 0xF0) == MIDI_PROG_CHANGE_MASK || (_tracks[trackIndex].eventByte & 0xF0) == MIDI_CH_PRESSURE_MASK) //if the event is one of these, skip the next byte and continue.
     810:	f3 01       	movw	r30, r6
     812:	80 81       	ld	r24, Z
     814:	80 7f       	andi	r24, 0xF0	; 240
     816:	80 3c       	cpi	r24, 0xC0	; 192
     818:	21 f0       	breq	.+8      	; 0x822 <getNextEvent+0x20a>
     81a:	80 81       	ld	r24, Z
     81c:	80 7f       	andi	r24, 0xF0	; 240
     81e:	80 3d       	cpi	r24, 0xD0	; 208
     820:	79 f4       	brne	.+30     	; 0x840 <getNextEvent+0x228>
		{
			sendDummy();
     822:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
			_tracks[trackIndex].addressOffset++;
     826:	f4 01       	movw	r30, r8
     828:	80 81       	ld	r24, Z
     82a:	91 81       	ldd	r25, Z+1	; 0x01
     82c:	a2 81       	ldd	r26, Z+2	; 0x02
     82e:	b3 81       	ldd	r27, Z+3	; 0x03
     830:	01 96       	adiw	r24, 0x01	; 1
     832:	a1 1d       	adc	r26, r1
     834:	b1 1d       	adc	r27, r1
     836:	80 83       	st	Z, r24
     838:	91 83       	std	Z+1, r25	; 0x01
     83a:	a2 83       	std	Z+2, r26	; 0x02
     83c:	b3 83       	std	Z+3, r27	; 0x03
     83e:	1f cf       	rjmp	.-450    	; 0x67e <getNextEvent+0x66>
		}
		//Now we have to check other event types to know how far to skip ahead
		else if(_tracks[trackIndex].eventByte == 0xFF) //Meta-Events
     840:	f3 01       	movw	r30, r6
     842:	80 81       	ld	r24, Z
     844:	8f 3f       	cpi	r24, 0xFF	; 255
     846:	09 f0       	breq	.+2      	; 0x84a <getNextEvent+0x232>
     848:	1a cf       	rjmp	.-460    	; 0x67e <getNextEvent+0x66>
		{
			data[0] = sendDummy(); //Get the event type
     84a:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     84e:	89 83       	std	Y+1, r24	; 0x01
			_tracks[trackIndex].addressOffset++;
     850:	f4 01       	movw	r30, r8
     852:	40 81       	ld	r20, Z
     854:	51 81       	ldd	r21, Z+1	; 0x01
     856:	62 81       	ldd	r22, Z+2	; 0x02
     858:	73 81       	ldd	r23, Z+3	; 0x03
     85a:	4f 5f       	subi	r20, 0xFF	; 255
     85c:	5f 4f       	sbci	r21, 0xFF	; 255
     85e:	6f 4f       	sbci	r22, 0xFF	; 255
     860:	7f 4f       	sbci	r23, 0xFF	; 255
     862:	40 83       	st	Z, r20
     864:	51 83       	std	Z+1, r21	; 0x01
     866:	62 83       	std	Z+2, r22	; 0x02
     868:	73 83       	std	Z+3, r23	; 0x03
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(data[0])
     86a:	8f 32       	cpi	r24, 0x2F	; 47
     86c:	09 f4       	brne	.+2      	; 0x870 <getNextEvent+0x258>
     86e:	d6 c0       	rjmp	.+428    	; 0xa1c <getNextEvent+0x404>
     870:	58 f4       	brcc	.+22     	; 0x888 <getNextEvent+0x270>
     872:	8a 30       	cpi	r24, 0x0A	; 10
     874:	20 f4       	brcc	.+8      	; 0x87e <getNextEvent+0x266>
     876:	81 30       	cpi	r24, 0x01	; 1
     878:	c8 f4       	brcc	.+50     	; 0x8ac <getNextEvent+0x294>
			{
				case 0x00:
					i = 1;
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	ba c0       	rjmp	.+372    	; 0x9f2 <getNextEvent+0x3da>
		else if(_tracks[trackIndex].eventByte == 0xFF) //Meta-Events
		{
			data[0] = sendDummy(); //Get the event type
			_tracks[trackIndex].addressOffset++;
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(data[0])
     87e:	80 32       	cpi	r24, 0x20	; 32
     880:	09 f0       	breq	.+2      	; 0x884 <getNextEvent+0x26c>
     882:	b6 c0       	rjmp	.+364    	; 0x9f0 <getNextEvent+0x3d8>
				case 0x09:
					i = sendDummy(); //next byte is len of text
					_tracks[trackIndex].addressOffset++;
					break;
				case 0x20:
					i = 2;
     884:	82 e0       	ldi	r24, 0x02	; 2
					break;
     886:	b5 c0       	rjmp	.+362    	; 0x9f2 <getNextEvent+0x3da>
		else if(_tracks[trackIndex].eventByte == 0xFF) //Meta-Events
		{
			data[0] = sendDummy(); //Get the event type
			_tracks[trackIndex].addressOffset++;
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(data[0])
     888:	88 35       	cpi	r24, 0x58	; 88
     88a:	09 f4       	brne	.+2      	; 0x88e <getNextEvent+0x276>
     88c:	9d c0       	rjmp	.+314    	; 0x9c8 <getNextEvent+0x3b0>
     88e:	38 f4       	brcc	.+14     	; 0x89e <getNextEvent+0x286>
     890:	81 35       	cpi	r24, 0x51	; 81
     892:	e1 f0       	breq	.+56     	; 0x8cc <getNextEvent+0x2b4>
     894:	84 35       	cpi	r24, 0x54	; 84
     896:	09 f0       	breq	.+2      	; 0x89a <getNextEvent+0x282>
     898:	ab c0       	rjmp	.+342    	; 0x9f0 <getNextEvent+0x3d8>
					TCC0.PER = (_tempo/(uint32_t)_division) / 4; //Divided by 4 so we can fit larger values. Timer clock also div4
					_tracks[trackIndex].addressOffset += 4;
					i = 0;
					break;
				case 0x54:
					i = 6;
     89a:	86 e0       	ldi	r24, 0x06	; 6
					break;
     89c:	aa c0       	rjmp	.+340    	; 0x9f2 <getNextEvent+0x3da>
		else if(_tracks[trackIndex].eventByte == 0xFF) //Meta-Events
		{
			data[0] = sendDummy(); //Get the event type
			_tracks[trackIndex].addressOffset++;
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(data[0])
     89e:	89 35       	cpi	r24, 0x59	; 89
     8a0:	09 f4       	brne	.+2      	; 0x8a4 <getNextEvent+0x28c>
     8a2:	94 c0       	rjmp	.+296    	; 0x9cc <getNextEvent+0x3b4>
     8a4:	87 3f       	cpi	r24, 0xF7	; 247
     8a6:	09 f4       	brne	.+2      	; 0x8aa <getNextEvent+0x292>
     8a8:	93 c0       	rjmp	.+294    	; 0x9d0 <getNextEvent+0x3b8>
     8aa:	a2 c0       	rjmp	.+324    	; 0x9f0 <getNextEvent+0x3d8>
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
					i = sendDummy(); //next byte is len of text
     8ac:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
					_tracks[trackIndex].addressOffset++;
     8b0:	f4 01       	movw	r30, r8
     8b2:	40 81       	ld	r20, Z
     8b4:	51 81       	ldd	r21, Z+1	; 0x01
     8b6:	62 81       	ldd	r22, Z+2	; 0x02
     8b8:	73 81       	ldd	r23, Z+3	; 0x03
     8ba:	4f 5f       	subi	r20, 0xFF	; 255
     8bc:	5f 4f       	sbci	r21, 0xFF	; 255
     8be:	6f 4f       	sbci	r22, 0xFF	; 255
     8c0:	7f 4f       	sbci	r23, 0xFF	; 255
     8c2:	40 83       	st	Z, r20
     8c4:	51 83       	std	Z+1, r21	; 0x01
     8c6:	62 83       	std	Z+2, r22	; 0x02
     8c8:	73 83       	std	Z+3, r23	; 0x03
					break;
     8ca:	93 c0       	rjmp	.+294    	; 0x9f2 <getNextEvent+0x3da>
					break;
				case 0x2F: //End of track
					return 0x2F; 
				case 0x51:
					// skip the 0x03 control byte
					sendDummy();
     8cc:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
					//read in the data bytes for the tempo
					data[0] = sendDummy();
     8d0:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     8d4:	18 2f       	mov	r17, r24
     8d6:	89 83       	std	Y+1, r24	; 0x01
					data[1] = sendDummy();
     8d8:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     8dc:	08 2f       	mov	r16, r24
     8de:	8a 83       	std	Y+2, r24	; 0x02
					data[2] = sendDummy();
     8e0:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     8e4:	28 2f       	mov	r18, r24
     8e6:	8b 83       	std	Y+3, r24	; 0x03
					//This is all used to calculate the period value for the timer to correctly set the tempo
					_tempo = ((uint32_t)data[0] << 16) + ((uint32_t)data[1] << 8) + data[2];
     8e8:	81 2f       	mov	r24, r17
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	a0 e0       	ldi	r26, 0x00	; 0
     8ee:	b0 e0       	ldi	r27, 0x00	; 0
     8f0:	dc 01       	movw	r26, r24
     8f2:	99 27       	eor	r25, r25
     8f4:	88 27       	eor	r24, r24
     8f6:	40 2f       	mov	r20, r16
     8f8:	50 e0       	ldi	r21, 0x00	; 0
     8fa:	60 e0       	ldi	r22, 0x00	; 0
     8fc:	70 e0       	ldi	r23, 0x00	; 0
     8fe:	76 2f       	mov	r23, r22
     900:	65 2f       	mov	r22, r21
     902:	54 2f       	mov	r21, r20
     904:	44 27       	eor	r20, r20
     906:	84 0f       	add	r24, r20
     908:	95 1f       	adc	r25, r21
     90a:	a6 1f       	adc	r26, r22
     90c:	b7 1f       	adc	r27, r23
     90e:	82 0f       	add	r24, r18
     910:	91 1d       	adc	r25, r1
     912:	a1 1d       	adc	r26, r1
     914:	b1 1d       	adc	r27, r1
     916:	80 93 85 20 	sts	0x2085, r24	; 0x802085 <_tempo>
     91a:	90 93 86 20 	sts	0x2086, r25	; 0x802086 <_tempo+0x1>
     91e:	a0 93 87 20 	sts	0x2087, r26	; 0x802087 <_tempo+0x2>
     922:	b0 93 88 20 	sts	0x2088, r27	; 0x802088 <_tempo+0x3>
					_tempo = ((uint64_t)F_CPU * _tempo) / 1000000;
     926:	60 91 85 20 	lds	r22, 0x2085	; 0x802085 <_tempo>
     92a:	70 91 86 20 	lds	r23, 0x2086	; 0x802086 <_tempo+0x1>
     92e:	80 91 87 20 	lds	r24, 0x2087	; 0x802087 <_tempo+0x2>
     932:	90 91 88 20 	lds	r25, 0x2088	; 0x802088 <_tempo+0x3>
     936:	20 e0       	ldi	r18, 0x00	; 0
     938:	3d e2       	ldi	r19, 0x2D	; 45
     93a:	41 e3       	ldi	r20, 0x31	; 49
     93c:	51 e0       	ldi	r21, 0x01	; 1
     93e:	0e 94 d7 08 	call	0x11ae	; 0x11ae <__umulsidi3>
     942:	f0 e4       	ldi	r31, 0x40	; 64
     944:	af 2e       	mov	r10, r31
     946:	a2 e4       	ldi	r26, 0x42	; 66
     948:	ba 2e       	mov	r11, r26
     94a:	bf e0       	ldi	r27, 0x0F	; 15
     94c:	cb 2e       	mov	r12, r27
     94e:	d1 2c       	mov	r13, r1
     950:	e1 2c       	mov	r14, r1
     952:	f1 2c       	mov	r15, r1
     954:	00 e0       	ldi	r16, 0x00	; 0
     956:	10 e0       	ldi	r17, 0x00	; 0
     958:	0e 94 04 09 	call	0x1208	; 0x1208 <__udivdi3>
     95c:	c9 01       	movw	r24, r18
     95e:	da 01       	movw	r26, r20
     960:	80 93 85 20 	sts	0x2085, r24	; 0x802085 <_tempo>
     964:	90 93 86 20 	sts	0x2086, r25	; 0x802086 <_tempo+0x1>
     968:	a0 93 87 20 	sts	0x2087, r26	; 0x802087 <_tempo+0x2>
     96c:	b0 93 88 20 	sts	0x2088, r27	; 0x802088 <_tempo+0x3>
					TCC0.PER = (_tempo/(uint32_t)_division) / 4; //Divided by 4 so we can fit larger values. Timer clock also div4
     970:	60 91 85 20 	lds	r22, 0x2085	; 0x802085 <_tempo>
     974:	70 91 86 20 	lds	r23, 0x2086	; 0x802086 <_tempo+0x1>
     978:	80 91 87 20 	lds	r24, 0x2087	; 0x802087 <_tempo+0x2>
     97c:	90 91 88 20 	lds	r25, 0x2088	; 0x802088 <_tempo+0x3>
     980:	20 91 0b 20 	lds	r18, 0x200B	; 0x80200b <_division>
     984:	30 91 0c 20 	lds	r19, 0x200C	; 0x80200c <_division+0x1>
     988:	03 2e       	mov	r0, r19
     98a:	00 0c       	add	r0, r0
     98c:	44 0b       	sbc	r20, r20
     98e:	55 0b       	sbc	r21, r21
     990:	0e 94 b5 08 	call	0x116a	; 0x116a <__udivmodsi4>
     994:	da 01       	movw	r26, r20
     996:	c9 01       	movw	r24, r18
     998:	12 e0       	ldi	r17, 0x02	; 2
     99a:	b6 95       	lsr	r27
     99c:	a7 95       	ror	r26
     99e:	97 95       	ror	r25
     9a0:	87 95       	ror	r24
     9a2:	1a 95       	dec	r17
     9a4:	d1 f7       	brne	.-12     	; 0x99a <getNextEvent+0x382>
     9a6:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     9aa:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
					_tracks[trackIndex].addressOffset += 4;
     9ae:	f4 01       	movw	r30, r8
     9b0:	80 81       	ld	r24, Z
     9b2:	91 81       	ldd	r25, Z+1	; 0x01
     9b4:	a2 81       	ldd	r26, Z+2	; 0x02
     9b6:	b3 81       	ldd	r27, Z+3	; 0x03
     9b8:	04 96       	adiw	r24, 0x04	; 4
     9ba:	a1 1d       	adc	r26, r1
     9bc:	b1 1d       	adc	r27, r1
     9be:	80 83       	st	Z, r24
     9c0:	91 83       	std	Z+1, r25	; 0x01
     9c2:	a2 83       	std	Z+2, r26	; 0x02
     9c4:	b3 83       	std	Z+3, r27	; 0x03
     9c6:	14 c0       	rjmp	.+40     	; 0x9f0 <getNextEvent+0x3d8>
					break;
				case 0x54:
					i = 6;
					break;
				case 0x58:
				i = 5;
     9c8:	85 e0       	ldi	r24, 0x05	; 5
				break;
     9ca:	13 c0       	rjmp	.+38     	; 0x9f2 <getNextEvent+0x3da>
				case 0x59:
				i = 3;
     9cc:	83 e0       	ldi	r24, 0x03	; 3
				break;
     9ce:	11 c0       	rjmp	.+34     	; 0x9f2 <getNextEvent+0x3da>
				case 0xF7:
				//TODO: Finish looking at this length
				while(1)
				{
					_tracks[trackIndex].addressOffset++;
     9d0:	f4 01       	movw	r30, r8
     9d2:	80 81       	ld	r24, Z
     9d4:	91 81       	ldd	r25, Z+1	; 0x01
     9d6:	a2 81       	ldd	r26, Z+2	; 0x02
     9d8:	b3 81       	ldd	r27, Z+3	; 0x03
     9da:	01 96       	adiw	r24, 0x01	; 1
     9dc:	a1 1d       	adc	r26, r1
     9de:	b1 1d       	adc	r27, r1
     9e0:	80 83       	st	Z, r24
     9e2:	91 83       	std	Z+1, r25	; 0x01
     9e4:	a2 83       	std	Z+2, r26	; 0x02
     9e6:	b3 83       	std	Z+3, r27	; 0x03
					if (sendDummy() == 0xF7)
     9e8:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     9ec:	87 3f       	cpi	r24, 0xF7	; 247
     9ee:	81 f7       	brne	.-32     	; 0x9d0 <getNextEvent+0x3b8>
		}

		//just using 'i' as a temp
		_tracks[trackIndex].deltaTime += getVariableLengthValue(data, &i);

		i = 0;
     9f0:	80 e0       	ldi	r24, 0x00	; 0
				}
				i = 0;
				break;
			}
				
			_tracks[trackIndex].addressOffset += i;
     9f2:	f4 01       	movw	r30, r8
     9f4:	40 81       	ld	r20, Z
     9f6:	51 81       	ldd	r21, Z+1	; 0x01
     9f8:	62 81       	ldd	r22, Z+2	; 0x02
     9fa:	73 81       	ldd	r23, Z+3	; 0x03
     9fc:	48 0f       	add	r20, r24
     9fe:	51 1d       	adc	r21, r1
     a00:	61 1d       	adc	r22, r1
     a02:	71 1d       	adc	r23, r1
     a04:	40 83       	st	Z, r20
     a06:	51 83       	std	Z+1, r21	; 0x01
     a08:	62 83       	std	Z+2, r22	; 0x02
     a0a:	73 83       	std	Z+3, r23	; 0x03
			//skip some bytes
			while(i--)
     a0c:	18 2f       	mov	r17, r24
     a0e:	11 23       	and	r17, r17
     a10:	09 f4       	brne	.+2      	; 0xa14 <getNextEvent+0x3fc>
     a12:	35 ce       	rjmp	.-918    	; 0x67e <getNextEvent+0x66>
			{
				sendDummy();
     a14:	0e 94 42 01 	call	0x284	; 0x284 <sendDummy>
     a18:	11 50       	subi	r17, 0x01	; 1
     a1a:	f9 cf       	rjmp	.-14     	; 0xa0e <getNextEvent+0x3f6>
		}
			
	}
	
	return 0x00;
}
     a1c:	2b 96       	adiw	r28, 0x0b	; 11
     a1e:	cd bf       	out	0x3d, r28	; 61
     a20:	de bf       	out	0x3e, r29	; 62
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	0f 91       	pop	r16
     a2a:	ff 90       	pop	r15
     a2c:	ef 90       	pop	r14
     a2e:	df 90       	pop	r13
     a30:	cf 90       	pop	r12
     a32:	bf 90       	pop	r11
     a34:	af 90       	pop	r10
     a36:	9f 90       	pop	r9
     a38:	8f 90       	pop	r8
     a3a:	7f 90       	pop	r7
     a3c:	6f 90       	pop	r6
     a3e:	5f 90       	pop	r5
     a40:	4f 90       	pop	r4
     a42:	3f 90       	pop	r3
     a44:	2f 90       	pop	r2
     a46:	08 95       	ret

00000a48 <getFirstEvent>:


uint8_t getFirstEvent(uint8_t *trackIndex, uint32_t trackStart)
{
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	00 d0       	rcall	.+0      	; 0xa52 <getFirstEvent+0xa>
     a52:	1f 92       	push	r1
     a54:	cd b7       	in	r28, 0x3d	; 61
     a56:	de b7       	in	r29, 0x3e	; 62
     a58:	8c 01       	movw	r16, r24
	waitForNotBusy();
     a5a:	49 83       	std	Y+1, r20	; 0x01
     a5c:	5a 83       	std	Y+2, r21	; 0x02
     a5e:	6b 83       	std	Y+3, r22	; 0x03
     a60:	7c 83       	std	Y+4, r23	; 0x04
     a62:	0e 94 70 01 	call	0x2e0	; 0x2e0 <waitForNotBusy>
	
	CS_DISABLE();
     a66:	80 e1       	ldi	r24, 0x10	; 16
     a68:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	CS_ENABLE();
     a6c:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
	sendSPI(MEM_READ);
     a70:	83 e0       	ldi	r24, 0x03	; 3
     a72:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
	memSendAddress(trackStart);
     a76:	49 81       	ldd	r20, Y+1	; 0x01
     a78:	5a 81       	ldd	r21, Y+2	; 0x02
     a7a:	6b 81       	ldd	r22, Y+3	; 0x03
     a7c:	7c 81       	ldd	r23, Y+4	; 0x04
     a7e:	cb 01       	movw	r24, r22
     a80:	ba 01       	movw	r22, r20
     a82:	0e 94 45 01 	call	0x28a	; 0x28a <memSendAddress>
	
	if (getNextEvent(*trackIndex) == 0xFF) //Checking 0xFF explicitly because there might be a 0x2F returned.
     a86:	f8 01       	movw	r30, r16
     a88:	80 81       	ld	r24, Z
     a8a:	0e 94 0c 03 	call	0x618	; 0x618 <getNextEvent>
     a8e:	8f 3f       	cpi	r24, 0xFF	; 255
     a90:	21 f4       	brne	.+8      	; 0xa9a <getFirstEvent+0x52>
	{
		(*trackIndex)++;
     a92:	f8 01       	movw	r30, r16
     a94:	80 81       	ld	r24, Z
     a96:	8f 5f       	subi	r24, 0xFF	; 255
     a98:	80 83       	st	Z, r24
	}
	
	CS_DISABLE();
     a9a:	80 e1       	ldi	r24, 0x10	; 16
     a9c:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	
	return 0x00;
}
     aa0:	80 e0       	ldi	r24, 0x00	; 0
     aa2:	24 96       	adiw	r28, 0x04	; 4
     aa4:	cd bf       	out	0x3d, r28	; 61
     aa6:	de bf       	out	0x3e, r29	; 62
     aa8:	df 91       	pop	r29
     aaa:	cf 91       	pop	r28
     aac:	1f 91       	pop	r17
     aae:	0f 91       	pop	r16
     ab0:	08 95       	ret

00000ab2 <getMidiTracks>:

//Gets up to the max number of MIDI tracks. Scans each track for notes. Ignores if no notes found
//Uses _trackCount 
//Sets _trackCount, _tracks
uint8_t getMidiTracks()
{
     ab2:	4f 92       	push	r4
     ab4:	5f 92       	push	r5
     ab6:	6f 92       	push	r6
     ab8:	7f 92       	push	r7
     aba:	8f 92       	push	r8
     abc:	9f 92       	push	r9
     abe:	af 92       	push	r10
     ac0:	bf 92       	push	r11
     ac2:	cf 92       	push	r12
     ac4:	df 92       	push	r13
     ac6:	ef 92       	push	r14
     ac8:	ff 92       	push	r15
     aca:	0f 93       	push	r16
     acc:	1f 93       	push	r17
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	cd b7       	in	r28, 0x3d	; 61
     ad4:	de b7       	in	r29, 0x3e	; 62
     ad6:	25 97       	sbiw	r28, 0x05	; 5
     ad8:	cd bf       	out	0x3d, r28	; 61
     ada:	de bf       	out	0x3e, r29	; 62
	uint8_t i = 0;
	uint8_t cnt = 0;
	uint8_t usedTracks = 0;
     adc:	1d 82       	std	Y+5, r1	; 0x05
	uint32_t trackStart = (uint32_t)MIDI_FIRST_TRACK_OFFSET + _fileAddressOffset + 4;// + 4 to skip the track header	
     ade:	c0 90 03 20 	lds	r12, 0x2003	; 0x802003 <_fileAddressOffset>
     ae2:	d0 90 04 20 	lds	r13, 0x2004	; 0x802004 <_fileAddressOffset+0x1>
     ae6:	e0 90 05 20 	lds	r14, 0x2005	; 0x802005 <_fileAddressOffset+0x2>
     aea:	f0 90 06 20 	lds	r15, 0x2006	; 0x802006 <_fileAddressOffset+0x3>
     aee:	82 e1       	ldi	r24, 0x12	; 18
     af0:	c8 0e       	add	r12, r24
     af2:	d1 1c       	adc	r13, r1
     af4:	e1 1c       	adc	r14, r1
     af6:	f1 1c       	adc	r15, r1
//Uses _trackCount 
//Sets _trackCount, _tracks
uint8_t getMidiTracks()
{
	uint8_t i = 0;
	uint8_t cnt = 0;
     af8:	10 e0       	ldi	r17, 0x00	; 0
	
	
	 while (cnt < _tractCount && usedTracks < MIDI_MAX_MIDI_TRACKS) 
	{
		//Clear the track data
		_tracks[cnt].eventByte = 0;
     afa:	0f e0       	ldi	r16, 0x0F	; 15
	uint8_t data[4];
	uint8_t done = 0;
	uint32_t trackLen = 0;
	
	
	 while (cnt < _tractCount && usedTracks < MIDI_MAX_MIDI_TRACKS) 
     afc:	90 91 02 20 	lds	r25, 0x2002	; 0x802002 <_tractCount>
     b00:	8d 81       	ldd	r24, Y+5	; 0x05
     b02:	19 17       	cp	r17, r25
     b04:	08 f0       	brcs	.+2      	; 0xb08 <getMidiTracks+0x56>
     b06:	68 c0       	rjmp	.+208    	; 0xbd8 <getMidiTracks+0x126>
     b08:	88 30       	cpi	r24, 0x08	; 8
     b0a:	08 f0       	brcs	.+2      	; 0xb0e <getMidiTracks+0x5c>
     b0c:	65 c0       	rjmp	.+202    	; 0xbd8 <getMidiTracks+0x126>
	{
		//Clear the track data
		_tracks[cnt].eventByte = 0;
     b0e:	01 9f       	mul	r16, r17
     b10:	f0 01       	movw	r30, r0
     b12:	11 24       	eor	r1, r1
     b14:	e3 5f       	subi	r30, 0xF3	; 243
     b16:	ff 4d       	sbci	r31, 0xDF	; 223
     b18:	14 86       	std	Z+12, r1	; 0x0c
		_tracks[usedTracks].eventData1 = 0;
     b1a:	08 9f       	mul	r16, r24
     b1c:	f0 01       	movw	r30, r0
     b1e:	11 24       	eor	r1, r1
     b20:	e3 5f       	subi	r30, 0xF3	; 243
     b22:	ff 4d       	sbci	r31, 0xDF	; 223
     b24:	15 86       	std	Z+13, r1	; 0x0d
		_tracks[usedTracks].eventData2 = 0;
     b26:	16 86       	std	Z+14, r1	; 0x0e
		_tracks[usedTracks].addressOffset = 0;
     b28:	10 82       	st	Z, r1
     b2a:	11 82       	std	Z+1, r1	; 0x01
     b2c:	12 82       	std	Z+2, r1	; 0x02
     b2e:	13 82       	std	Z+3, r1	; 0x03
		_tracks[usedTracks].startAddress = 0;
     b30:	14 82       	std	Z+4, r1	; 0x04
     b32:	15 82       	std	Z+5, r1	; 0x05
     b34:	16 82       	std	Z+6, r1	; 0x06
     b36:	17 82       	std	Z+7, r1	; 0x07

		//Get the length of the track
		memReadToBuffer(trackStart, data, 4); 
     b38:	24 e0       	ldi	r18, 0x04	; 4
     b3a:	ae 01       	movw	r20, r28
     b3c:	4f 5f       	subi	r20, 0xFF	; 255
     b3e:	5f 4f       	sbci	r21, 0xFF	; 255
     b40:	c7 01       	movw	r24, r14
     b42:	b6 01       	movw	r22, r12
     b44:	0e 94 75 01 	call	0x2ea	; 0x2ea <memReadToBuffer>

		//_tracks[usedTracks].trackLength = ((uint32_t)data[0] << 24) + ((uint32_t)data[1] << 16) + ((uint32_t)data[2] << 8) + ((uint32_t)data[3] << 0);
		trackLen = ((uint32_t)data[0] << 24) + ((uint32_t)data[1] << 16) + ((uint32_t)data[2] << 8) + ((uint32_t)data[3] << 0);
     b48:	8b 80       	ldd	r8, Y+3	; 0x03
     b4a:	91 2c       	mov	r9, r1
     b4c:	a1 2c       	mov	r10, r1
     b4e:	b1 2c       	mov	r11, r1
     b50:	ba 2c       	mov	r11, r10
     b52:	a9 2c       	mov	r10, r9
     b54:	98 2c       	mov	r9, r8
     b56:	88 24       	eor	r8, r8
     b58:	4c 80       	ldd	r4, Y+4	; 0x04
     b5a:	51 2c       	mov	r5, r1
     b5c:	61 2c       	mov	r6, r1
     b5e:	71 2c       	mov	r7, r1
     b60:	84 e0       	ldi	r24, 0x04	; 4
     b62:	48 0e       	add	r4, r24
     b64:	51 1c       	adc	r5, r1
     b66:	61 1c       	adc	r6, r1
     b68:	71 1c       	adc	r7, r1
     b6a:	99 81       	ldd	r25, Y+1	; 0x01
     b6c:	89 2f       	mov	r24, r25
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	b8 2f       	mov	r27, r24
     b76:	aa 27       	eor	r26, r26
     b78:	99 27       	eor	r25, r25
     b7a:	88 27       	eor	r24, r24
     b7c:	84 0d       	add	r24, r4
     b7e:	95 1d       	adc	r25, r5
     b80:	a6 1d       	adc	r26, r6
     b82:	b7 1d       	adc	r27, r7
     b84:	4a 80       	ldd	r4, Y+2	; 0x02
     b86:	51 2c       	mov	r5, r1
     b88:	61 2c       	mov	r6, r1
     b8a:	71 2c       	mov	r7, r1
     b8c:	32 01       	movw	r6, r4
     b8e:	55 24       	eor	r5, r5
     b90:	44 24       	eor	r4, r4
     b92:	48 0e       	add	r4, r24
     b94:	59 1e       	adc	r5, r25
     b96:	6a 1e       	adc	r6, r26
     b98:	7b 1e       	adc	r7, r27
		
		trackStart += 4; //move the trackStart to after the length
     b9a:	84 e0       	ldi	r24, 0x04	; 4
     b9c:	c8 0e       	add	r12, r24
     b9e:	d1 1c       	adc	r13, r1
     ba0:	e1 1c       	adc	r14, r1
     ba2:	f1 1c       	adc	r15, r1
		//set the start of the track
		_tracks[usedTracks].startAddress = trackStart;
     ba4:	ed 81       	ldd	r30, Y+5	; 0x05
     ba6:	0e 9f       	mul	r16, r30
     ba8:	f0 01       	movw	r30, r0
     baa:	11 24       	eor	r1, r1
     bac:	e3 5f       	subi	r30, 0xF3	; 243
     bae:	ff 4d       	sbci	r31, 0xDF	; 223
     bb0:	c4 82       	std	Z+4, r12	; 0x04
     bb2:	d5 82       	std	Z+5, r13	; 0x05
     bb4:	e6 82       	std	Z+6, r14	; 0x06
     bb6:	f7 82       	std	Z+7, r15	; 0x07
		
		//scan the track for a starting note. If no note-on found, skip the track
		//Doing a continuous read for better performance
		getFirstEvent(&usedTracks, trackStart);
     bb8:	b7 01       	movw	r22, r14
     bba:	a6 01       	movw	r20, r12
     bbc:	ce 01       	movw	r24, r28
     bbe:	05 96       	adiw	r24, 0x05	; 5
     bc0:	0e 94 24 05 	call	0xa48	; 0xa48 <getFirstEvent>
     bc4:	84 0c       	add	r8, r4
     bc6:	95 1c       	adc	r9, r5
     bc8:	a6 1c       	adc	r10, r6
     bca:	b7 1c       	adc	r11, r7

		//Update the trackStart here because we will need it later.
		trackStart += trackLen + 4;
     bcc:	c8 0c       	add	r12, r8
     bce:	d9 1c       	adc	r13, r9
     bd0:	ea 1c       	adc	r14, r10
     bd2:	fb 1c       	adc	r15, r11
				
		cnt++;
     bd4:	1f 5f       	subi	r17, 0xFF	; 255
     bd6:	92 cf       	rjmp	.-220    	; 0xafc <getMidiTracks+0x4a>
		
	}
	
	return usedTracks;
}
     bd8:	25 96       	adiw	r28, 0x05	; 5
     bda:	cd bf       	out	0x3d, r28	; 61
     bdc:	de bf       	out	0x3e, r29	; 62
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	ff 90       	pop	r15
     be8:	ef 90       	pop	r14
     bea:	df 90       	pop	r13
     bec:	cf 90       	pop	r12
     bee:	bf 90       	pop	r11
     bf0:	af 90       	pop	r10
     bf2:	9f 90       	pop	r9
     bf4:	8f 90       	pop	r8
     bf6:	7f 90       	pop	r7
     bf8:	6f 90       	pop	r6
     bfa:	5f 90       	pop	r5
     bfc:	4f 90       	pop	r4
     bfe:	08 95       	ret

00000c00 <loadFile>:
	_fileAddressOffset = FILE_COUNT_ADDR + 2 + (_fileCount * 4);
}

uint8_t loadFile(uint16_t index)
{
	_fileIndex = index;
     c00:	80 93 07 20 	sts	0x2007, r24	; 0x802007 <_fileIndex>
     c04:	90 93 08 20 	sts	0x2008, r25	; 0x802008 <_fileIndex+0x1>
	moveToFile();
     c08:	0e 94 cc 01 	call	0x398	; 0x398 <moveToFile>
	getTrackCount();
     c0c:	0e 94 a8 02 	call	0x550	; 0x550 <getTrackCount>
	getTimeDivision();
     c10:	0e 94 ca 02 	call	0x594	; 0x594 <getTimeDivision>
	_tractCount = getMidiTracks();
     c14:	0e 94 59 05 	call	0xab2	; 0xab2 <getMidiTracks>
     c18:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <_tractCount>
	_activeTracks = _tractCount;
     c1c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <_tractCount>
     c20:	80 93 01 20 	sts	0x2001, r24	; 0x802001 <_activeTracks>
}
     c24:	08 95       	ret

00000c26 <moveToNext>:
	TIMER_DISABLE();
}

static void  moveToNext()
{
	_fileIndex++;
     c26:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     c2a:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     c2e:	01 96       	adiw	r24, 0x01	; 1
     c30:	80 93 07 20 	sts	0x2007, r24	; 0x802007 <_fileIndex>
     c34:	90 93 08 20 	sts	0x2008, r25	; 0x802008 <_fileIndex+0x1>
	if (_fileIndex >= _fileCount)
     c38:	20 91 07 20 	lds	r18, 0x2007	; 0x802007 <_fileIndex>
     c3c:	30 91 08 20 	lds	r19, 0x2008	; 0x802008 <_fileIndex+0x1>
     c40:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
     c44:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
     c48:	28 17       	cp	r18, r24
     c4a:	39 07       	cpc	r19, r25
     c4c:	20 f0       	brcs	.+8      	; 0xc56 <moveToNext+0x30>
	{
		_fileIndex = 0;
     c4e:	10 92 07 20 	sts	0x2007, r1	; 0x802007 <_fileIndex>
     c52:	10 92 08 20 	sts	0x2008, r1	; 0x802008 <_fileIndex+0x1>
	}
			
	stopMidi(); //to stop the current notes that are playing
     c56:	0e 94 1f 01 	call	0x23e	; 0x23e <stopMidi>
	loadFile(_fileIndex);
     c5a:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     c5e:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     c62:	0e 94 00 06 	call	0xc00	; 0xc00 <loadFile>
	startMidi();	
     c66:	0c 94 25 01 	jmp	0x24a	; 0x24a <startMidi>

00000c6a <main>:
int main(void)
{
	uint8_t data[2];
	uint8_t usedTracks;
	
	cli();
     c6a:	f8 94       	cli
volatile uint8_t _statusFlags; //7 = Paused, 6 = Updating play mode, 5 = reserved, 4 = reserved, 3:2 = play mode, 1 = button 1 down, 0 = button 0 down


static inline void initClk()
{
	OSC.CTRL = OSC_RC2MEN_bm;
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
	while(!(OSC.STATUS &   OSC_RC2MRDY_bm));   //wait for stability
     c72:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
     c76:	80 ff       	sbrs	r24, 0
     c78:	fc cf       	rjmp	.-8      	; 0xc72 <main+0x8>
	
	OSC.PLLCTRL = OSC_PLLSRC_RC2M_gc | 10;
     c7a:	8a e0       	ldi	r24, 0x0A	; 10
     c7c:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
	OSC.CTRL |= OSC_PLLEN_bm;
     c80:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
     c84:	80 61       	ori	r24, 0x10	; 16
     c86:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
	while(!(OSC.STATUS &   OSC_PLLRDY_bm));   //wait for stability
     c8a:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
     c8e:	84 ff       	sbrs	r24, 4
     c90:	fc cf       	rjmp	.-8      	; 0xc8a <main+0x20>

	CCP = CCP_IOREG_gc; //secured access
     c92:	88 ed       	ldi	r24, 0xD8	; 216
     c94:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = CLK_SCLKSEL_PLL_gc; //choose this osc source as clk
     c96:	34 e0       	ldi	r19, 0x04	; 4
     c98:	30 93 40 00 	sts	0x0040, r19	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
}

static inline void initSPI()
{
	PORTC.DIRSET = PIN4_bm | PIN5_bm | PIN7_bm;
     c9c:	80 eb       	ldi	r24, 0xB0	; 176
     c9e:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
	PORTC.DIRCLR = PIN6_bm;
     ca2:	80 e4       	ldi	r24, 0x40	; 64
     ca4:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
	SPIC.CTRL =  SPI_CLK2X_bm | SPI_ENABLE_bm | SPI_MASTER_bm | SPI_PRESCALER_DIV16_gc;
     ca8:	81 ed       	ldi	r24, 0xD1	; 209
     caa:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7008c0>
}

static inline void initMidiUART()
{
	PORTD.DIRSET = PIN3_bm;
     cae:	28 e0       	ldi	r18, 0x08	; 8
     cb0:	20 93 61 06 	sts	0x0661, r18	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	USARTD0.BAUDCTRLA = 81;
     cb4:	81 e5       	ldi	r24, 0x51	; 81
     cb6:	80 93 a6 09 	sts	0x09A6, r24	; 0x8009a6 <__TEXT_REGION_LENGTH__+0x7009a6>
	USARTD0.BAUDCTRLB = 0 << 4; //Set the bsel to 1 and the bscale to 6
     cba:	10 92 a7 09 	sts	0x09A7, r1	; 0x8009a7 <__TEXT_REGION_LENGTH__+0x7009a7>
	USARTD0.CTRLB = USART_TXEN_bm | USART_CLK2X_bm;
     cbe:	8c e0       	ldi	r24, 0x0C	; 12
     cc0:	80 93 a4 09 	sts	0x09A4, r24	; 0x8009a4 <__TEXT_REGION_LENGTH__+0x7009a4>
	USARTD0.CTRLC = USART_CHSIZE_8BIT_gc;
     cc4:	83 e0       	ldi	r24, 0x03	; 3
     cc6:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <__TEXT_REGION_LENGTH__+0x7009a5>
	
}

static inline void initInterrupts()
{
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
     cca:	90 91 a2 00 	lds	r25, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cce:	97 60       	ori	r25, 0x07	; 7
     cd0:	90 93 a2 00 	sts	0x00A2, r25	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	TCC1.PER = MIDI_INPUT_TIMER_PER; //Should cause this to tick at about 100Hz (every 10ms)
}

static inline void initMidiTimer()
{
	TCC0.CTRLA = TC_TC0_CLKSEL_OFF_gc;
     cd4:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
	TCC0.INTCTRLA = TC_TC0_OVFINTLVL_HI_gc;
     cd8:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <__TEXT_REGION_LENGTH__+0x700806>
	TCC0.PER = TIMER_PER_FOR_120BPM;	
     cdc:	49 e8       	ldi	r20, 0x89	; 137
     cde:	59 e0       	ldi	r21, 0x09	; 9
     ce0:	40 93 26 08 	sts	0x0826, r20	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     ce4:	50 93 27 08 	sts	0x0827, r21	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
	
}

static inline void initInputTimer()
{
	TCC1.CTRLA = TC_TC1_CLKSEL_DIV8_gc;
     ce8:	30 93 40 08 	sts	0x0840, r19	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
	TCC1.INTCTRLA = TC_TC1_OVFINTLVL_HI_gc;
     cec:	80 93 46 08 	sts	0x0846, r24	; 0x800846 <__TEXT_REGION_LENGTH__+0x700846>
	TCC1.PER = MIDI_INPUT_TIMER_PER; //Should cause this to tick at about 100Hz (every 10ms)
     cf0:	88 ea       	ldi	r24, 0xA8	; 168
     cf2:	91 e6       	ldi	r25, 0x61	; 97
     cf4:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <__TEXT_REGION_LENGTH__+0x700866>
     cf8:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <__TEXT_REGION_LENGTH__+0x700867>
	TCC0.PER = TIMER_PER_FOR_120BPM;	
}

static inline void initInputADC()
{
	ADCA.CTRLB = ADC_IMPMODE_bm | ADC_CURRLIMIT_LOW_gc | ADC_RESOLUTION_8BIT_gc;
     cfc:	84 ea       	ldi	r24, 0xA4	; 164
     cfe:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
	ADCA.REFCTRL = ADC_REFSEL_AREFA_gc;
     d02:	c0 e2       	ldi	r28, 0x20	; 32
     d04:	c0 93 02 02 	sts	0x0202, r28	; 0x800202 <__TEXT_REGION_LENGTH__+0x700202>
	ADCA.PRESCALER = ADC_PRESCALER_DIV512_gc;
     d08:	87 e0       	ldi	r24, 0x07	; 7
     d0a:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <__TEXT_REGION_LENGTH__+0x700204>
	ADCA.CH1.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	80 93 28 02 	sts	0x0228, r24	; 0x800228 <__TEXT_REGION_LENGTH__+0x700228>
	ADCA.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
     d14:	20 93 29 02 	sts	0x0229, r18	; 0x800229 <__TEXT_REGION_LENGTH__+0x700229>
	ADCA.CTRLA = ADC_ENABLE_bm;
     d18:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__TEXT_REGION_LENGTH__+0x700200>
	initInterrupts();
	initMidiTimer();
	initInputTimer();
	initInputADC();
	
	sei();
     d1c:	78 94       	sei
}

static inline void initMemory()
{

	getFileCount();
     d1e:	0e 94 ac 01 	call	0x358	; 0x358 <getFileCount>
	_fileAddressOffset = FILE_COUNT_ADDR + 2 + (_fileCount * 4);
     d22:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
     d26:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
     d2a:	88 0f       	add	r24, r24
     d2c:	99 1f       	adc	r25, r25
     d2e:	88 0f       	add	r24, r24
     d30:	99 1f       	adc	r25, r25
     d32:	8a 5f       	subi	r24, 0xFA	; 250
     d34:	9f 4e       	sbci	r25, 0xEF	; 239
     d36:	a0 e0       	ldi	r26, 0x00	; 0
     d38:	b0 e0       	ldi	r27, 0x00	; 0
     d3a:	80 93 03 20 	sts	0x2003, r24	; 0x802003 <_fileAddressOffset>
     d3e:	90 93 04 20 	sts	0x2004, r25	; 0x802004 <_fileAddressOffset+0x1>
     d42:	a0 93 05 20 	sts	0x2005, r26	; 0x802005 <_fileAddressOffset+0x2>
     d46:	b0 93 06 20 	sts	0x2006, r27	; 0x802006 <_fileAddressOffset+0x3>
	
	sei();
			
	initMemory();
	
	PORTA.DIRSET = PIN5_bm;
     d4a:	c0 93 01 06 	sts	0x0601, r28	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	
	_fileIndex = 0xFFFFFF; //so it rolls over to the correct file with the very first button click.
     d4e:	8f ef       	ldi	r24, 0xFF	; 255
     d50:	9f ef       	ldi	r25, 0xFF	; 255
     d52:	80 93 07 20 	sts	0x2007, r24	; 0x802007 <_fileIndex>
     d56:	90 93 08 20 	sts	0x2008, r25	; 0x802008 <_fileIndex+0x1>
	for(uint16_t i = 0; i < _tractCount; i++)
	{

		//getNextEvent requires the memory to be in continuous read mode. This is an optimization to speed up reading the next event
		waitForNotBusy();	
		CS_DISABLE();
     d5a:	30 e1       	ldi	r19, 0x10	; 16
     d5c:	93 2e       	mov	r9, r19
		CS_ENABLE();
		sendSPI(MEM_READ);
		memSendAddress(_tracks[i].startAddress + _tracks[i].addressOffset);
     d5e:	4f e0       	ldi	r20, 0x0F	; 15
     d60:	84 2e       	mov	r8, r20
	
	_fileIndex = 0xFFFFFF; //so it rolls over to the correct file with the very first button click.
	
    while (1) 
    {
		if (_clockTickFlag)
     d62:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <_edata>
     d66:	88 23       	and	r24, r24
     d68:	09 f4       	brne	.+2      	; 0xd6c <main+0x102>
     d6a:	c0 c0       	rjmp	.+384    	; 0xeec <main+0x282>
     d6c:	00 e0       	ldi	r16, 0x00	; 0
     d6e:	10 e0       	ldi	r17, 0x00	; 0
	//3: goto 1.
	uint8_t prevEventByte;
	uint8_t prevNote;
	uint8_t out = 0;

	for(uint16_t i = 0; i < _tractCount; i++)
     d70:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <_tractCount>
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	08 17       	cp	r16, r24
     d78:	19 07       	cpc	r17, r25
     d7a:	08 f0       	brcs	.+2      	; 0xd7e <main+0x114>
     d7c:	b5 c0       	rjmp	.+362    	; 0xee8 <main+0x27e>
	{

		//getNextEvent requires the memory to be in continuous read mode. This is an optimization to speed up reading the next event
		waitForNotBusy();	
     d7e:	0e 94 70 01 	call	0x2e0	; 0x2e0 <waitForNotBusy>
		CS_DISABLE();
     d82:	90 92 45 06 	sts	0x0645, r9	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
		CS_ENABLE();
     d86:	90 92 46 06 	sts	0x0646, r9	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
		sendSPI(MEM_READ);
     d8a:	83 e0       	ldi	r24, 0x03	; 3
     d8c:	0e 94 39 01 	call	0x272	; 0x272 <sendSPI>
		memSendAddress(_tracks[i].startAddress + _tracks[i].addressOffset);
     d90:	80 9e       	mul	r8, r16
     d92:	e0 01       	movw	r28, r0
     d94:	81 9e       	mul	r8, r17
     d96:	d0 0d       	add	r29, r0
     d98:	11 24       	eor	r1, r1
     d9a:	c3 5f       	subi	r28, 0xF3	; 243
     d9c:	df 4d       	sbci	r29, 0xDF	; 223
     d9e:	8c 81       	ldd	r24, Y+4	; 0x04
     da0:	9d 81       	ldd	r25, Y+5	; 0x05
     da2:	ae 81       	ldd	r26, Y+6	; 0x06
     da4:	bf 81       	ldd	r27, Y+7	; 0x07
     da6:	48 81       	ld	r20, Y
     da8:	59 81       	ldd	r21, Y+1	; 0x01
     daa:	6a 81       	ldd	r22, Y+2	; 0x02
     dac:	7b 81       	ldd	r23, Y+3	; 0x03
     dae:	6a 01       	movw	r12, r20
     db0:	7b 01       	movw	r14, r22
     db2:	c8 0e       	add	r12, r24
     db4:	d9 1e       	adc	r13, r25
     db6:	ea 1e       	adc	r14, r26
     db8:	fb 1e       	adc	r15, r27
     dba:	c7 01       	movw	r24, r14
     dbc:	b6 01       	movw	r22, r12
     dbe:	0e 94 45 01 	call	0x28a	; 0x28a <memSendAddress>
												
		//Get the next event and keep sending as long as the deltatime is 0										
		while(1)
		{	
			if (!_tracks[i].eventByte) //if there is no event, skip ahead
     dc2:	7e 01       	movw	r14, r28
     dc4:	8c e0       	ldi	r24, 0x0C	; 12
     dc6:	e8 0e       	add	r14, r24
     dc8:	f1 1c       	adc	r15, r1
			{
				break;
			}
							
			if (!_tracks[i].deltaTime) //A DeltaTime has reached 0;
     dca:	5e 01       	movw	r10, r28
     dcc:	e8 e0       	ldi	r30, 0x08	; 8
     dce:	ae 0e       	add	r10, r30
     dd0:	b1 1c       	adc	r11, r1
			{
					
				prevEventByte = _tracks[i].eventByte;
				prevNote = _tracks[i].eventData1;
     dd2:	6e 01       	movw	r12, r28
     dd4:	fd e0       	ldi	r31, 0x0D	; 13
     dd6:	cf 0e       	add	r12, r31
     dd8:	d1 1c       	adc	r13, r1
				sendMidi(_tracks[i].eventByte);
				sendMidi(_tracks[i].eventData1);
				sendMidi(_tracks[i].eventData2);
     dda:	2e 96       	adiw	r28, 0x0e	; 14
		memSendAddress(_tracks[i].startAddress + _tracks[i].addressOffset);
												
		//Get the next event and keep sending as long as the deltatime is 0										
		while(1)
		{	
			if (!_tracks[i].eventByte) //if there is no event, skip ahead
     ddc:	f7 01       	movw	r30, r14
     dde:	80 81       	ld	r24, Z
     de0:	88 23       	and	r24, r24
     de2:	09 f4       	brne	.+2      	; 0xde6 <main+0x17c>
     de4:	42 c0       	rjmp	.+132    	; 0xe6a <main+0x200>
			{
				break;
			}
							
			if (!_tracks[i].deltaTime) //A DeltaTime has reached 0;
     de6:	f5 01       	movw	r30, r10
     de8:	80 81       	ld	r24, Z
     dea:	91 81       	ldd	r25, Z+1	; 0x01
     dec:	a2 81       	ldd	r26, Z+2	; 0x02
     dee:	b3 81       	ldd	r27, Z+3	; 0x03
     df0:	89 2b       	or	r24, r25
     df2:	8a 2b       	or	r24, r26
     df4:	8b 2b       	or	r24, r27
     df6:	c9 f5       	brne	.+114    	; 0xe6a <main+0x200>
			{
					
				prevEventByte = _tracks[i].eventByte;
     df8:	f7 01       	movw	r30, r14
     dfa:	70 80       	ld	r7, Z
				prevNote = _tracks[i].eventData1;
     dfc:	f6 01       	movw	r30, r12
     dfe:	60 80       	ld	r6, Z
				sendMidi(_tracks[i].eventByte);
     e00:	f7 01       	movw	r30, r14
     e02:	80 81       	ld	r24, Z
     e04:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
				sendMidi(_tracks[i].eventData1);
     e08:	f6 01       	movw	r30, r12
     e0a:	80 81       	ld	r24, Z
     e0c:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
				sendMidi(_tracks[i].eventData2);
     e10:	88 81       	ld	r24, Y
     e12:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
				
				out = getNextEvent(i);
     e16:	80 2f       	mov	r24, r16
     e18:	0e 94 0c 03 	call	0x618	; 0x618 <getNextEvent>
				if (out == 0)
     e1c:	88 23       	and	r24, r24
     e1e:	29 f1       	breq	.+74     	; 0xe6a <main+0x200>
				{
					break;
				}		
				
				if (out == 0x2F)
     e20:	8f 32       	cpi	r24, 0x2F	; 47
     e22:	f1 f0       	breq	.+60     	; 0xe60 <main+0x1f6>
				{
					_activeTracks--;
					break;
				}
				if ((prevEventByte & 0xF0) == MIDI_NOTE_ON_MASK && (_tracks[i].eventByte & 0xF0) == MIDI_NOTE_OFF_MASK && _tracks[i].deltaTime == 0 && prevNote == _tracks[i].eventData1) // Skipping a note off if it was 0 length since the last.
     e24:	87 2d       	mov	r24, r7
     e26:	80 7f       	andi	r24, 0xF0	; 240
     e28:	80 39       	cpi	r24, 0x90	; 144
     e2a:	c1 f6       	brne	.-80     	; 0xddc <main+0x172>
     e2c:	f7 01       	movw	r30, r14
     e2e:	80 81       	ld	r24, Z
     e30:	80 7f       	andi	r24, 0xF0	; 240
     e32:	80 38       	cpi	r24, 0x80	; 128
     e34:	99 f6       	brne	.-90     	; 0xddc <main+0x172>
     e36:	f5 01       	movw	r30, r10
     e38:	80 81       	ld	r24, Z
     e3a:	91 81       	ldd	r25, Z+1	; 0x01
     e3c:	a2 81       	ldd	r26, Z+2	; 0x02
     e3e:	b3 81       	ldd	r27, Z+3	; 0x03
     e40:	89 2b       	or	r24, r25
     e42:	8a 2b       	or	r24, r26
     e44:	8b 2b       	or	r24, r27
     e46:	51 f6       	brne	.-108    	; 0xddc <main+0x172>
     e48:	f6 01       	movw	r30, r12
     e4a:	80 81       	ld	r24, Z
     e4c:	68 12       	cpse	r6, r24
     e4e:	c6 cf       	rjmp	.-116    	; 0xddc <main+0x172>
				{

					out = getNextEvent(i);
     e50:	80 2f       	mov	r24, r16
     e52:	0e 94 0c 03 	call	0x618	; 0x618 <getNextEvent>
					if (out == 0)
     e56:	88 23       	and	r24, r24
     e58:	41 f0       	breq	.+16     	; 0xe6a <main+0x200>
					{
						break;
					}
					
					if (out == 0x2F)
     e5a:	8f 32       	cpi	r24, 0x2F	; 47
     e5c:	09 f0       	breq	.+2      	; 0xe60 <main+0x1f6>
     e5e:	be cf       	rjmp	.-132    	; 0xddc <main+0x172>
					{
						_activeTracks--;
     e60:	80 91 01 20 	lds	r24, 0x2001	; 0x802001 <_activeTracks>
     e64:	81 50       	subi	r24, 0x01	; 1
     e66:	80 93 01 20 	sts	0x2001, r24	; 0x802001 <_activeTracks>
			else
			{
				break;
			}
		}
		CS_DISABLE();
     e6a:	90 92 45 06 	sts	0x0645, r9	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>

		//Just to avoid overflowing deltatime (since it's a 32 bit number). This may actually be slower and it may not matter in the end
		if(_tracks[i].deltaTime)						
     e6e:	80 9e       	mul	r8, r16
     e70:	f0 01       	movw	r30, r0
     e72:	81 9e       	mul	r8, r17
     e74:	f0 0d       	add	r31, r0
     e76:	11 24       	eor	r1, r1
     e78:	e3 5f       	subi	r30, 0xF3	; 243
     e7a:	ff 4d       	sbci	r31, 0xDF	; 223
     e7c:	80 85       	ldd	r24, Z+8	; 0x08
     e7e:	91 85       	ldd	r25, Z+9	; 0x09
     e80:	a2 85       	ldd	r26, Z+10	; 0x0a
     e82:	b3 85       	ldd	r27, Z+11	; 0x0b
     e84:	89 2b       	or	r24, r25
     e86:	8a 2b       	or	r24, r26
     e88:	8b 2b       	or	r24, r27
     e8a:	59 f0       	breq	.+22     	; 0xea2 <main+0x238>
		{
			_tracks[i].deltaTime--;	
     e8c:	80 85       	ldd	r24, Z+8	; 0x08
     e8e:	91 85       	ldd	r25, Z+9	; 0x09
     e90:	a2 85       	ldd	r26, Z+10	; 0x0a
     e92:	b3 85       	ldd	r27, Z+11	; 0x0b
     e94:	01 97       	sbiw	r24, 0x01	; 1
     e96:	a1 09       	sbc	r26, r1
     e98:	b1 09       	sbc	r27, r1
     e9a:	80 87       	std	Z+8, r24	; 0x08
     e9c:	91 87       	std	Z+9, r25	; 0x09
     e9e:	a2 87       	std	Z+10, r26	; 0x0a
     ea0:	b3 87       	std	Z+11, r27	; 0x0b
		}	
		
		//Here we are checking to see if any tracks are left playing and disabling the timer if there are none.
		//This also handles what to do next for play modes.
		if (!_activeTracks)
     ea2:	80 91 01 20 	lds	r24, 0x2001	; 0x802001 <_activeTracks>
     ea6:	81 11       	cpse	r24, r1
     ea8:	1c c0       	rjmp	.+56     	; 0xee2 <main+0x278>
		{
			TIMER_DISABLE();
     eaa:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
			//If mode 2, we just stop
			stopMidi();
     eae:	0e 94 1f 01 	call	0x23e	; 0x23e <stopMidi>
			
			if (((_statusFlags >> 2) & INPUT_PLAY_MODE_SHIFTED_MAKS) == 1) //Loop mode
     eb2:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     eb6:	86 95       	lsr	r24
     eb8:	86 95       	lsr	r24
     eba:	83 70       	andi	r24, 0x03	; 3
     ebc:	81 30       	cpi	r24, 0x01	; 1
     ebe:	49 f4       	brne	.+18     	; 0xed2 <main+0x268>
			{
				loadFile(_fileIndex);
     ec0:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
     ec4:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
     ec8:	0e 94 00 06 	call	0xc00	; 0xc00 <loadFile>
				startMidi();						
     ecc:	0e 94 25 01 	call	0x24a	; 0x24a <startMidi>
     ed0:	08 c0       	rjmp	.+16     	; 0xee2 <main+0x278>
			}
			else if (((_statusFlags >> 2) & INPUT_PLAY_MODE_SHIFTED_MAKS) == 0) //Continuous mode
     ed2:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     ed6:	86 95       	lsr	r24
     ed8:	86 95       	lsr	r24
     eda:	83 70       	andi	r24, 0x03	; 3
     edc:	11 f4       	brne	.+4      	; 0xee2 <main+0x278>
			{
				moveToNext();
     ede:	0e 94 13 06 	call	0xc26	; 0xc26 <moveToNext>
	//3: goto 1.
	uint8_t prevEventByte;
	uint8_t prevNote;
	uint8_t out = 0;

	for(uint16_t i = 0; i < _tractCount; i++)
     ee2:	0f 5f       	subi	r16, 0xFF	; 255
     ee4:	1f 4f       	sbci	r17, 0xFF	; 255
     ee6:	44 cf       	rjmp	.-376    	; 0xd70 <main+0x106>
    while (1) 
    {
		if (_clockTickFlag)
		{
			handleClockTick();
			_clockTickFlag = 0x00;
     ee8:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <_edata>

static void checkButtons()
{
				
	//NOTE: Counts are guaranteed not to roll over
	if (_input0Counts >= 100) //approx 1000ms hold
     eec:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <_input0Counts>
     ef0:	84 36       	cpi	r24, 0x64	; 100
     ef2:	08 f4       	brcc	.+2      	; 0xef6 <main+0x28c>
     ef4:	44 c0       	rjmp	.+136    	; 0xf7e <main+0x314>
	{
		if (!(_statusFlags & INPUT_PLAY_MODE_UPDATING_MASK)) //If already in updating mode, do nothing. Basically if the button is still being held, don't try to update play mode again.
     ef6:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     efa:	86 fd       	sbrc	r24, 6
     efc:	74 c0       	rjmp	.+232    	; 0xfe6 <main+0x37c>
		{
			_statusFlags &= ~INPUT_BUTTON_0_MASK; //Clear the button 0 flag to ensure this does not allow the midi to become immediately unpaused
     efe:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f02:	8e 7f       	andi	r24, 0xFE	; 254
     f04:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
			_statusFlags |= INPUT_PLAY_MODE_UPDATING_MASK;
     f08:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f0c:	80 64       	ori	r24, 0x40	; 64
     f0e:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>

//Three play modes: 0 = continuous play, 1 = repeat, 2 = stop after finished with current
//Updates bits 3:2 of the status
static void  updateMidiPlayMode()
{
	if (((_statusFlags >> 2) & INPUT_PLAY_MODE_SHIFTED_MAKS) == 2)
     f12:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f16:	86 95       	lsr	r24
     f18:	86 95       	lsr	r24
     f1a:	83 70       	andi	r24, 0x03	; 3
     f1c:	82 30       	cpi	r24, 0x02	; 2
     f1e:	21 f4       	brne	.+8      	; 0xf28 <main+0x2be>
	{
		_statusFlags &= 0xF3; //Set the play mode to 0
     f20:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f24:	83 7f       	andi	r24, 0xF3	; 243
     f26:	1e c0       	rjmp	.+60     	; 0xf64 <main+0x2fa>
	}
	else if (((_statusFlags >> 2) & INPUT_PLAY_MODE_SHIFTED_MAKS) == 1)
     f28:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f2c:	86 95       	lsr	r24
     f2e:	86 95       	lsr	r24
     f30:	83 70       	andi	r24, 0x03	; 3
     f32:	81 30       	cpi	r24, 0x01	; 1
     f34:	49 f4       	brne	.+18     	; 0xf48 <main+0x2de>
	{
		//first reset to 0
		_statusFlags &= 0xF3; //Clear the play mode bits
     f36:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f3a:	83 7f       	andi	r24, 0xF3	; 243
     f3c:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
		_statusFlags |= 0x08; //Set the play mode to 2
     f40:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f44:	88 60       	ori	r24, 0x08	; 8
     f46:	0e c0       	rjmp	.+28     	; 0xf64 <main+0x2fa>
		
	}
	else if (((_statusFlags >> 2) & INPUT_PLAY_MODE_SHIFTED_MAKS) == 0)
     f48:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f4c:	86 95       	lsr	r24
     f4e:	86 95       	lsr	r24
     f50:	83 70       	andi	r24, 0x03	; 3
     f52:	51 f4       	brne	.+20     	; 0xf68 <main+0x2fe>
	{
		_statusFlags &= 0xF3; //Clear the play mode bits
     f54:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f58:	83 7f       	andi	r24, 0xF3	; 243
     f5a:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
		_statusFlags |= 0x04; //Set the play mode to 1
     f5e:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f62:	84 60       	ori	r24, 0x04	; 4
     f64:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
	}
	
	sendMidi(MIDI_UPDATE_MODE);
     f68:	8d ef       	ldi	r24, 0xFD	; 253
     f6a:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	sendMidi(((_statusFlags >> 2) & 0x3));
     f6e:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f72:	86 95       	lsr	r24
     f74:	86 95       	lsr	r24
     f76:	83 70       	andi	r24, 0x03	; 3
     f78:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
     f7c:	34 c0       	rjmp	.+104    	; 0xfe6 <main+0x37c>
			_statusFlags &= ~INPUT_BUTTON_0_MASK; //Clear the button 0 flag to ensure this does not allow the midi to become immediately unpaused
			_statusFlags |= INPUT_PLAY_MODE_UPDATING_MASK;
			updateMidiPlayMode();
		}
	}
	else if (_input0Counts > 5 && _input1Counts < 100) //approx 50ms hold
     f7e:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <_input0Counts>
     f82:	86 30       	cpi	r24, 0x06	; 6
     f84:	40 f0       	brcs	.+16     	; 0xf96 <main+0x32c>
     f86:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
     f8a:	84 36       	cpi	r24, 0x64	; 100
     f8c:	20 f4       	brcc	.+8      	; 0xf96 <main+0x32c>
	{
		_statusFlags |= INPUT_BUTTON_0_MASK; //second bit indicate button 0 is pressed
     f8e:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     f92:	81 60       	ori	r24, 0x01	; 1
     f94:	26 c0       	rjmp	.+76     	; 0xfe2 <main+0x378>

	}
	else if (_input0Counts == 0)
     f96:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <_input0Counts>
     f9a:	81 11       	cpse	r24, r1
     f9c:	24 c0       	rjmp	.+72     	; 0xfe6 <main+0x37c>
	{
		if ((_statusFlags & INPUT_BUTTON_0_MASK) && !(_statusFlags & INPUT_PLAY_MODE_UPDATING_MASK)) //Only want to move forward or unpause if we didn't just release from a long button 0 hold to update play mode
     f9e:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     fa2:	80 ff       	sbrs	r24, 0
     fa4:	16 c0       	rjmp	.+44     	; 0xfd2 <main+0x368>
     fa6:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     faa:	86 fd       	sbrc	r24, 6
     fac:	12 c0       	rjmp	.+36     	; 0xfd2 <main+0x368>
		{
			if ((_statusFlags & INPUT_PAUSE_MASK)) //In pause mode and button was pressed and released quickly so unpause instead of moving forward
     fae:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     fb2:	87 ff       	sbrs	r24, 7
     fb4:	0c c0       	rjmp	.+24     	; 0xfce <main+0x364>
			{
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
     fb6:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     fba:	8f 77       	andi	r24, 0x7F	; 127
     fbc:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
	TIMER_ENABLE();
}

static void  continueMidi()
{
	sendMidi(MIDI_CONTINUE);
     fc0:	8b ef       	ldi	r24, 0xFB	; 251
     fc2:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	TIMER_ENABLE();
     fc6:	83 e0       	ldi	r24, 0x03	; 3
     fc8:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
     fcc:	02 c0       	rjmp	.+4      	; 0xfd2 <main+0x368>
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
				continueMidi();
			}
			else
			{
				moveToNext();
     fce:	0e 94 13 06 	call	0xc26	; 0xc26 <moveToNext>
			}
		}
			
		//Always reset button down status
		_statusFlags &= ~INPUT_BUTTON_0_MASK; //Clear the button 0 flag
     fd2:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     fd6:	8e 7f       	andi	r24, 0xFE	; 254
     fd8:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
		//Always reset play mode update status
		_statusFlags &= ~INPUT_PLAY_MODE_UPDATING_MASK;
     fdc:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     fe0:	8f 7b       	andi	r24, 0xBF	; 191
     fe2:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
		
		
		
		
	//NOTE: Counts are guaranteed not to roll over
	if (_input1Counts >= 100) //approx 1000ms hold
     fe6:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
     fea:	84 36       	cpi	r24, 0x64	; 100
     fec:	88 f0       	brcs	.+34     	; 0x1010 <main+0x3a6>
	{
		if (!(_statusFlags & INPUT_PAUSE_MASK))	//If already in pause mode, don't pause again
     fee:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     ff2:	87 fd       	sbrc	r24, 7
     ff4:	b6 ce       	rjmp	.-660    	; 0xd62 <main+0xf8>
		{
			_statusFlags |= INPUT_PAUSE_MASK; //set pause status
     ff6:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
     ffa:	80 68       	ori	r24, 0x80	; 128
     ffc:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
			_statusFlags &= ~INPUT_BUTTON_1_MASK; //Clear the button 1 flag to ensure this does not allow the midi to become immediately unpaused
    1000:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
    1004:	8d 7f       	andi	r24, 0xFD	; 253
    1006:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
			stopMidi();
    100a:	0e 94 1f 01 	call	0x23e	; 0x23e <stopMidi>
    100e:	a9 ce       	rjmp	.-686    	; 0xd62 <main+0xf8>
		}
	}
	else if (_input1Counts > 5 && _input1Counts < 100) //approx 50ms hold
    1010:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
    1014:	86 30       	cpi	r24, 0x06	; 6
    1016:	40 f0       	brcs	.+16     	; 0x1028 <main+0x3be>
    1018:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
    101c:	84 36       	cpi	r24, 0x64	; 100
    101e:	20 f4       	brcc	.+8      	; 0x1028 <main+0x3be>
	{
		_statusFlags |= INPUT_BUTTON_1_MASK; //second bit indicate button 1 is pressed
    1020:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
    1024:	82 60       	ori	r24, 0x02	; 2
    1026:	44 c0       	rjmp	.+136    	; 0x10b0 <main+0x446>

	}
	else if (_input1Counts == 0)
    1028:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
    102c:	81 11       	cpse	r24, r1
    102e:	99 ce       	rjmp	.-718    	; 0xd62 <main+0xf8>
	{
		if ( (_statusFlags & INPUT_BUTTON_1_MASK))
    1030:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
    1034:	81 ff       	sbrs	r24, 1
    1036:	39 c0       	rjmp	.+114    	; 0x10aa <main+0x440>
		{
			if ((_statusFlags & INPUT_PAUSE_MASK)) //In pause mode and button was pressed and released quickly so unpause instead of moving forward
    1038:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
    103c:	87 ff       	sbrs	r24, 7
    103e:	0c c0       	rjmp	.+24     	; 0x1058 <main+0x3ee>
			{
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
    1040:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
    1044:	8f 77       	andi	r24, 0x7F	; 127
    1046:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
	TIMER_ENABLE();
}

static void  continueMidi()
{
	sendMidi(MIDI_CONTINUE);
    104a:	8b ef       	ldi	r24, 0xFB	; 251
    104c:	0e 94 18 01 	call	0x230	; 0x230 <sendMidi>
	TIMER_ENABLE();
    1050:	83 e0       	ldi	r24, 0x03	; 3
    1052:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    1056:	29 c0       	rjmp	.+82     	; 0x10aa <main+0x440>
	startMidi();	
}

static void  moveToPrevious()
{
	if (_fileIndex == 0 || _fileIndex >= _fileCount)
    1058:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
    105c:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
    1060:	89 2b       	or	r24, r25
    1062:	59 f0       	breq	.+22     	; 0x107a <main+0x410>
    1064:	20 91 07 20 	lds	r18, 0x2007	; 0x802007 <_fileIndex>
    1068:	30 91 08 20 	lds	r19, 0x2008	; 0x802008 <_fileIndex+0x1>
    106c:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
    1070:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
    1074:	28 17       	cp	r18, r24
    1076:	39 07       	cpc	r19, r25
    1078:	28 f0       	brcs	.+10     	; 0x1084 <main+0x41a>
	{
		_fileIndex = _fileCount - 1;
    107a:	80 91 09 20 	lds	r24, 0x2009	; 0x802009 <_fileCount>
    107e:	90 91 0a 20 	lds	r25, 0x200A	; 0x80200a <_fileCount+0x1>
    1082:	04 c0       	rjmp	.+8      	; 0x108c <main+0x422>
	}
	else
	{
		_fileIndex--;
    1084:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
    1088:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
    108c:	01 97       	sbiw	r24, 0x01	; 1
    108e:	80 93 07 20 	sts	0x2007, r24	; 0x802007 <_fileIndex>
    1092:	90 93 08 20 	sts	0x2008, r25	; 0x802008 <_fileIndex+0x1>
	}
			
	stopMidi(); //to stop the current notes that are playing
    1096:	0e 94 1f 01 	call	0x23e	; 0x23e <stopMidi>
	loadFile(_fileIndex);
    109a:	80 91 07 20 	lds	r24, 0x2007	; 0x802007 <_fileIndex>
    109e:	90 91 08 20 	lds	r25, 0x2008	; 0x802008 <_fileIndex+0x1>
    10a2:	0e 94 00 06 	call	0xc00	; 0xc00 <loadFile>
	startMidi();	
    10a6:	0e 94 25 01 	call	0x24a	; 0x24a <startMidi>
			{
				moveToPrevious();
			}
		}
		//Always reset button down status
		_statusFlags &= ~INPUT_BUTTON_1_MASK; //Clear the button 1 flag
    10aa:	80 91 8b 20 	lds	r24, 0x208B	; 0x80208b <_statusFlags>
    10ae:	8d 7f       	andi	r24, 0xFD	; 253
    10b0:	80 93 8b 20 	sts	0x208B, r24	; 0x80208b <_statusFlags>
    10b4:	56 ce       	rjmp	.-852    	; 0xd62 <main+0xf8>

000010b6 <__vector_14>:
	
    }
}

ISR(TCC0_OVF_vect)
{
    10b6:	1f 92       	push	r1
    10b8:	0f 92       	push	r0
    10ba:	0f b6       	in	r0, 0x3f	; 63
    10bc:	0f 92       	push	r0
    10be:	11 24       	eor	r1, r1
    10c0:	08 b6       	in	r0, 0x38	; 56
    10c2:	0f 92       	push	r0
    10c4:	18 be       	out	0x38, r1	; 56
    10c6:	8f 93       	push	r24
	PORTA.OUTTGL = PIN5_bm;
    10c8:	80 e2       	ldi	r24, 0x20	; 32
    10ca:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <__TEXT_REGION_LENGTH__+0x700607>
	_clockTickFlag = 0xFF;
    10ce:	8f ef       	ldi	r24, 0xFF	; 255
    10d0:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <_edata>
}
    10d4:	8f 91       	pop	r24
    10d6:	0f 90       	pop	r0
    10d8:	08 be       	out	0x38, r0	; 56
    10da:	0f 90       	pop	r0
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	0f 90       	pop	r0
    10e0:	1f 90       	pop	r1
    10e2:	18 95       	reti

000010e4 <__vector_20>:

ISR(TCC1_OVF_vect)
{
    10e4:	1f 92       	push	r1
    10e6:	0f 92       	push	r0
    10e8:	0f b6       	in	r0, 0x3f	; 63
    10ea:	0f 92       	push	r0
    10ec:	11 24       	eor	r1, r1
    10ee:	08 b6       	in	r0, 0x38	; 56
    10f0:	0f 92       	push	r0
    10f2:	18 be       	out	0x38, r1	; 56
    10f4:	8f 93       	push	r24
    10f6:	9f 93       	push	r25
	PORTA.OUTTGL = PIN5_bm;
    10f8:	80 e2       	ldi	r24, 0x20	; 32
    10fa:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <__TEXT_REGION_LENGTH__+0x700607>
	
	uint8_t res;
	ADCA.CH1.CTRL |= ADC_CH_START_bm;
    10fe:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <__TEXT_REGION_LENGTH__+0x700228>
    1102:	80 68       	ori	r24, 0x80	; 128
    1104:	80 93 28 02 	sts	0x0228, r24	; 0x800228 <__TEXT_REGION_LENGTH__+0x700228>
	
	while ((ADCA.CH1.CTRL & ADC_CH_START_bm)) {}
    1108:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <__TEXT_REGION_LENGTH__+0x700228>
    110c:	87 fd       	sbrc	r24, 7
    110e:	fc cf       	rjmp	.-8      	; 0x1108 <__vector_20+0x24>
	
	res = 	ADCA.CH1.RES;
    1110:	80 91 2c 02 	lds	r24, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
    1114:	90 91 2d 02 	lds	r25, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
    1118:	98 2f       	mov	r25, r24
	
	if (res > 120 && res < 250)
    111a:	89 57       	subi	r24, 0x79	; 121
    111c:	81 38       	cpi	r24, 0x81	; 129
    111e:	50 f4       	brcc	.+20     	; 0x1134 <__vector_20+0x50>
	{
		
		if(_input0Counts < 255)
    1120:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <_input0Counts>
    1124:	8f 3f       	cpi	r24, 0xFF	; 255
    1126:	b1 f0       	breq	.+44     	; 0x1154 <__vector_20+0x70>
		{
			_input0Counts++;
    1128:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <_input0Counts>
    112c:	8f 5f       	subi	r24, 0xFF	; 255
    112e:	80 93 8a 20 	sts	0x208A, r24	; 0x80208a <_input0Counts>
    1132:	10 c0       	rjmp	.+32     	; 0x1154 <__vector_20+0x70>
		}
		_input1Counts = 0;
	}
	else if (res >= 250)
    1134:	9a 3f       	cpi	r25, 0xFA	; 250
    1136:	60 f0       	brcs	.+24     	; 0x1150 <__vector_20+0x6c>
	{
		
		if(_input1Counts < 255)
    1138:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
    113c:	8f 3f       	cpi	r24, 0xFF	; 255
    113e:	29 f0       	breq	.+10     	; 0x114a <__vector_20+0x66>
		{
		  _input1Counts++;
    1140:	80 91 89 20 	lds	r24, 0x2089	; 0x802089 <_input1Counts>
    1144:	8f 5f       	subi	r24, 0xFF	; 255
    1146:	80 93 89 20 	sts	0x2089, r24	; 0x802089 <_input1Counts>
		}
		_input0Counts = 0;
    114a:	10 92 8a 20 	sts	0x208A, r1	; 0x80208a <_input0Counts>
    114e:	04 c0       	rjmp	.+8      	; 0x1158 <__vector_20+0x74>
	}
	else
	{
		_input0Counts = 0;
    1150:	10 92 8a 20 	sts	0x208A, r1	; 0x80208a <_input0Counts>
		_input1Counts = 0;		
    1154:	10 92 89 20 	sts	0x2089, r1	; 0x802089 <_input1Counts>
	}
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	0f 90       	pop	r0
    115e:	08 be       	out	0x38, r0	; 56
    1160:	0f 90       	pop	r0
    1162:	0f be       	out	0x3f, r0	; 63
    1164:	0f 90       	pop	r0
    1166:	1f 90       	pop	r1
    1168:	18 95       	reti

0000116a <__udivmodsi4>:
    116a:	a1 e2       	ldi	r26, 0x21	; 33
    116c:	1a 2e       	mov	r1, r26
    116e:	aa 1b       	sub	r26, r26
    1170:	bb 1b       	sub	r27, r27
    1172:	fd 01       	movw	r30, r26
    1174:	0d c0       	rjmp	.+26     	; 0x1190 <__udivmodsi4_ep>

00001176 <__udivmodsi4_loop>:
    1176:	aa 1f       	adc	r26, r26
    1178:	bb 1f       	adc	r27, r27
    117a:	ee 1f       	adc	r30, r30
    117c:	ff 1f       	adc	r31, r31
    117e:	a2 17       	cp	r26, r18
    1180:	b3 07       	cpc	r27, r19
    1182:	e4 07       	cpc	r30, r20
    1184:	f5 07       	cpc	r31, r21
    1186:	20 f0       	brcs	.+8      	; 0x1190 <__udivmodsi4_ep>
    1188:	a2 1b       	sub	r26, r18
    118a:	b3 0b       	sbc	r27, r19
    118c:	e4 0b       	sbc	r30, r20
    118e:	f5 0b       	sbc	r31, r21

00001190 <__udivmodsi4_ep>:
    1190:	66 1f       	adc	r22, r22
    1192:	77 1f       	adc	r23, r23
    1194:	88 1f       	adc	r24, r24
    1196:	99 1f       	adc	r25, r25
    1198:	1a 94       	dec	r1
    119a:	69 f7       	brne	.-38     	; 0x1176 <__udivmodsi4_loop>
    119c:	60 95       	com	r22
    119e:	70 95       	com	r23
    11a0:	80 95       	com	r24
    11a2:	90 95       	com	r25
    11a4:	9b 01       	movw	r18, r22
    11a6:	ac 01       	movw	r20, r24
    11a8:	bd 01       	movw	r22, r26
    11aa:	cf 01       	movw	r24, r30
    11ac:	08 95       	ret

000011ae <__umulsidi3>:
    11ae:	e8 94       	clt

000011b0 <__umulsidi3_helper>:
    11b0:	df 93       	push	r29
    11b2:	cf 93       	push	r28
    11b4:	fc 01       	movw	r30, r24
    11b6:	db 01       	movw	r26, r22
    11b8:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__umulhisi3>
    11bc:	7f 93       	push	r23
    11be:	6f 93       	push	r22
    11c0:	e9 01       	movw	r28, r18
    11c2:	9a 01       	movw	r18, r20
    11c4:	ac 01       	movw	r20, r24
    11c6:	bf 93       	push	r27
    11c8:	af 93       	push	r26
    11ca:	3f 93       	push	r19
    11cc:	2f 93       	push	r18
    11ce:	df 01       	movw	r26, r30
    11d0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__umulhisi3>
    11d4:	26 f4       	brtc	.+8      	; 0x11de <__umulsidi3_helper+0x2e>
    11d6:	6c 1b       	sub	r22, r28
    11d8:	7d 0b       	sbc	r23, r29
    11da:	82 0b       	sbc	r24, r18
    11dc:	93 0b       	sbc	r25, r19
    11de:	9e 01       	movw	r18, r28
    11e0:	eb 01       	movw	r28, r22
    11e2:	fc 01       	movw	r30, r24
    11e4:	0e 94 70 09 	call	0x12e0	; 0x12e0 <__muldi3_6>
    11e8:	af 91       	pop	r26
    11ea:	bf 91       	pop	r27
    11ec:	2f 91       	pop	r18
    11ee:	3f 91       	pop	r19
    11f0:	0e 94 70 09 	call	0x12e0	; 0x12e0 <__muldi3_6>
    11f4:	be 01       	movw	r22, r28
    11f6:	cf 01       	movw	r24, r30
    11f8:	f9 01       	movw	r30, r18
    11fa:	2f 91       	pop	r18
    11fc:	3f 91       	pop	r19
    11fe:	cf 91       	pop	r28
    1200:	df 91       	pop	r29
    1202:	08 95       	ret

00001204 <__umoddi3>:
    1204:	68 94       	set
    1206:	01 c0       	rjmp	.+2      	; 0x120a <__udivdi3_umoddi3>

00001208 <__udivdi3>:
    1208:	e8 94       	clt

0000120a <__udivdi3_umoddi3>:
    120a:	8f 92       	push	r8
    120c:	9f 92       	push	r9
    120e:	cf 93       	push	r28
    1210:	df 93       	push	r29
    1212:	0e 94 10 09 	call	0x1220	; 0x1220 <__udivmod64>
    1216:	df 91       	pop	r29
    1218:	cf 91       	pop	r28
    121a:	9f 90       	pop	r9
    121c:	8f 90       	pop	r8
    121e:	08 95       	ret

00001220 <__udivmod64>:
    1220:	88 24       	eor	r8, r8
    1222:	99 24       	eor	r9, r9
    1224:	f4 01       	movw	r30, r8
    1226:	e4 01       	movw	r28, r8
    1228:	b0 e4       	ldi	r27, 0x40	; 64
    122a:	9f 93       	push	r25
    122c:	aa 27       	eor	r26, r26
    122e:	9a 15       	cp	r25, r10
    1230:	8b 04       	cpc	r8, r11
    1232:	9c 04       	cpc	r9, r12
    1234:	ed 05       	cpc	r30, r13
    1236:	fe 05       	cpc	r31, r14
    1238:	cf 05       	cpc	r28, r15
    123a:	d0 07       	cpc	r29, r16
    123c:	a1 07       	cpc	r26, r17
    123e:	98 f4       	brcc	.+38     	; 0x1266 <__udivmod64+0x46>
    1240:	ad 2f       	mov	r26, r29
    1242:	dc 2f       	mov	r29, r28
    1244:	cf 2f       	mov	r28, r31
    1246:	fe 2f       	mov	r31, r30
    1248:	e9 2d       	mov	r30, r9
    124a:	98 2c       	mov	r9, r8
    124c:	89 2e       	mov	r8, r25
    124e:	98 2f       	mov	r25, r24
    1250:	87 2f       	mov	r24, r23
    1252:	76 2f       	mov	r23, r22
    1254:	65 2f       	mov	r22, r21
    1256:	54 2f       	mov	r21, r20
    1258:	43 2f       	mov	r20, r19
    125a:	32 2f       	mov	r19, r18
    125c:	22 27       	eor	r18, r18
    125e:	b8 50       	subi	r27, 0x08	; 8
    1260:	31 f7       	brne	.-52     	; 0x122e <__udivmod64+0xe>
    1262:	bf 91       	pop	r27
    1264:	27 c0       	rjmp	.+78     	; 0x12b4 <__udivmod64+0x94>
    1266:	1b 2e       	mov	r1, r27
    1268:	bf 91       	pop	r27
    126a:	bb 27       	eor	r27, r27
    126c:	22 0f       	add	r18, r18
    126e:	33 1f       	adc	r19, r19
    1270:	44 1f       	adc	r20, r20
    1272:	55 1f       	adc	r21, r21
    1274:	66 1f       	adc	r22, r22
    1276:	77 1f       	adc	r23, r23
    1278:	88 1f       	adc	r24, r24
    127a:	99 1f       	adc	r25, r25
    127c:	88 1c       	adc	r8, r8
    127e:	99 1c       	adc	r9, r9
    1280:	ee 1f       	adc	r30, r30
    1282:	ff 1f       	adc	r31, r31
    1284:	cc 1f       	adc	r28, r28
    1286:	dd 1f       	adc	r29, r29
    1288:	aa 1f       	adc	r26, r26
    128a:	bb 1f       	adc	r27, r27
    128c:	8a 14       	cp	r8, r10
    128e:	9b 04       	cpc	r9, r11
    1290:	ec 05       	cpc	r30, r12
    1292:	fd 05       	cpc	r31, r13
    1294:	ce 05       	cpc	r28, r14
    1296:	df 05       	cpc	r29, r15
    1298:	a0 07       	cpc	r26, r16
    129a:	b1 07       	cpc	r27, r17
    129c:	48 f0       	brcs	.+18     	; 0x12b0 <__udivmod64+0x90>
    129e:	8a 18       	sub	r8, r10
    12a0:	9b 08       	sbc	r9, r11
    12a2:	ec 09       	sbc	r30, r12
    12a4:	fd 09       	sbc	r31, r13
    12a6:	ce 09       	sbc	r28, r14
    12a8:	df 09       	sbc	r29, r15
    12aa:	a0 0b       	sbc	r26, r16
    12ac:	b1 0b       	sbc	r27, r17
    12ae:	21 60       	ori	r18, 0x01	; 1
    12b0:	1a 94       	dec	r1
    12b2:	e1 f6       	brne	.-72     	; 0x126c <__udivmod64+0x4c>
    12b4:	2e f4       	brtc	.+10     	; 0x12c0 <__udivmod64+0xa0>
    12b6:	94 01       	movw	r18, r8
    12b8:	af 01       	movw	r20, r30
    12ba:	be 01       	movw	r22, r28
    12bc:	cd 01       	movw	r24, r26
    12be:	00 0c       	add	r0, r0
    12c0:	08 95       	ret

000012c2 <__umulhisi3>:
    12c2:	a2 9f       	mul	r26, r18
    12c4:	b0 01       	movw	r22, r0
    12c6:	b3 9f       	mul	r27, r19
    12c8:	c0 01       	movw	r24, r0
    12ca:	a3 9f       	mul	r26, r19
    12cc:	70 0d       	add	r23, r0
    12ce:	81 1d       	adc	r24, r1
    12d0:	11 24       	eor	r1, r1
    12d2:	91 1d       	adc	r25, r1
    12d4:	b2 9f       	mul	r27, r18
    12d6:	70 0d       	add	r23, r0
    12d8:	81 1d       	adc	r24, r1
    12da:	11 24       	eor	r1, r1
    12dc:	91 1d       	adc	r25, r1
    12de:	08 95       	ret

000012e0 <__muldi3_6>:
    12e0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__umulhisi3>
    12e4:	46 0f       	add	r20, r22
    12e6:	57 1f       	adc	r21, r23
    12e8:	c8 1f       	adc	r28, r24
    12ea:	d9 1f       	adc	r29, r25
    12ec:	08 f4       	brcc	.+2      	; 0x12f0 <__muldi3_6+0x10>
    12ee:	31 96       	adiw	r30, 0x01	; 1
    12f0:	08 95       	ret

000012f2 <_exit>:
    12f2:	f8 94       	cli

000012f4 <__stop_program>:
    12f4:	ff cf       	rjmp	.-2      	; 0x12f4 <__stop_program>
