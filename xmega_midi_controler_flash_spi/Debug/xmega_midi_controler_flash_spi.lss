
xmega_midi_controler_flash_spi.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000193e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001e2  00802000  0000193e  000019d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000093  008021e2  008021e2  00001bb4  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001bb4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c10  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  00001c50  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005018  00000000  00000000  00001d88  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002af5  00000000  00000000  00006da0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001239  00000000  00000000  00009895  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005f8  00000000  00000000  0000aad0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003033  00000000  00000000  0000b0c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001493  00000000  00000000  0000e0fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000170  00000000  00000000  0000f58e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 00 01 	jmp	0x200	; 0x200 <__ctors_end>
       4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
       8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
       c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      10:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      14:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      18:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      1c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      20:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      24:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      28:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      2c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      30:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      34:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      38:	0c 94 35 09 	jmp	0x126a	; 0x126a <__vector_14>
      3c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      40:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      44:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      48:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      4c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      50:	0c 94 4c 09 	jmp	0x1298	; 0x1298 <__vector_20>
      54:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      58:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      5c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      60:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      64:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      68:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      6c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      70:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      74:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      78:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      7c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      80:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      84:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      88:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      8c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      90:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      94:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      98:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      9c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      a0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      a4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      a8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      ac:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      b0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      b4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      b8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      bc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      c0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      c4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      c8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      cc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      d0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      d4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      d8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      dc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      e0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      e4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      e8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      ec:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      f0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      f4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      f8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      fc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     100:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     104:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     108:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     10c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     110:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     114:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     118:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     11c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     120:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     124:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     128:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     12c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     130:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     134:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     138:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     13c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     140:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     144:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     148:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     14c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     150:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     154:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     158:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     15c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     160:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     164:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     168:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     16c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     170:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     174:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     178:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     17c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     180:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     184:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     188:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     18c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     190:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     194:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     198:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     19c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1a0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1a4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1a8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1ac:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1b0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1b4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1b8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1bc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1c0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1c4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1c8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1cc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1d0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1d4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1d8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1dc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1e0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1e4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1e8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1ec:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1f0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1f4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1f8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 28 01 	jmp	0x250	; 0x250 <uart_putchar>

00000200 <__ctors_end>:
     200:	11 24       	eor	r1, r1
     202:	1f be       	out	0x3f, r1	; 63
     204:	cf ef       	ldi	r28, 0xFF	; 255
     206:	cd bf       	out	0x3d, r28	; 61
     208:	df e3       	ldi	r29, 0x3F	; 63
     20a:	de bf       	out	0x3e, r29	; 62
     20c:	00 e0       	ldi	r16, 0x00	; 0
     20e:	0c bf       	out	0x3c, r16	; 60
     210:	18 be       	out	0x38, r1	; 56
     212:	19 be       	out	0x39, r1	; 57
     214:	1a be       	out	0x3a, r1	; 58
     216:	1b be       	out	0x3b, r1	; 59

00000218 <__do_copy_data>:
     218:	11 e2       	ldi	r17, 0x21	; 33
     21a:	a0 e0       	ldi	r26, 0x00	; 0
     21c:	b0 e2       	ldi	r27, 0x20	; 32
     21e:	ee e3       	ldi	r30, 0x3E	; 62
     220:	f9 e1       	ldi	r31, 0x19	; 25
     222:	00 e0       	ldi	r16, 0x00	; 0
     224:	0b bf       	out	0x3b, r16	; 59
     226:	02 c0       	rjmp	.+4      	; 0x22c <__do_copy_data+0x14>
     228:	07 90       	elpm	r0, Z+
     22a:	0d 92       	st	X+, r0
     22c:	a2 3e       	cpi	r26, 0xE2	; 226
     22e:	b1 07       	cpc	r27, r17
     230:	d9 f7       	brne	.-10     	; 0x228 <__do_copy_data+0x10>
     232:	1b be       	out	0x3b, r1	; 59

00000234 <__do_clear_bss>:
     234:	22 e2       	ldi	r18, 0x22	; 34
     236:	a2 ee       	ldi	r26, 0xE2	; 226
     238:	b1 e2       	ldi	r27, 0x21	; 33
     23a:	01 c0       	rjmp	.+2      	; 0x23e <.do_clear_bss_start>

0000023c <.do_clear_bss_loop>:
     23c:	1d 92       	st	X+, r1

0000023e <.do_clear_bss_start>:
     23e:	a5 37       	cpi	r26, 0x75	; 117
     240:	b2 07       	cpc	r27, r18
     242:	e1 f7       	brne	.-8      	; 0x23c <.do_clear_bss_loop>
     244:	0e 94 47 06 	call	0xc8e	; 0xc8e <main>
     248:	0c 94 9d 0c 	jmp	0x193a	; 0x193a <_exit>

0000024c <__bad_interrupt>:
     24c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000250 <uart_putchar>:
	}while(--len);
	
	CS_DISABLE();
	return;
	
}
     250:	e0 ea       	ldi	r30, 0xA0	; 160
     252:	fa e0       	ldi	r31, 0x0A	; 10
     254:	91 81       	ldd	r25, Z+1	; 0x01
     256:	95 ff       	sbrs	r25, 5
     258:	fd cf       	rjmp	.-6      	; 0x254 <uart_putchar+0x4>
     25a:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
     25e:	08 95       	ret

00000260 <initClk>:
     260:	82 e0       	ldi	r24, 0x02	; 2
     262:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
     266:	e0 e5       	ldi	r30, 0x50	; 80
     268:	f0 e0       	ldi	r31, 0x00	; 0
     26a:	81 81       	ldd	r24, Z+1	; 0x01
     26c:	81 ff       	sbrs	r24, 1
     26e:	fd cf       	rjmp	.-6      	; 0x26a <initClk+0xa>
     270:	88 ed       	ldi	r24, 0xD8	; 216
     272:	84 bf       	out	0x34, r24	; 52
     274:	81 e0       	ldi	r24, 0x01	; 1
     276:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
     27a:	08 95       	ret

0000027c <initSPI>:
     27c:	e0 e4       	ldi	r30, 0x40	; 64
     27e:	f6 e0       	ldi	r31, 0x06	; 6
     280:	80 eb       	ldi	r24, 0xB0	; 176
     282:	81 83       	std	Z+1, r24	; 0x01
     284:	80 e4       	ldi	r24, 0x40	; 64
     286:	82 83       	std	Z+2, r24	; 0x02
     288:	81 ed       	ldi	r24, 0xD1	; 209
     28a:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7008c0>
     28e:	08 95       	ret

00000290 <initDebugUART>:
     290:	88 e0       	ldi	r24, 0x08	; 8
     292:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     296:	e0 ea       	ldi	r30, 0xA0	; 160
     298:	fa e0       	ldi	r31, 0x0A	; 10
     29a:	84 83       	std	Z+4, r24	; 0x04
     29c:	83 e0       	ldi	r24, 0x03	; 3
     29e:	85 83       	std	Z+5, r24	; 0x05
     2a0:	08 95       	ret

000002a2 <initMidiUART>:
     2a2:	88 e0       	ldi	r24, 0x08	; 8
     2a4:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
     2a8:	e0 ea       	ldi	r30, 0xA0	; 160
     2aa:	f9 e0       	ldi	r31, 0x09	; 9
     2ac:	83 e8       	ldi	r24, 0x83	; 131
     2ae:	86 83       	std	Z+6, r24	; 0x06
     2b0:	17 82       	std	Z+7, r1	; 0x07
     2b2:	8c e0       	ldi	r24, 0x0C	; 12
     2b4:	84 83       	std	Z+4, r24	; 0x04
     2b6:	83 e0       	ldi	r24, 0x03	; 3
     2b8:	85 83       	std	Z+5, r24	; 0x05
     2ba:	08 95       	ret

000002bc <initMidiTimer>:
     2bc:	e0 e4       	ldi	r30, 0x40	; 64
     2be:	f8 e0       	ldi	r31, 0x08	; 8
     2c0:	85 e0       	ldi	r24, 0x05	; 5
     2c2:	80 83       	st	Z, r24
     2c4:	83 e0       	ldi	r24, 0x03	; 3
     2c6:	86 83       	std	Z+6, r24	; 0x06
     2c8:	88 e8       	ldi	r24, 0x88	; 136
     2ca:	93 e1       	ldi	r25, 0x13	; 19
     2cc:	86 a3       	std	Z+38, r24	; 0x26
     2ce:	97 a3       	std	Z+39, r25	; 0x27
     2d0:	08 95       	ret

000002d2 <initInputTimer>:
     2d2:	e0 e0       	ldi	r30, 0x00	; 0
     2d4:	f8 e0       	ldi	r31, 0x08	; 8
     2d6:	10 82       	st	Z, r1
     2d8:	83 e0       	ldi	r24, 0x03	; 3
     2da:	86 83       	std	Z+6, r24	; 0x06
     2dc:	82 e4       	ldi	r24, 0x42	; 66
     2de:	9f e0       	ldi	r25, 0x0F	; 15
     2e0:	86 a3       	std	Z+38, r24	; 0x26
     2e2:	97 a3       	std	Z+39, r25	; 0x27
     2e4:	08 95       	ret

000002e6 <initInputADC>:
     2e6:	e0 e0       	ldi	r30, 0x00	; 0
     2e8:	f2 e0       	ldi	r31, 0x02	; 2
     2ea:	84 ea       	ldi	r24, 0xA4	; 164
     2ec:	81 83       	std	Z+1, r24	; 0x01
     2ee:	80 e2       	ldi	r24, 0x20	; 32
     2f0:	82 83       	std	Z+2, r24	; 0x02
     2f2:	87 e0       	ldi	r24, 0x07	; 7
     2f4:	84 83       	std	Z+4, r24	; 0x04
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	80 a7       	std	Z+40, r24	; 0x28
     2fa:	98 e0       	ldi	r25, 0x08	; 8
     2fc:	91 a7       	std	Z+41, r25	; 0x29
     2fe:	80 83       	st	Z, r24
     300:	08 95       	ret

00000302 <initInterrupts>:
     302:	e0 ea       	ldi	r30, 0xA0	; 160
     304:	f0 e0       	ldi	r31, 0x00	; 0
     306:	82 81       	ldd	r24, Z+2	; 0x02
     308:	87 60       	ori	r24, 0x07	; 7
     30a:	82 83       	std	Z+2, r24	; 0x02
     30c:	08 95       	ret

0000030e <sendMidi>:
     30e:	e0 ea       	ldi	r30, 0xA0	; 160
     310:	f9 e0       	ldi	r31, 0x09	; 9
     312:	91 81       	ldd	r25, Z+1	; 0x01
     314:	95 ff       	sbrs	r25, 5
     316:	fd cf       	rjmp	.-6      	; 0x312 <sendMidi+0x4>
     318:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     31c:	08 95       	ret

0000031e <sendSPI>:
     31e:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
     322:	e0 ec       	ldi	r30, 0xC0	; 192
     324:	f8 e0       	ldi	r31, 0x08	; 8
     326:	82 81       	ldd	r24, Z+2	; 0x02
     328:	88 23       	and	r24, r24
     32a:	ec f7       	brge	.-6      	; 0x326 <sendSPI+0x8>
     32c:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
     330:	08 95       	ret

00000332 <sendDummy>:
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
     338:	08 95       	ret

0000033a <memSendAddress>:
     33a:	cf 93       	push	r28
     33c:	df 93       	push	r29
     33e:	00 d0       	rcall	.+0      	; 0x340 <memSendAddress+0x6>
     340:	1f 92       	push	r1
     342:	cd b7       	in	r28, 0x3d	; 61
     344:	de b7       	in	r29, 0x3e	; 62
     346:	69 83       	std	Y+1, r22	; 0x01
     348:	7a 83       	std	Y+2, r23	; 0x02
     34a:	8b 83       	std	Y+3, r24	; 0x03
     34c:	9c 83       	std	Y+4, r25	; 0x04
     34e:	8b 81       	ldd	r24, Y+3	; 0x03
     350:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
     354:	8a 81       	ldd	r24, Y+2	; 0x02
     356:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
     35a:	89 81       	ldd	r24, Y+1	; 0x01
     35c:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
     360:	24 96       	adiw	r28, 0x04	; 4
     362:	cd bf       	out	0x3d, r28	; 61
     364:	de bf       	out	0x3e, r29	; 62
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <getMemStatus>:
     36c:	1f 93       	push	r17
     36e:	cf 93       	push	r28
     370:	df 93       	push	r29
     372:	c0 e4       	ldi	r28, 0x40	; 64
     374:	d6 e0       	ldi	r29, 0x06	; 6
     376:	10 e1       	ldi	r17, 0x10	; 16
     378:	1d 83       	std	Y+5, r17	; 0x05
     37a:	1e 83       	std	Y+6, r17	; 0x06
     37c:	85 e0       	ldi	r24, 0x05	; 5
     37e:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
     382:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     386:	1d 83       	std	Y+5, r17	; 0x05
     388:	df 91       	pop	r29
     38a:	cf 91       	pop	r28
     38c:	1f 91       	pop	r17
     38e:	08 95       	ret

00000390 <waitForNotBusy>:
     390:	0e 94 b6 01 	call	0x36c	; 0x36c <getMemStatus>
     394:	80 fd       	sbrc	r24, 0
     396:	fc cf       	rjmp	.-8      	; 0x390 <waitForNotBusy>
     398:	08 95       	ret

0000039a <memReadToVariable>:
     39a:	cf 92       	push	r12
     39c:	df 92       	push	r13
     39e:	ef 92       	push	r14
     3a0:	ff 92       	push	r15
     3a2:	0f 93       	push	r16
     3a4:	1f 93       	push	r17
     3a6:	cf 93       	push	r28
     3a8:	6b 01       	movw	r12, r22
     3aa:	7c 01       	movw	r14, r24
     3ac:	8a 01       	movw	r16, r20
     3ae:	c2 2f       	mov	r28, r18
     3b0:	0e 94 c8 01 	call	0x390	; 0x390 <waitForNotBusy>
     3b4:	e0 e4       	ldi	r30, 0x40	; 64
     3b6:	f6 e0       	ldi	r31, 0x06	; 6
     3b8:	80 e1       	ldi	r24, 0x10	; 16
     3ba:	85 83       	std	Z+5, r24	; 0x05
     3bc:	86 83       	std	Z+6, r24	; 0x06
     3be:	83 e0       	ldi	r24, 0x03	; 3
     3c0:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
     3c4:	c7 01       	movw	r24, r14
     3c6:	b6 01       	movw	r22, r12
     3c8:	0e 94 9d 01 	call	0x33a	; 0x33a <memSendAddress>
     3cc:	c1 50       	subi	r28, 0x01	; 1
     3ce:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     3d2:	f8 01       	movw	r30, r16
     3d4:	ec 0f       	add	r30, r28
     3d6:	f1 1d       	adc	r31, r1
     3d8:	80 83       	st	Z, r24
     3da:	c1 11       	cpse	r28, r1
     3dc:	f7 cf       	rjmp	.-18     	; 0x3cc <memReadToVariable+0x32>
     3de:	80 e1       	ldi	r24, 0x10	; 16
     3e0:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
     3e4:	cf 91       	pop	r28
     3e6:	1f 91       	pop	r17
     3e8:	0f 91       	pop	r16
     3ea:	ff 90       	pop	r15
     3ec:	ef 90       	pop	r14
     3ee:	df 90       	pop	r13
     3f0:	cf 90       	pop	r12
     3f2:	08 95       	ret

000003f4 <getFileCount>:
{
	uint8_t data[2];
	//memReadToBuffer(FILE_COUNT_ADDR, data, 2);
	//_fileCount = ((uint16_t)data[0] << 8) + (uint16_t)data[1];	
	//
			printf("Addres of _fileCount %04x\r\n", &_fileCount);
     3f4:	8c ee       	ldi	r24, 0xEC	; 236
     3f6:	91 e2       	ldi	r25, 0x21	; 33
     3f8:	9f 93       	push	r25
     3fa:	8f 93       	push	r24
     3fc:	84 e1       	ldi	r24, 0x14	; 20
     3fe:	90 e2       	ldi	r25, 0x20	; 32
     400:	9f 93       	push	r25
     402:	8f 93       	push	r24
     404:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
	memReadToVariable(FILE_COUNT_ADDR, &_fileCount, 2);
     408:	22 e0       	ldi	r18, 0x02	; 2
     40a:	4c ee       	ldi	r20, 0xEC	; 236
     40c:	51 e2       	ldi	r21, 0x21	; 33
     40e:	64 e0       	ldi	r22, 0x04	; 4
     410:	70 e1       	ldi	r23, 0x10	; 16
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	0e 94 cd 01 	call	0x39a	; 0x39a <memReadToVariable>
	printf("File Count: %u\r\n", _fileCount);
     41a:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     41e:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     422:	9f 93       	push	r25
     424:	8f 93       	push	r24
     426:	80 e3       	ldi	r24, 0x30	; 48
     428:	90 e2       	ldi	r25, 0x20	; 32
     42a:	9f 93       	push	r25
     42c:	8f 93       	push	r24
     42e:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
     432:	8d b7       	in	r24, 0x3d	; 61
     434:	9e b7       	in	r25, 0x3e	; 62
     436:	08 96       	adiw	r24, 0x08	; 8
     438:	8d bf       	out	0x3d, r24	; 61
     43a:	9e bf       	out	0x3e, r25	; 62
     43c:	08 95       	ret

0000043e <moveToFile>:

//Uses _fileIndex
//Sets _fileAddressOffset
//Since we don't need the file names, we will automatically add the name length to the offset
void moveToFile()
{
     43e:	8f 92       	push	r8
     440:	9f 92       	push	r9
     442:	af 92       	push	r10
     444:	bf 92       	push	r11
     446:	ef 92       	push	r14
     448:	ff 92       	push	r15
     44a:	0f 93       	push	r16
     44c:	1f 93       	push	r17
     44e:	cf 93       	push	r28
     450:	df 93       	push	r29
     452:	00 d0       	rcall	.+0      	; 0x454 <moveToFile+0x16>
     454:	00 d0       	rcall	.+0      	; 0x456 <moveToFile+0x18>
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
	
	uint32_t newAddressOffset;
	uint16_t smallAddressOffset;
	//uint8_t data[2];
	uint32_t address = FILE_COUNT_ADDR + 2; //starting address for lookup table is 2 bytes after the size of the total data section.
	_fileAddressOffset = address + (uint32_t)(_fileCount * 4); //first file address is the address of the first lookup table entry + all entries (Which are each 4 bytes)
     45a:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     45e:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     462:	88 0f       	add	r24, r24
     464:	99 1f       	adc	r25, r25
     466:	88 0f       	add	r24, r24
     468:	99 1f       	adc	r25, r25
     46a:	a0 e0       	ldi	r26, 0x00	; 0
     46c:	b0 e0       	ldi	r27, 0x00	; 0
     46e:	8a 5f       	subi	r24, 0xFA	; 250
     470:	9f 4e       	sbci	r25, 0xEF	; 239
     472:	af 4f       	sbci	r26, 0xFF	; 255
     474:	bf 4f       	sbci	r27, 0xFF	; 255
     476:	80 93 e6 21 	sts	0x21E6, r24	; 0x8021e6 <_fileAddressOffset>
     47a:	90 93 e7 21 	sts	0x21E7, r25	; 0x8021e7 <_fileAddressOffset+0x1>
     47e:	a0 93 e8 21 	sts	0x21E8, r26	; 0x8021e8 <_fileAddressOffset+0x2>
     482:	b0 93 e9 21 	sts	0x21E9, r27	; 0x8021e9 <_fileAddressOffset+0x3>
	
	//if the index we are looking for is 0 or the file count is 0, then we can leave the address we initialized _fileAddressOffset to
	if (_fileIndex > 0 && _fileCount > 0)
     486:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     48a:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     48e:	89 2b       	or	r24, r25
     490:	09 f4       	brne	.+2      	; 0x494 <moveToFile+0x56>
     492:	75 c0       	rjmp	.+234    	; 0x57e <moveToFile+0x140>
     494:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     498:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     49c:	89 2b       	or	r24, r25
     49e:	09 f4       	brne	.+2      	; 0x4a2 <moveToFile+0x64>
     4a0:	6e c0       	rjmp	.+220    	; 0x57e <moveToFile+0x140>
	{
		//Make sure the index is not larger than the file count
		if (_fileIndex >= _fileCount)
     4a2:	20 91 ea 21 	lds	r18, 0x21EA	; 0x8021ea <_fileIndex>
     4a6:	30 91 eb 21 	lds	r19, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     4aa:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     4ae:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     4b2:	28 17       	cp	r18, r24
     4b4:	39 07       	cpc	r19, r25
     4b6:	48 f0       	brcs	.+18     	; 0x4ca <moveToFile+0x8c>
		{
			_fileIndex = _fileCount - 1;
     4b8:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     4bc:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     4c0:	01 97       	sbiw	r24, 0x01	; 1
     4c2:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
     4c6:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
		}	
		
		//We are basically summing up all of the file sizes until we reach our file index
		for(uint16_t i = 0; i < _fileIndex; i++)
     4ca:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     4ce:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     4d2:	89 2b       	or	r24, r25
     4d4:	09 f4       	brne	.+2      	; 0x4d8 <moveToFile+0x9a>
     4d6:	53 c0       	rjmp	.+166    	; 0x57e <moveToFile+0x140>
     4d8:	00 e0       	ldi	r16, 0x00	; 0
     4da:	10 e0       	ldi	r17, 0x00	; 0
     4dc:	0f 2e       	mov	r0, r31
     4de:	f6 e0       	ldi	r31, 0x06	; 6
     4e0:	8f 2e       	mov	r8, r31
     4e2:	f0 e1       	ldi	r31, 0x10	; 16
     4e4:	9f 2e       	mov	r9, r31
     4e6:	a1 2c       	mov	r10, r1
     4e8:	b1 2c       	mov	r11, r1
     4ea:	f0 2d       	mov	r31, r0
			//memReadToBuffer(address, data, 4);
			//printf("Addres of _fileAddressOffset %04x, value %08x\r\n", &_fileAddressOffset, _fileAddressOffset);
			memReadToVariable(address, &newAddressOffset, 4);
			//printf("Index: %u New _fileAddressOffset 0x%08lx\r\n",i, _fileAddressOffset);
			_fileAddressOffset += newAddressOffset;
			printf("Index: %u New _fileAddressOffset 0x%08lx\r\n",i, _fileAddressOffset);
     4ec:	0f 2e       	mov	r0, r31
     4ee:	f1 e4       	ldi	r31, 0x41	; 65
     4f0:	ef 2e       	mov	r14, r31
     4f2:	f0 e2       	ldi	r31, 0x20	; 32
     4f4:	ff 2e       	mov	r15, r31
     4f6:	f0 2d       	mov	r31, r0
		for(uint16_t i = 0; i < _fileIndex; i++)
		{
			//read file sizes and add them too the offsets			
			//memReadToBuffer(address, data, 4);
			//printf("Addres of _fileAddressOffset %04x, value %08x\r\n", &_fileAddressOffset, _fileAddressOffset);
			memReadToVariable(address, &newAddressOffset, 4);
     4f8:	24 e0       	ldi	r18, 0x04	; 4
     4fa:	ae 01       	movw	r20, r28
     4fc:	4f 5f       	subi	r20, 0xFF	; 255
     4fe:	5f 4f       	sbci	r21, 0xFF	; 255
     500:	c5 01       	movw	r24, r10
     502:	b4 01       	movw	r22, r8
     504:	0e 94 cd 01 	call	0x39a	; 0x39a <memReadToVariable>
			//printf("Index: %u New _fileAddressOffset 0x%08lx\r\n",i, _fileAddressOffset);
			_fileAddressOffset += newAddressOffset;
     508:	40 91 e6 21 	lds	r20, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     50c:	50 91 e7 21 	lds	r21, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     510:	60 91 e8 21 	lds	r22, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     514:	70 91 e9 21 	lds	r23, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     518:	89 81       	ldd	r24, Y+1	; 0x01
     51a:	9a 81       	ldd	r25, Y+2	; 0x02
     51c:	ab 81       	ldd	r26, Y+3	; 0x03
     51e:	bc 81       	ldd	r27, Y+4	; 0x04
     520:	84 0f       	add	r24, r20
     522:	95 1f       	adc	r25, r21
     524:	a6 1f       	adc	r26, r22
     526:	b7 1f       	adc	r27, r23
     528:	80 93 e6 21 	sts	0x21E6, r24	; 0x8021e6 <_fileAddressOffset>
     52c:	90 93 e7 21 	sts	0x21E7, r25	; 0x8021e7 <_fileAddressOffset+0x1>
     530:	a0 93 e8 21 	sts	0x21E8, r26	; 0x8021e8 <_fileAddressOffset+0x2>
     534:	b0 93 e9 21 	sts	0x21E9, r27	; 0x8021e9 <_fileAddressOffset+0x3>
			printf("Index: %u New _fileAddressOffset 0x%08lx\r\n",i, _fileAddressOffset);
     538:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     53c:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     540:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     544:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     548:	bf 93       	push	r27
     54a:	af 93       	push	r26
     54c:	9f 93       	push	r25
     54e:	8f 93       	push	r24
     550:	1f 93       	push	r17
     552:	0f 93       	push	r16
     554:	ff 92       	push	r15
     556:	ef 92       	push	r14
     558:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
			address += 4;
     55c:	24 e0       	ldi	r18, 0x04	; 4
     55e:	82 0e       	add	r8, r18
     560:	91 1c       	adc	r9, r1
     562:	a1 1c       	adc	r10, r1
     564:	b1 1c       	adc	r11, r1
		{
			_fileIndex = _fileCount - 1;
		}	
		
		//We are basically summing up all of the file sizes until we reach our file index
		for(uint16_t i = 0; i < _fileIndex; i++)
     566:	0f 5f       	subi	r16, 0xFF	; 255
     568:	1f 4f       	sbci	r17, 0xFF	; 255
     56a:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     56e:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     572:	cd bf       	out	0x3d, r28	; 61
     574:	de bf       	out	0x3e, r29	; 62
     576:	08 17       	cp	r16, r24
     578:	19 07       	cpc	r17, r25
     57a:	08 f4       	brcc	.+2      	; 0x57e <moveToFile+0x140>
     57c:	bd cf       	rjmp	.-134    	; 0x4f8 <moveToFile+0xba>
		}
	}
	
	//As a convenience, here we add file name length to offset.
	//memReadToBuffer(_fileAddressOffset, data, 2);
	memReadToVariable(_fileAddressOffset, &smallAddressOffset, 2);
     57e:	60 91 e6 21 	lds	r22, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     582:	70 91 e7 21 	lds	r23, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     586:	80 91 e8 21 	lds	r24, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     58a:	90 91 e9 21 	lds	r25, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     58e:	22 e0       	ldi	r18, 0x02	; 2
     590:	ae 01       	movw	r20, r28
     592:	4b 5f       	subi	r20, 0xFB	; 251
     594:	5f 4f       	sbci	r21, 0xFF	; 255
     596:	0e 94 cd 01 	call	0x39a	; 0x39a <memReadToVariable>
	printf("Reading file name length from 0x%08lx. Len: %04x\r\n", _fileAddressOffset, smallAddressOffset);
     59a:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     59e:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     5a2:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     5a6:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     5aa:	2e 81       	ldd	r18, Y+6	; 0x06
     5ac:	2f 93       	push	r18
     5ae:	2d 81       	ldd	r18, Y+5	; 0x05
     5b0:	2f 93       	push	r18
     5b2:	bf 93       	push	r27
     5b4:	af 93       	push	r26
     5b6:	9f 93       	push	r25
     5b8:	8f 93       	push	r24
     5ba:	8c e6       	ldi	r24, 0x6C	; 108
     5bc:	90 e2       	ldi	r25, 0x20	; 32
     5be:	9f 93       	push	r25
     5c0:	8f 93       	push	r24
     5c2:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
	_fileAddressOffset +=  smallAddressOffset + 2; //+ 2 for the name length bytes
     5c6:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     5ca:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     5ce:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     5d2:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     5d6:	2d 81       	ldd	r18, Y+5	; 0x05
     5d8:	3e 81       	ldd	r19, Y+6	; 0x06
     5da:	2e 5f       	subi	r18, 0xFE	; 254
     5dc:	3f 4f       	sbci	r19, 0xFF	; 255
     5de:	82 0f       	add	r24, r18
     5e0:	93 1f       	adc	r25, r19
     5e2:	a1 1d       	adc	r26, r1
     5e4:	b1 1d       	adc	r27, r1
     5e6:	80 93 e6 21 	sts	0x21E6, r24	; 0x8021e6 <_fileAddressOffset>
     5ea:	90 93 e7 21 	sts	0x21E7, r25	; 0x8021e7 <_fileAddressOffset+0x1>
     5ee:	a0 93 e8 21 	sts	0x21E8, r26	; 0x8021e8 <_fileAddressOffset+0x2>
     5f2:	b0 93 e9 21 	sts	0x21E9, r27	; 0x8021e9 <_fileAddressOffset+0x3>
     5f6:	cd bf       	out	0x3d, r28	; 61
     5f8:	de bf       	out	0x3e, r29	; 62
	//memReadToVariable(_fileAddressOffset, &smallAddressOffset, 2);
	//_fileAddressOffset += smallAddressOffset;
	//printf("New _fileAddressOffset: 0x%08lx	\r\n", _fileAddressOffset);
}
     5fa:	26 96       	adiw	r28, 0x06	; 6
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	de bf       	out	0x3e, r29	; 62
     600:	df 91       	pop	r29
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	0f 91       	pop	r16
     608:	ff 90       	pop	r15
     60a:	ef 90       	pop	r14
     60c:	bf 90       	pop	r11
     60e:	af 90       	pop	r10
     610:	9f 90       	pop	r9
     612:	8f 90       	pop	r8
     614:	08 95       	ret

00000616 <getTrackCount>:

	//memReadToBuffer(_fileAddressOffset + MIDI_HEADER_TRACk_COUNT_OFFSET, data, 2);
	//printf("Track Count From 0x%08lx, 0x%02x, 0x%02x\r\n", _fileAddressOffset + MIDI_HEADER_TRACk_COUNT_OFFSET, data[0], data[1]);
	//_tractCount = ((uint16_t)data[0] << 8) + (uint16_t)data[1];	
	
	memReadToVariable(_fileAddressOffset + MIDI_HEADER_TRACk_COUNT_OFFSET, &_tractCount, 2);
     616:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     61a:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     61e:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     622:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     626:	bc 01       	movw	r22, r24
     628:	cd 01       	movw	r24, r26
     62a:	66 5f       	subi	r22, 0xF6	; 246
     62c:	7f 4f       	sbci	r23, 0xFF	; 255
     62e:	8f 4f       	sbci	r24, 0xFF	; 255
     630:	9f 4f       	sbci	r25, 0xFF	; 255
     632:	22 e0       	ldi	r18, 0x02	; 2
     634:	44 ee       	ldi	r20, 0xE4	; 228
     636:	51 e2       	ldi	r21, 0x21	; 33
     638:	0e 94 cd 01 	call	0x39a	; 0x39a <memReadToVariable>
	printf("Track Count From 0x%08lx, 0x%04x\r\n", _fileAddressOffset + MIDI_HEADER_TRACk_COUNT_OFFSET, _tractCount);
     63c:	20 91 e4 21 	lds	r18, 0x21E4	; 0x8021e4 <_tractCount>
     640:	30 91 e5 21 	lds	r19, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     644:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     648:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     64c:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     650:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     654:	3f 93       	push	r19
     656:	2f 93       	push	r18
     658:	0a 96       	adiw	r24, 0x0a	; 10
     65a:	a1 1d       	adc	r26, r1
     65c:	b1 1d       	adc	r27, r1
     65e:	bf 93       	push	r27
     660:	af 93       	push	r26
     662:	9f 93       	push	r25
     664:	8f 93       	push	r24
     666:	8f e9       	ldi	r24, 0x9F	; 159
     668:	90 e2       	ldi	r25, 0x20	; 32
     66a:	9f 93       	push	r25
     66c:	8f 93       	push	r24
     66e:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
     672:	8d b7       	in	r24, 0x3d	; 61
     674:	9e b7       	in	r25, 0x3e	; 62
     676:	08 96       	adiw	r24, 0x08	; 8
     678:	8d bf       	out	0x3d, r24	; 61
     67a:	9e bf       	out	0x3e, r25	; 62
     67c:	08 95       	ret

0000067e <getTimeDivision>:
	//For the SMPTE, the _division is calculated by multiplying the first byte by the second byte and then by -1. This means a value of 0xE7 0x28 would be the same as 0x03 0xE8 (or 1000uS, 1mS)	
	uint8_t data[2];

	//memReadToBuffer(_fileAddressOffset + MIDI_HEADER_TIME_DIV_OFFSET, data, 2);
	//_division = ((uint16_t)data[0] << 8) + (uint16_t)data[1];
	memReadToVariable(_fileAddressOffset + MIDI_HEADER_TIME_DIV_OFFSET, &_division, 2);
     67e:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     682:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     686:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     68a:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     68e:	bc 01       	movw	r22, r24
     690:	cd 01       	movw	r24, r26
     692:	64 5f       	subi	r22, 0xF4	; 244
     694:	7f 4f       	sbci	r23, 0xFF	; 255
     696:	8f 4f       	sbci	r24, 0xFF	; 255
     698:	9f 4f       	sbci	r25, 0xFF	; 255
     69a:	22 e0       	ldi	r18, 0x02	; 2
     69c:	4e ee       	ldi	r20, 0xEE	; 238
     69e:	51 e2       	ldi	r21, 0x21	; 33
     6a0:	0e 94 cd 01 	call	0x39a	; 0x39a <memReadToVariable>
	
	
	if (_division < 0) //_division is negative so is in SMPTE format
     6a4:	80 91 ee 21 	lds	r24, 0x21EE	; 0x8021ee <_division>
     6a8:	90 91 ef 21 	lds	r25, 0x21EF	; 0x8021ef <_division+0x1>
     6ac:	99 23       	and	r25, r25
     6ae:	24 f4       	brge	.+8      	; 0x6b8 <getTimeDivision+0x3a>
	{
		_division = -1 * (int8_t)data[0] * data[1];
     6b0:	10 92 ee 21 	sts	0x21EE, r1	; 0x8021ee <_division>
     6b4:	10 92 ef 21 	sts	0x21EF, r1	; 0x8021ef <_division+0x1>
	}	
	
	printf("Division From 0x%08lx, 0x%02x, 0x%02x (%d)\r\n", _fileAddressOffset + MIDI_HEADER_TIME_DIV_OFFSET, data[0], data[1], _division);
     6b8:	20 91 ee 21 	lds	r18, 0x21EE	; 0x8021ee <_division>
     6bc:	30 91 ef 21 	lds	r19, 0x21EF	; 0x8021ef <_division+0x1>
     6c0:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     6c4:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     6c8:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     6cc:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     6d0:	3f 93       	push	r19
     6d2:	2f 93       	push	r18
     6d4:	1f 92       	push	r1
     6d6:	1f 92       	push	r1
     6d8:	1f 92       	push	r1
     6da:	1f 92       	push	r1
     6dc:	0c 96       	adiw	r24, 0x0c	; 12
     6de:	a1 1d       	adc	r26, r1
     6e0:	b1 1d       	adc	r27, r1
     6e2:	bf 93       	push	r27
     6e4:	af 93       	push	r26
     6e6:	9f 93       	push	r25
     6e8:	8f 93       	push	r24
     6ea:	82 ec       	ldi	r24, 0xC2	; 194
     6ec:	90 e2       	ldi	r25, 0x20	; 32
     6ee:	9f 93       	push	r25
     6f0:	8f 93       	push	r24
     6f2:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
     6f6:	8d b7       	in	r24, 0x3d	; 61
     6f8:	9e b7       	in	r25, 0x3e	; 62
     6fa:	0c 96       	adiw	r24, 0x0c	; 12
     6fc:	8d bf       	out	0x3d, r24	; 61
     6fe:	9e bf       	out	0x3e, r25	; 62
     700:	08 95       	ret

00000702 <getNextEvent>:
}



uint8_t getNextEvent(uint8_t trackIndex)
{
     702:	2f 92       	push	r2
     704:	3f 92       	push	r3
     706:	4f 92       	push	r4
     708:	5f 92       	push	r5
     70a:	6f 92       	push	r6
     70c:	7f 92       	push	r7
     70e:	8f 92       	push	r8
     710:	9f 92       	push	r9
     712:	af 92       	push	r10
     714:	bf 92       	push	r11
     716:	cf 92       	push	r12
     718:	df 92       	push	r13
     71a:	ef 92       	push	r14
     71c:	ff 92       	push	r15
     71e:	1f 93       	push	r17
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
	uint8_t done = 0;
	uint32_t value = 0;
    uint8_t data[4];
	uint8_t i;
    uint8_t eventByte;
	uint32_t addressOffset = _tracks[trackIndex].addressOffset;	
     724:	9f e0       	ldi	r25, 0x0F	; 15
     726:	89 9f       	mul	r24, r25
     728:	f0 01       	movw	r30, r0
     72a:	11 24       	eor	r1, r1
     72c:	e0 51       	subi	r30, 0x10	; 16
     72e:	fe 4d       	sbci	r31, 0xDE	; 222
     730:	80 80       	ld	r8, Z
     732:	91 80       	ldd	r9, Z+1	; 0x01
     734:	a2 80       	ldd	r10, Z+2	; 0x02
     736:	b3 80       	ldd	r11, Z+3	; 0x03
	uint8_t temp = 0;
	uint8_t *tempoPtr = &_tempo;
	
	_tracks[trackIndex].deltaTime = 0;
     738:	10 86       	std	Z+8, r1	; 0x08
     73a:	11 86       	std	Z+9, r1	; 0x09
     73c:	12 86       	std	Z+10, r1	; 0x0a
     73e:	13 86       	std	Z+11, r1	; 0x0b
				}
				else
				{
					
					value += temp;
					_tracks[trackIndex].deltaTime += value;
     740:	48 2e       	mov	r4, r24
     742:	51 2c       	mov	r5, r1
     744:	af e0       	ldi	r26, 0x0F	; 15
     746:	8a 9f       	mul	r24, r26
     748:	e0 01       	movw	r28, r0
     74a:	11 24       	eor	r1, r1
     74c:	c8 50       	subi	r28, 0x08	; 8
     74e:	de 4d       	sbci	r29, 0xDE	; 222
					
				
					
					
					_tempo = 0;
					*(tempoPtr + 2) = sendDummy();
     750:	0f 2e       	mov	r0, r31
     752:	f8 e6       	ldi	r31, 0x68	; 104
     754:	6f 2e       	mov	r6, r31
     756:	f2 e2       	ldi	r31, 0x22	; 34
     758:	7f 2e       	mov	r7, r31
     75a:	f0 2d       	mov	r31, r0
					*(tempoPtr + 1) = sendDummy();
					*tempoPtr = sendDummy();		
					printf("Tempo: %lu\r\n", _tempo);
					_tempo *= F_CPU_MHZ;
					TCC0.PER = (_tempo/_division) / 4; //Divided by 4 so we can fit larger values. Timer clock also div4
     75c:	21 2c       	mov	r2, r1
     75e:	68 94       	set
     760:	33 24       	eor	r3, r3
     762:	33 f8       	bld	r3, 3
	uint8_t *tempoPtr = &_tempo;
	
	_tracks[trackIndex].deltaTime = 0;
	
	//printf("Getting next event\r\n");
	while(!done) //(_tracks[usedTracks].addressOffset < _tracks[usedTracks].trackLength)
     764:	5d c1       	rjmp	.+698    	; 0xa20 <getNextEvent+0x31e>
			i = 0;
			value = 0;
			while(i < 4)
			{
		
				value <<= 7;
     766:	cc 0c       	add	r12, r12
     768:	dd 1c       	adc	r13, r13
     76a:	ee 1c       	adc	r14, r14
     76c:	ff 1c       	adc	r15, r15
     76e:	cc 0c       	add	r12, r12
     770:	dd 1c       	adc	r13, r13
     772:	ee 1c       	adc	r14, r14
     774:	ff 1c       	adc	r15, r15
     776:	cc 0c       	add	r12, r12
     778:	dd 1c       	adc	r13, r13
     77a:	ee 1c       	adc	r14, r14
     77c:	ff 1c       	adc	r15, r15
     77e:	cc 0c       	add	r12, r12
     780:	dd 1c       	adc	r13, r13
     782:	ee 1c       	adc	r14, r14
     784:	ff 1c       	adc	r15, r15
     786:	cc 0c       	add	r12, r12
     788:	dd 1c       	adc	r13, r13
     78a:	ee 1c       	adc	r14, r14
     78c:	ff 1c       	adc	r15, r15
     78e:	cc 0c       	add	r12, r12
     790:	dd 1c       	adc	r13, r13
     792:	ee 1c       	adc	r14, r14
     794:	ff 1c       	adc	r15, r15
     796:	cc 0c       	add	r12, r12
     798:	dd 1c       	adc	r13, r13
     79a:	ee 1c       	adc	r14, r14
     79c:	ff 1c       	adc	r15, r15
				//printf("byte %u = %u\r\n", *out_numBytesUsed, *(first4bytes + *out_numBytesUsed));
				temp = sendDummy();
     79e:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
				i++;
     7a2:	1f 5f       	subi	r17, 0xFF	; 255
				if ((temp & 0x80))
     7a4:	88 23       	and	r24, r24
     7a6:	44 f4       	brge	.+16     	; 0x7b8 <getNextEvent+0xb6>
				{
					value += (temp & 0x7F);
     7a8:	8f 77       	andi	r24, 0x7F	; 127
     7aa:	c8 0e       	add	r12, r24
     7ac:	d1 1c       	adc	r13, r1
     7ae:	e1 1c       	adc	r14, r1
     7b0:	f1 1c       	adc	r15, r1
	{


			i = 0;
			value = 0;
			while(i < 4)
     7b2:	14 30       	cpi	r17, 0x04	; 4
     7b4:	c1 f6       	brne	.-80     	; 0x766 <getNextEvent+0x64>
     7b6:	10 c0       	rjmp	.+32     	; 0x7d8 <getNextEvent+0xd6>
				}
				else
				{
					
					value += temp;
					_tracks[trackIndex].deltaTime += value;
     7b8:	48 81       	ld	r20, Y
     7ba:	59 81       	ldd	r21, Y+1	; 0x01
     7bc:	6a 81       	ldd	r22, Y+2	; 0x02
     7be:	7b 81       	ldd	r23, Y+3	; 0x03
     7c0:	c4 0e       	add	r12, r20
     7c2:	d5 1e       	adc	r13, r21
     7c4:	e6 1e       	adc	r14, r22
     7c6:	f7 1e       	adc	r15, r23
     7c8:	c8 0e       	add	r12, r24
     7ca:	d1 1c       	adc	r13, r1
     7cc:	e1 1c       	adc	r14, r1
     7ce:	f1 1c       	adc	r15, r1
     7d0:	c8 82       	st	Y, r12
     7d2:	d9 82       	std	Y+1, r13	; 0x01
     7d4:	ea 82       	std	Y+2, r14	; 0x02
     7d6:	fb 82       	std	Y+3, r15	; 0x03
					break;
				}
				
			}
		addressOffset+=i;
     7d8:	75 01       	movw	r14, r10
     7da:	64 01       	movw	r12, r8
     7dc:	c1 0e       	add	r12, r17
     7de:	d1 1c       	adc	r13, r1
     7e0:	e1 1c       	adc	r14, r1
     7e2:	f1 1c       	adc	r15, r1
		i = 0;
			
		eventByte = sendDummy(); // this should be the event byte
     7e4:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     7e8:	18 2f       	mov	r17, r24
		
		//printf("Evaluating tract %u event 0x%02x: dt: %lu (%02x %02x %02x %02x) \r\n", trackIndex, _tracks[trackIndex].eventByte, _tracks[trackIndex].deltaTime, data[0], data[1], data[2], data[3]);
		
		addressOffset++;
     7ea:	46 01       	movw	r8, r12
     7ec:	57 01       	movw	r10, r14
     7ee:	bf ef       	ldi	r27, 0xFF	; 255
     7f0:	8b 1a       	sub	r8, r27
     7f2:	9b 0a       	sbc	r9, r27
     7f4:	ab 0a       	sbc	r10, r27
     7f6:	bb 0a       	sbc	r11, r27
			
		//printf("dt: %lu, event: 0x%02x, offset: %lu\r\n", _tracks[trackIndex].deltaTime, _tracks[trackIndex].eventByte, _tracks[trackIndex].addressOffset);

		if ((eventByte & 0xF0) == MIDI_NOTE_ON_MASK || (eventByte & 0xF0) == MIDI_NOTE_OFF_MASK || (eventByte & 0xF0) == MIDI_PITCH_BEND_MASK)
     7f8:	98 2f       	mov	r25, r24
     7fa:	90 7f       	andi	r25, 0xF0	; 240
     7fc:	80 7e       	andi	r24, 0xE0	; 224
     7fe:	80 38       	cpi	r24, 0x80	; 128
     800:	11 f0       	breq	.+4      	; 0x806 <getNextEvent+0x104>
     802:	90 3e       	cpi	r25, 0xE0	; 224
     804:	d1 f4       	brne	.+52     	; 0x83a <getNextEvent+0x138>
		{
			//These are valid events that we want to handle, so capture the next two bytes and move to the next track
			_tracks[trackIndex].eventByte = eventByte;
     806:	8f e0       	ldi	r24, 0x0F	; 15
     808:	84 9d       	mul	r24, r4
     80a:	e0 01       	movw	r28, r0
     80c:	85 9d       	mul	r24, r5
     80e:	d0 0d       	add	r29, r0
     810:	11 24       	eor	r1, r1
     812:	c0 51       	subi	r28, 0x10	; 16
     814:	de 4d       	sbci	r29, 0xDE	; 222
     816:	1c 87       	std	Y+12, r17	; 0x0c
			_tracks[trackIndex].eventData1 = sendDummy();
     818:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     81c:	8d 87       	std	Y+13, r24	; 0x0d
			_tracks[trackIndex].eventData2 = sendDummy();
     81e:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     822:	8e 87       	std	Y+14, r24	; 0x0e
			_tracks[trackIndex].addressOffset = addressOffset + 2;
     824:	e3 e0       	ldi	r30, 0x03	; 3
     826:	ce 0e       	add	r12, r30
     828:	d1 1c       	adc	r13, r1
     82a:	e1 1c       	adc	r14, r1
     82c:	f1 1c       	adc	r15, r1
     82e:	c8 82       	st	Y, r12
     830:	d9 82       	std	Y+1, r13	; 0x01
     832:	ea 82       	std	Y+2, r14	; 0x02
     834:	fb 82       	std	Y+3, r15	; 0x03


			//printf("Event 0x%02x found for track %u\r\n", _tracks[trackIndex].eventByte, trackIndex);
			return 0xFF; 			
     836:	8f ef       	ldi	r24, 0xFF	; 255
     838:	05 c1       	rjmp	.+522    	; 0xa44 <getNextEvent+0x342>
		}
		if ((eventByte & 0xF0) == MIDI_POLY_KEY_MASK || (eventByte & 0xF0) == MIDI_CTRL_CHANGE_MASK)//if the event is one of these, skip the next two bytes and continue.
     83a:	80 3a       	cpi	r24, 0xA0	; 160
     83c:	61 f4       	brne	.+24     	; 0x856 <getNextEvent+0x154>
		{
			sendDummy();
     83e:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
			sendDummy();
     842:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
			addressOffset += 2;
     846:	46 01       	movw	r8, r12
     848:	57 01       	movw	r10, r14
     84a:	f3 e0       	ldi	r31, 0x03	; 3
     84c:	8f 0e       	add	r8, r31
     84e:	91 1c       	adc	r9, r1
     850:	a1 1c       	adc	r10, r1
     852:	b1 1c       	adc	r11, r1
     854:	0c c0       	rjmp	.+24     	; 0x86e <getNextEvent+0x16c>
		}
		if ( (eventByte & 0xF0) == MIDI_PROG_CHANGE_MASK || (eventByte & 0xF0) == MIDI_CH_PRESSURE_MASK) //if the event is one of these, skip the next byte and continue.
     856:	80 3c       	cpi	r24, 0xC0	; 192
     858:	51 f4       	brne	.+20     	; 0x86e <getNextEvent+0x16c>
		{
			sendDummy();
     85a:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
			addressOffset++;
     85e:	46 01       	movw	r8, r12
     860:	57 01       	movw	r10, r14
     862:	82 e0       	ldi	r24, 0x02	; 2
     864:	88 0e       	add	r8, r24
     866:	91 1c       	adc	r9, r1
     868:	a1 1c       	adc	r10, r1
     86a:	b1 1c       	adc	r11, r1
     86c:	d9 c0       	rjmp	.+434    	; 0xa20 <getNextEvent+0x31e>
		}
		//Now we have to check other event types to know how far to skip ahead
		else if(eventByte == 0xFF) //Meta-Events
     86e:	1f 3f       	cpi	r17, 0xFF	; 255
     870:	09 f0       	breq	.+2      	; 0x874 <getNextEvent+0x172>
     872:	d6 c0       	rjmp	.+428    	; 0xa20 <getNextEvent+0x31e>
		{
			
			addressOffset++;
     874:	75 01       	movw	r14, r10
     876:	64 01       	movw	r12, r8
     878:	9f ef       	ldi	r25, 0xFF	; 255
     87a:	c9 1a       	sub	r12, r25
     87c:	d9 0a       	sbc	r13, r25
     87e:	e9 0a       	sbc	r14, r25
     880:	f9 0a       	sbc	r15, r25
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(sendDummy())
     882:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     886:	8f 32       	cpi	r24, 0x2F	; 47
     888:	09 f4       	brne	.+2      	; 0x88c <getNextEvent+0x18a>
     88a:	dc c0       	rjmp	.+440    	; 0xa44 <getNextEvent+0x342>
     88c:	48 f4       	brcc	.+18     	; 0x8a0 <getNextEvent+0x19e>
     88e:	8a 30       	cpi	r24, 0x0A	; 10
     890:	20 f4       	brcc	.+8      	; 0x89a <getNextEvent+0x198>
     892:	81 30       	cpi	r24, 0x01	; 1
     894:	08 f4       	brcc	.+2      	; 0x898 <getNextEvent+0x196>
     896:	c9 c0       	rjmp	.+402    	; 0xa2a <getNextEvent+0x328>
     898:	16 c0       	rjmp	.+44     	; 0x8c6 <getNextEvent+0x1c4>
     89a:	80 32       	cpi	r24, 0x20	; 32
     89c:	91 f0       	breq	.+36     	; 0x8c2 <getNextEvent+0x1c0>
     89e:	ae c0       	rjmp	.+348    	; 0x9fc <getNextEvent+0x2fa>
     8a0:	88 35       	cpi	r24, 0x58	; 88
     8a2:	09 f4       	brne	.+2      	; 0x8a6 <getNextEvent+0x1a4>
     8a4:	9b c0       	rjmp	.+310    	; 0x9dc <getNextEvent+0x2da>
     8a6:	30 f4       	brcc	.+12     	; 0x8b4 <getNextEvent+0x1b2>
     8a8:	81 35       	cpi	r24, 0x51	; 81
     8aa:	b9 f0       	breq	.+46     	; 0x8da <getNextEvent+0x1d8>
     8ac:	84 35       	cpi	r24, 0x54	; 84
     8ae:	09 f4       	brne	.+2      	; 0x8b2 <getNextEvent+0x1b0>
     8b0:	be c0       	rjmp	.+380    	; 0xa2e <getNextEvent+0x32c>
     8b2:	a4 c0       	rjmp	.+328    	; 0x9fc <getNextEvent+0x2fa>
     8b4:	89 35       	cpi	r24, 0x59	; 89
     8b6:	09 f4       	brne	.+2      	; 0x8ba <getNextEvent+0x1b8>
     8b8:	93 c0       	rjmp	.+294    	; 0x9e0 <getNextEvent+0x2de>
     8ba:	87 3f       	cpi	r24, 0xF7	; 247
     8bc:	09 f4       	brne	.+2      	; 0x8c0 <getNextEvent+0x1be>
     8be:	92 c0       	rjmp	.+292    	; 0x9e4 <getNextEvent+0x2e2>
     8c0:	9d c0       	rjmp	.+314    	; 0x9fc <getNextEvent+0x2fa>
				case 0x09:
					i = sendDummy(); //next byte is len of text
					addressOffset++;
					break;
				case 0x20:
					i = 2;
     8c2:	82 e0       	ldi	r24, 0x02	; 2
     8c4:	b5 c0       	rjmp	.+362    	; 0xa30 <getNextEvent+0x32e>
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
					i = sendDummy(); //next byte is len of text
     8c6:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
					addressOffset++;
     8ca:	75 01       	movw	r14, r10
     8cc:	64 01       	movw	r12, r8
     8ce:	a2 e0       	ldi	r26, 0x02	; 2
     8d0:	ca 0e       	add	r12, r26
     8d2:	d1 1c       	adc	r13, r1
     8d4:	e1 1c       	adc	r14, r1
     8d6:	f1 1c       	adc	r15, r1
					break;
     8d8:	92 c0       	rjmp	.+292    	; 0x9fe <getNextEvent+0x2fc>
					//_tracks[trackIndex].eventByte = 0x2F;
					//i = 1;
					//break;
				case 0x51:
					// skip the 0x03 control byte
					sendDummy();
     8da:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
										//printf("Tempo using array %lu, data: %02x %02x %02x\r\n", _tempo, data[0], data[1], data[2]);
					
				
					
					
					_tempo = 0;
     8de:	10 92 68 22 	sts	0x2268, r1	; 0x802268 <_tempo>
     8e2:	10 92 69 22 	sts	0x2269, r1	; 0x802269 <_tempo+0x1>
     8e6:	10 92 6a 22 	sts	0x226A, r1	; 0x80226a <_tempo+0x2>
     8ea:	10 92 6b 22 	sts	0x226B, r1	; 0x80226b <_tempo+0x3>
					*(tempoPtr + 2) = sendDummy();
     8ee:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     8f2:	f3 01       	movw	r30, r6
     8f4:	82 83       	std	Z+2, r24	; 0x02
					*(tempoPtr + 1) = sendDummy();
     8f6:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     8fa:	d3 01       	movw	r26, r6
     8fc:	11 96       	adiw	r26, 0x01	; 1
     8fe:	8c 93       	st	X, r24
					*tempoPtr = sendDummy();		
     900:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     904:	f3 01       	movw	r30, r6
     906:	80 83       	st	Z, r24
					printf("Tempo: %lu\r\n", _tempo);
     908:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <_tempo>
     90c:	90 91 69 22 	lds	r25, 0x2269	; 0x802269 <_tempo+0x1>
     910:	a0 91 6a 22 	lds	r26, 0x226A	; 0x80226a <_tempo+0x2>
     914:	b0 91 6b 22 	lds	r27, 0x226B	; 0x80226b <_tempo+0x3>
     918:	bf 93       	push	r27
     91a:	af 93       	push	r26
     91c:	9f 93       	push	r25
     91e:	8f 93       	push	r24
     920:	af ee       	ldi	r26, 0xEF	; 239
     922:	b0 e2       	ldi	r27, 0x20	; 32
     924:	bf 93       	push	r27
     926:	af 93       	push	r26
     928:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
					_tempo *= F_CPU_MHZ;
     92c:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <_tempo>
     930:	90 91 69 22 	lds	r25, 0x2269	; 0x802269 <_tempo+0x1>
     934:	a0 91 6a 22 	lds	r26, 0x226A	; 0x80226a <_tempo+0x2>
     938:	b0 91 6b 22 	lds	r27, 0x226B	; 0x80226b <_tempo+0x3>
     93c:	88 0f       	add	r24, r24
     93e:	99 1f       	adc	r25, r25
     940:	aa 1f       	adc	r26, r26
     942:	bb 1f       	adc	r27, r27
     944:	88 0f       	add	r24, r24
     946:	99 1f       	adc	r25, r25
     948:	aa 1f       	adc	r26, r26
     94a:	bb 1f       	adc	r27, r27
     94c:	88 0f       	add	r24, r24
     94e:	99 1f       	adc	r25, r25
     950:	aa 1f       	adc	r26, r26
     952:	bb 1f       	adc	r27, r27
     954:	88 0f       	add	r24, r24
     956:	99 1f       	adc	r25, r25
     958:	aa 1f       	adc	r26, r26
     95a:	bb 1f       	adc	r27, r27
     95c:	88 0f       	add	r24, r24
     95e:	99 1f       	adc	r25, r25
     960:	aa 1f       	adc	r26, r26
     962:	bb 1f       	adc	r27, r27
     964:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <_tempo>
     968:	90 93 69 22 	sts	0x2269, r25	; 0x802269 <_tempo+0x1>
     96c:	a0 93 6a 22 	sts	0x226A, r26	; 0x80226a <_tempo+0x2>
     970:	b0 93 6b 22 	sts	0x226B, r27	; 0x80226b <_tempo+0x3>
					TCC0.PER = (_tempo/_division) / 4; //Divided by 4 so we can fit larger values. Timer clock also div4
     974:	60 91 68 22 	lds	r22, 0x2268	; 0x802268 <_tempo>
     978:	70 91 69 22 	lds	r23, 0x2269	; 0x802269 <_tempo+0x1>
     97c:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <_tempo+0x2>
     980:	90 91 6b 22 	lds	r25, 0x226B	; 0x80226b <_tempo+0x3>
     984:	20 91 ee 21 	lds	r18, 0x21EE	; 0x8021ee <_division>
     988:	30 91 ef 21 	lds	r19, 0x21EF	; 0x8021ef <_division+0x1>
     98c:	03 2e       	mov	r0, r19
     98e:	00 0c       	add	r0, r0
     990:	44 0b       	sbc	r20, r20
     992:	55 0b       	sbc	r21, r21
     994:	0e 94 96 09 	call	0x132c	; 0x132c <__udivmodsi4>
     998:	da 01       	movw	r26, r20
     99a:	c9 01       	movw	r24, r18
     99c:	b6 95       	lsr	r27
     99e:	a7 95       	ror	r26
     9a0:	97 95       	ror	r25
     9a2:	87 95       	ror	r24
     9a4:	b6 95       	lsr	r27
     9a6:	a7 95       	ror	r26
     9a8:	97 95       	ror	r25
     9aa:	87 95       	ror	r24
     9ac:	f1 01       	movw	r30, r2
     9ae:	86 a3       	std	Z+38, r24	; 0x26
     9b0:	97 a3       	std	Z+39, r25	; 0x27
					printf("PER: %u\r\n", TCC0.PER);
     9b2:	86 a1       	ldd	r24, Z+38	; 0x26
     9b4:	97 a1       	ldd	r25, Z+39	; 0x27
     9b6:	9f 93       	push	r25
     9b8:	8f 93       	push	r24
     9ba:	ac ef       	ldi	r26, 0xFC	; 252
     9bc:	b0 e2       	ldi	r27, 0x20	; 32
     9be:	bf 93       	push	r27
     9c0:	af 93       	push	r26
     9c2:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
					addressOffset += 4;
     9c6:	f5 e0       	ldi	r31, 0x05	; 5
     9c8:	8f 0e       	add	r8, r31
     9ca:	91 1c       	adc	r9, r1
     9cc:	a1 1c       	adc	r10, r1
     9ce:	b1 1c       	adc	r11, r1
					i = 0;
					break;
     9d0:	8d b7       	in	r24, 0x3d	; 61
     9d2:	9e b7       	in	r25, 0x3e	; 62
     9d4:	0a 96       	adiw	r24, 0x0a	; 10
     9d6:	8d bf       	out	0x3d, r24	; 61
     9d8:	9e bf       	out	0x3e, r25	; 62
     9da:	22 c0       	rjmp	.+68     	; 0xa20 <getNextEvent+0x31e>
				case 0x54:
					i = 6;
					break;
				case 0x58:
				i = 5;
     9dc:	85 e0       	ldi	r24, 0x05	; 5
				break;
     9de:	28 c0       	rjmp	.+80     	; 0xa30 <getNextEvent+0x32e>
				case 0x59:
				i = 3;
     9e0:	83 e0       	ldi	r24, 0x03	; 3
				break;
     9e2:	26 c0       	rjmp	.+76     	; 0xa30 <getNextEvent+0x32e>
		else if(eventByte == 0xFF) //Meta-Events
		{
			
			addressOffset++;
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(sendDummy())
     9e4:	46 01       	movw	r8, r12
     9e6:	57 01       	movw	r10, r14
				break;
				case 0xF7:
				//TODO: Finish looking at this length
				while(1)
				{
					addressOffset++;
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	89 1a       	sub	r8, r25
     9ec:	99 0a       	sbc	r9, r25
     9ee:	a9 0a       	sbc	r10, r25
     9f0:	b9 0a       	sbc	r11, r25
					if (sendDummy() == 0xF7)
     9f2:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     9f6:	87 3f       	cpi	r24, 0xF7	; 247
     9f8:	b9 f7       	brne	.-18     	; 0x9e8 <getNextEvent+0x2e6>
     9fa:	12 c0       	rjmp	.+36     	; 0xa20 <getNextEvent+0x31e>
					break;
				}
				
			}
		addressOffset+=i;
		i = 0;
     9fc:	80 e0       	ldi	r24, 0x00	; 0
				}
				i = 0;
				break;
			}
				
			addressOffset += i;
     9fe:	46 01       	movw	r8, r12
     a00:	57 01       	movw	r10, r14
     a02:	88 0e       	add	r8, r24
     a04:	91 1c       	adc	r9, r1
     a06:	a1 1c       	adc	r10, r1
     a08:	b1 1c       	adc	r11, r1
			//skip some bytes
			while(i--)
     a0a:	ff 24       	eor	r15, r15
     a0c:	fa 94       	dec	r15
     a0e:	f8 0e       	add	r15, r24
     a10:	88 23       	and	r24, r24
     a12:	31 f0       	breq	.+12     	; 0xa20 <getNextEvent+0x31e>
			{
				sendDummy();
     a14:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     a18:	8f 2d       	mov	r24, r15
				break;
			}
				
			addressOffset += i;
			//skip some bytes
			while(i--)
     a1a:	fa 94       	dec	r15
     a1c:	81 11       	cpse	r24, r1
     a1e:	fa cf       	rjmp	.-12     	; 0xa14 <getNextEvent+0x312>
	//printf("Getting next event\r\n");
	while(!done) //(_tracks[usedTracks].addressOffset < _tracks[usedTracks].trackLength)
	{


			i = 0;
     a20:	10 e0       	ldi	r17, 0x00	; 0
			value = 0;
     a22:	c1 2c       	mov	r12, r1
     a24:	d1 2c       	mov	r13, r1
     a26:	76 01       	movw	r14, r12
     a28:	9e ce       	rjmp	.-708    	; 0x766 <getNextEvent+0x64>
			addressOffset++;
			//Here we are just looking for the number of bytes to jump, except for in the case of FF 51 03 (Tempo)
			switch(sendDummy())
			{
				case 0x00:
					i = 1;
     a2a:	81 e0       	ldi	r24, 0x01	; 1
     a2c:	01 c0       	rjmp	.+2      	; 0xa30 <getNextEvent+0x32e>
					printf("PER: %u\r\n", TCC0.PER);
					addressOffset += 4;
					i = 0;
					break;
				case 0x54:
					i = 6;
     a2e:	86 e0       	ldi	r24, 0x06	; 6
				}
				i = 0;
				break;
			}
				
			addressOffset += i;
     a30:	46 01       	movw	r8, r12
     a32:	57 01       	movw	r10, r14
     a34:	88 0e       	add	r8, r24
     a36:	91 1c       	adc	r9, r1
     a38:	a1 1c       	adc	r10, r1
     a3a:	b1 1c       	adc	r11, r1
			//skip some bytes
			while(i--)
     a3c:	ff 24       	eor	r15, r15
     a3e:	fa 94       	dec	r15
     a40:	f8 0e       	add	r15, r24
     a42:	e8 cf       	rjmp	.-48     	; 0xa14 <getNextEvent+0x312>
		}
			
	}
	
	return 0x00;
}
     a44:	df 91       	pop	r29
     a46:	cf 91       	pop	r28
     a48:	1f 91       	pop	r17
     a4a:	ff 90       	pop	r15
     a4c:	ef 90       	pop	r14
     a4e:	df 90       	pop	r13
     a50:	cf 90       	pop	r12
     a52:	bf 90       	pop	r11
     a54:	af 90       	pop	r10
     a56:	9f 90       	pop	r9
     a58:	8f 90       	pop	r8
     a5a:	7f 90       	pop	r7
     a5c:	6f 90       	pop	r6
     a5e:	5f 90       	pop	r5
     a60:	4f 90       	pop	r4
     a62:	3f 90       	pop	r3
     a64:	2f 90       	pop	r2
     a66:	08 95       	ret

00000a68 <getMidiTracks>:

//Gets up to the max number of MIDI tracks. Scans each track for notes. Ignores if no notes found
//Uses _trackCount 
//Sets _trackCount, _tracks
uint8_t getMidiTracks()
{
     a68:	4f 92       	push	r4
     a6a:	5f 92       	push	r5
     a6c:	6f 92       	push	r6
     a6e:	7f 92       	push	r7
     a70:	8f 92       	push	r8
     a72:	9f 92       	push	r9
     a74:	af 92       	push	r10
     a76:	bf 92       	push	r11
     a78:	cf 92       	push	r12
     a7a:	df 92       	push	r13
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	00 d0       	rcall	.+0      	; 0xa8a <getMidiTracks+0x22>
     a8a:	1f 92       	push	r1
     a8c:	cd b7       	in	r28, 0x3d	; 61
     a8e:	de b7       	in	r29, 0x3e	; 62
	uint8_t i = 0;
	uint8_t cnt = 0;
	uint8_t usedTracks = 0;
	uint32_t trackStart = (uint32_t)MIDI_FIRST_TRACK_OFFSET + _fileAddressOffset + 4;// + 4 to skip the track header	
     a90:	c0 90 e6 21 	lds	r12, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     a94:	d0 90 e7 21 	lds	r13, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     a98:	e0 90 e8 21 	lds	r14, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     a9c:	f0 90 e9 21 	lds	r15, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     aa0:	22 e1       	ldi	r18, 0x12	; 18
     aa2:	c2 0e       	add	r12, r18
     aa4:	d1 1c       	adc	r13, r1
     aa6:	e1 1c       	adc	r14, r1
     aa8:	f1 1c       	adc	r15, r1
	uint8_t data[4];
	uint8_t done = 0;
	uint32_t trackLen = 0;
     aaa:	19 82       	std	Y+1, r1	; 0x01
     aac:	1a 82       	std	Y+2, r1	; 0x02
     aae:	1b 82       	std	Y+3, r1	; 0x03
     ab0:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t *ptr = &trackLen;
	
	 while (cnt < _tractCount && usedTracks < MIDI_MAX_MIDI_TRACKS) 
     ab2:	80 91 e4 21 	lds	r24, 0x21E4	; 0x8021e4 <_tractCount>
     ab6:	90 91 e5 21 	lds	r25, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     aba:	89 2b       	or	r24, r25
     abc:	09 f4       	brne	.+2      	; 0xac0 <getMidiTracks+0x58>
     abe:	75 c0       	rjmp	.+234    	; 0xbaa <getMidiTracks+0x142>
     ac0:	71 2c       	mov	r7, r1
     ac2:	51 2c       	mov	r5, r1
	{

		
		//Clear the track data
		_tracks[usedTracks].eventByte = 0;
     ac4:	0f 2e       	mov	r0, r31
     ac6:	ff e0       	ldi	r31, 0x0F	; 15
     ac8:	4f 2e       	mov	r4, r31
     aca:	f0 2d       	mov	r31, r0
		_tracks[usedTracks].addressOffset = 0;
		_tracks[usedTracks].startAddress = 0;

			waitForNotBusy();
			
			CS_DISABLE();
     acc:	00 e4       	ldi	r16, 0x40	; 64
     ace:	16 e0       	ldi	r17, 0x06	; 6
     ad0:	68 94       	set
     ad2:	66 24       	eor	r6, r6
     ad4:	64 f8       	bld	r6, 4
			CS_ENABLE();
			sendSPI(MEM_READ);
			memSendAddress(trackStart);

		printf("trackStart: 0x%08lx \r\n", trackStart);
     ad6:	0f 2e       	mov	r0, r31
     ad8:	f6 e0       	ldi	r31, 0x06	; 6
     ada:	af 2e       	mov	r10, r31
     adc:	f1 e2       	ldi	r31, 0x21	; 33
     ade:	bf 2e       	mov	r11, r31
     ae0:	f0 2d       	mov	r31, r0
	 while (cnt < _tractCount && usedTracks < MIDI_MAX_MIDI_TRACKS) 
	{

		
		//Clear the track data
		_tracks[usedTracks].eventByte = 0;
     ae2:	47 9c       	mul	r4, r7
     ae4:	c0 01       	movw	r24, r0
     ae6:	11 24       	eor	r1, r1
     ae8:	fc 01       	movw	r30, r24
     aea:	e0 51       	subi	r30, 0x10	; 16
     aec:	fe 4d       	sbci	r31, 0xDE	; 222
     aee:	4f 01       	movw	r8, r30
     af0:	14 86       	std	Z+12, r1	; 0x0c
		_tracks[usedTracks].eventData1 = 0;
     af2:	15 86       	std	Z+13, r1	; 0x0d
		_tracks[usedTracks].eventData2 = 0;
     af4:	16 86       	std	Z+14, r1	; 0x0e
		_tracks[usedTracks].addressOffset = 0;
     af6:	10 82       	st	Z, r1
     af8:	11 82       	std	Z+1, r1	; 0x01
     afa:	12 82       	std	Z+2, r1	; 0x02
     afc:	13 82       	std	Z+3, r1	; 0x03
		_tracks[usedTracks].startAddress = 0;
     afe:	14 82       	std	Z+4, r1	; 0x04
     b00:	15 82       	std	Z+5, r1	; 0x05
     b02:	16 82       	std	Z+6, r1	; 0x06
     b04:	17 82       	std	Z+7, r1	; 0x07

			waitForNotBusy();
     b06:	0e 94 c8 01 	call	0x390	; 0x390 <waitForNotBusy>
			
			CS_DISABLE();
     b0a:	f8 01       	movw	r30, r16
     b0c:	65 82       	std	Z+5, r6	; 0x05
			CS_ENABLE();
     b0e:	66 82       	std	Z+6, r6	; 0x06
			sendSPI(MEM_READ);
     b10:	83 e0       	ldi	r24, 0x03	; 3
     b12:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
			memSendAddress(trackStart);
     b16:	c7 01       	movw	r24, r14
     b18:	b6 01       	movw	r22, r12
     b1a:	0e 94 9d 01 	call	0x33a	; 0x33a <memSendAddress>

		printf("trackStart: 0x%08lx \r\n", trackStart);
     b1e:	ff 92       	push	r15
     b20:	ef 92       	push	r14
     b22:	df 92       	push	r13
     b24:	cf 92       	push	r12
     b26:	bf 92       	push	r11
     b28:	af 92       	push	r10
     b2a:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
//
		////_tracks[usedTracks].trackLength = ((uint32_t)data[0] << 24) + ((uint32_t)data[1] << 16) + ((uint32_t)data[2] << 8) + ((uint32_t)data[3] << 0);
		//trackLen = ((uint32_t)data[0] * 0x01000000) + ((uint32_t)data[1] * 0x010000) + ((uint32_t)data[2] * 0x0100) + ((uint32_t)data[3] << 0);
		////printf("len: %02x %02x %02x %02x (%lu)\r\n", data[0], data[1], data[2], data[3], trackLen);
		
		*(ptr + 3) = sendDummy();
     b2e:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     b32:	8c 83       	std	Y+4, r24	; 0x04
		*(ptr + 2) = sendDummy();
     b34:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     b38:	8b 83       	std	Y+3, r24	; 0x03
		*(ptr + 1) = sendDummy();
     b3a:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     b3e:	8a 83       	std	Y+2, r24	; 0x02
		*ptr = sendDummy();
     b40:	0e 94 99 01 	call	0x332	; 0x332 <sendDummy>
     b44:	89 83       	std	Y+1, r24	; 0x01
		
		trackStart += 4; //move the trackStart to after the length
     b46:	f4 e0       	ldi	r31, 0x04	; 4
     b48:	cf 0e       	add	r12, r31
     b4a:	d1 1c       	adc	r13, r1
     b4c:	e1 1c       	adc	r14, r1
     b4e:	f1 1c       	adc	r15, r1
		//set the start of the track
		_tracks[usedTracks].startAddress = trackStart;
     b50:	f4 01       	movw	r30, r8
     b52:	c4 82       	std	Z+4, r12	; 0x04
     b54:	d5 82       	std	Z+5, r13	; 0x05
     b56:	e6 82       	std	Z+6, r14	; 0x06
     b58:	f7 82       	std	Z+7, r15	; 0x07
	
		//trackLen = _tracks[usedTracks].trackLength + 4;// + 4 to skip the track header
	 
		//getFirstEvent(&usedTracks, trackStart);

			if (getNextEvent(usedTracks) == 0xFF) //Checking 0xFF explicitly because there might be a 0x2F returned.
     b5a:	87 2d       	mov	r24, r7
     b5c:	0e 94 81 03 	call	0x702	; 0x702 <getNextEvent>
     b60:	0f 90       	pop	r0
     b62:	0f 90       	pop	r0
     b64:	0f 90       	pop	r0
     b66:	0f 90       	pop	r0
     b68:	0f 90       	pop	r0
     b6a:	0f 90       	pop	r0
     b6c:	8f 3f       	cpi	r24, 0xFF	; 255
     b6e:	09 f4       	brne	.+2      	; 0xb72 <getMidiTracks+0x10a>
			{
				usedTracks++;
     b70:	73 94       	inc	r7
			}
	
			CS_DISABLE();
     b72:	f8 01       	movw	r30, r16
     b74:	65 82       	std	Z+5, r6	; 0x05
     b76:	89 81       	ldd	r24, Y+1	; 0x01
     b78:	9a 81       	ldd	r25, Y+2	; 0x02
     b7a:	ab 81       	ldd	r26, Y+3	; 0x03
     b7c:	bc 81       	ldd	r27, Y+4	; 0x04
     b7e:	04 96       	adiw	r24, 0x04	; 4
     b80:	a1 1d       	adc	r26, r1
     b82:	b1 1d       	adc	r27, r1
	
		//Update the trackStart here because we will need it later.
		trackStart += trackLen + 4;
     b84:	c8 0e       	add	r12, r24
     b86:	d9 1e       	adc	r13, r25
     b88:	ea 1e       	adc	r14, r26
     b8a:	fb 1e       	adc	r15, r27
				
		cnt++;
     b8c:	53 94       	inc	r5
	uint8_t data[4];
	uint8_t done = 0;
	uint32_t trackLen = 0;
	uint8_t *ptr = &trackLen;
	
	 while (cnt < _tractCount && usedTracks < MIDI_MAX_MIDI_TRACKS) 
     b8e:	80 91 e4 21 	lds	r24, 0x21E4	; 0x8021e4 <_tractCount>
     b92:	90 91 e5 21 	lds	r25, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     b96:	25 2d       	mov	r18, r5
     b98:	30 e0       	ldi	r19, 0x00	; 0
     b9a:	28 17       	cp	r18, r24
     b9c:	39 07       	cpc	r19, r25
     b9e:	30 f4       	brcc	.+12     	; 0xbac <getMidiTracks+0x144>
     ba0:	f7 e0       	ldi	r31, 0x07	; 7
     ba2:	f7 15       	cp	r31, r7
     ba4:	08 f0       	brcs	.+2      	; 0xba8 <getMidiTracks+0x140>
     ba6:	9d cf       	rjmp	.-198    	; 0xae2 <getMidiTracks+0x7a>
     ba8:	01 c0       	rjmp	.+2      	; 0xbac <getMidiTracks+0x144>
//Sets _trackCount, _tracks
uint8_t getMidiTracks()
{
	uint8_t i = 0;
	uint8_t cnt = 0;
	uint8_t usedTracks = 0;
     baa:	71 2c       	mov	r7, r1
		cnt++;
		
	}
	
	return usedTracks;
}
     bac:	87 2d       	mov	r24, r7
     bae:	24 96       	adiw	r28, 0x04	; 4
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	de bf       	out	0x3e, r29	; 62
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	1f 91       	pop	r17
     bba:	0f 91       	pop	r16
     bbc:	ff 90       	pop	r15
     bbe:	ef 90       	pop	r14
     bc0:	df 90       	pop	r13
     bc2:	cf 90       	pop	r12
     bc4:	bf 90       	pop	r11
     bc6:	af 90       	pop	r10
     bc8:	9f 90       	pop	r9
     bca:	8f 90       	pop	r8
     bcc:	7f 90       	pop	r7
     bce:	6f 90       	pop	r6
     bd0:	5f 90       	pop	r5
     bd2:	4f 90       	pop	r4
     bd4:	08 95       	ret

00000bd6 <initMemory>:

void initMemory()
{

	getFileCount();
     bd6:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <getFileCount>
	_fileAddressOffset = FILE_COUNT_ADDR + 2 + (_fileCount * 4);
     bda:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     bde:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     be2:	88 0f       	add	r24, r24
     be4:	99 1f       	adc	r25, r25
     be6:	88 0f       	add	r24, r24
     be8:	99 1f       	adc	r25, r25
     bea:	8a 5f       	subi	r24, 0xFA	; 250
     bec:	9f 4e       	sbci	r25, 0xEF	; 239
     bee:	a0 e0       	ldi	r26, 0x00	; 0
     bf0:	b0 e0       	ldi	r27, 0x00	; 0
     bf2:	80 93 e6 21 	sts	0x21E6, r24	; 0x8021e6 <_fileAddressOffset>
     bf6:	90 93 e7 21 	sts	0x21E7, r25	; 0x8021e7 <_fileAddressOffset+0x1>
     bfa:	a0 93 e8 21 	sts	0x21E8, r26	; 0x8021e8 <_fileAddressOffset+0x2>
     bfe:	b0 93 e9 21 	sts	0x21E9, r27	; 0x8021e9 <_fileAddressOffset+0x3>
	
	printf("File Count: %u, Starting Address 0x%08lx\r\n", _fileCount, _fileAddressOffset);
     c02:	80 91 e6 21 	lds	r24, 0x21E6	; 0x8021e6 <_fileAddressOffset>
     c06:	90 91 e7 21 	lds	r25, 0x21E7	; 0x8021e7 <_fileAddressOffset+0x1>
     c0a:	a0 91 e8 21 	lds	r26, 0x21E8	; 0x8021e8 <_fileAddressOffset+0x2>
     c0e:	b0 91 e9 21 	lds	r27, 0x21E9	; 0x8021e9 <_fileAddressOffset+0x3>
     c12:	20 91 ec 21 	lds	r18, 0x21EC	; 0x8021ec <_fileCount>
     c16:	30 91 ed 21 	lds	r19, 0x21ED	; 0x8021ed <_fileCount+0x1>
     c1a:	bf 93       	push	r27
     c1c:	af 93       	push	r26
     c1e:	9f 93       	push	r25
     c20:	8f 93       	push	r24
     c22:	3f 93       	push	r19
     c24:	2f 93       	push	r18
     c26:	8d e1       	ldi	r24, 0x1D	; 29
     c28:	91 e2       	ldi	r25, 0x21	; 33
     c2a:	9f 93       	push	r25
     c2c:	8f 93       	push	r24
     c2e:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
     c32:	8d b7       	in	r24, 0x3d	; 61
     c34:	9e b7       	in	r25, 0x3e	; 62
     c36:	08 96       	adiw	r24, 0x08	; 8
     c38:	8d bf       	out	0x3d, r24	; 61
     c3a:	9e bf       	out	0x3e, r25	; 62
     c3c:	08 95       	ret

00000c3e <loadFile>:

}

uint8_t loadFile(uint16_t index)
{
	_fileIndex = index;
     c3e:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
     c42:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
	moveToFile();
     c46:	0e 94 1f 02 	call	0x43e	; 0x43e <moveToFile>
	getTrackCount();
     c4a:	0e 94 0b 03 	call	0x616	; 0x616 <getTrackCount>
	getTimeDivision();
     c4e:	0e 94 3f 03 	call	0x67e	; 0x67e <getTimeDivision>
	_tractCount = getMidiTracks();
     c52:	0e 94 34 05 	call	0xa68	; 0xa68 <getMidiTracks>
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	80 93 e4 21 	sts	0x21E4, r24	; 0x8021e4 <_tractCount>
     c5c:	90 93 e5 21 	sts	0x21E5, r25	; 0x8021e5 <_tractCount+0x1>
	_activeTracks = _tractCount;
     c60:	80 91 e4 21 	lds	r24, 0x21E4	; 0x8021e4 <_tractCount>
     c64:	90 91 e5 21 	lds	r25, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     c68:	80 93 e3 21 	sts	0x21E3, r24	; 0x8021e3 <_activeTracks>
	printf("Used tracks %u\r\n", _tractCount);
     c6c:	80 91 e4 21 	lds	r24, 0x21E4	; 0x8021e4 <_tractCount>
     c70:	90 91 e5 21 	lds	r25, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     c74:	9f 93       	push	r25
     c76:	8f 93       	push	r24
     c78:	88 e4       	ldi	r24, 0x48	; 72
     c7a:	91 e2       	ldi	r25, 0x21	; 33
     c7c:	9f 93       	push	r25
     c7e:	8f 93       	push	r24
     c80:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
     c84:	0f 90       	pop	r0
     c86:	0f 90       	pop	r0
     c88:	0f 90       	pop	r0
     c8a:	0f 90       	pop	r0
}
     c8c:	08 95       	ret

00000c8e <main>:
int main(void)
{
	uint8_t data[4];
	uint8_t i;
	
	cli();
     c8e:	f8 94       	cli
	
	initClk();	
     c90:	0e 94 30 01 	call	0x260	; 0x260 <initClk>
	initSPI();
     c94:	0e 94 3e 01 	call	0x27c	; 0x27c <initSPI>
	initDebugUART();
     c98:	0e 94 48 01 	call	0x290	; 0x290 <initDebugUART>
	initMidiUART();
     c9c:	0e 94 51 01 	call	0x2a2	; 0x2a2 <initMidiUART>
	initInterrupts();
     ca0:	0e 94 81 01 	call	0x302	; 0x302 <initInterrupts>
	initMidiTimer();
     ca4:	0e 94 5e 01 	call	0x2bc	; 0x2bc <initMidiTimer>
	initInputTimer();
     ca8:	0e 94 69 01 	call	0x2d2	; 0x2d2 <initInputTimer>
	initInputADC();
     cac:	0e 94 73 01 	call	0x2e6	; 0x2e6 <initInputADC>
	
	sei();
     cb0:	78 94       	sei
	
	stdout = &mystdout;
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	90 e2       	ldi	r25, 0x20	; 32
     cb6:	80 93 71 22 	sts	0x2271, r24	; 0x802271 <__iob+0x2>
     cba:	90 93 72 22 	sts	0x2272, r25	; 0x802272 <__iob+0x3>
	
	printf("started\r\n");
     cbe:	89 e5       	ldi	r24, 0x59	; 89
     cc0:	91 e2       	ldi	r25, 0x21	; 33
     cc2:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
			//i++;
		//}
	//
	
	
	initMemory();
     cc6:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <initMemory>
	
	
	
	
	//TODO: Remove
	PORTA.DIRSET = PIN5_bm;
     cca:	80 e2       	ldi	r24, 0x20	; 32
     ccc:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
		
	_fileIndex = 0xFFFFFF; //so it rolls over to the correct file with the very first button click.
     cd0:	8f ef       	ldi	r24, 0xFF	; 255
     cd2:	9f ef       	ldi	r25, 0xFF	; 255
     cd4:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
     cd8:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
	for(uint16_t i = 0; i < _tractCount; i++)
	{

		//getNextEvent requires the memory to be in continuous read mode. This is an optimization to speed up reading the next event
		waitForNotBusy();	
		CS_DISABLE();
     cdc:	0f 2e       	mov	r0, r31
     cde:	f0 e4       	ldi	r31, 0x40	; 64
     ce0:	6f 2e       	mov	r6, r31
     ce2:	f6 e0       	ldi	r31, 0x06	; 6
     ce4:	7f 2e       	mov	r7, r31
     ce6:	f0 2d       	mov	r31, r0
		CS_ENABLE();
		sendSPI(MEM_READ);
		memSendAddress(_tracks[i].startAddress + _tracks[i].addressOffset);
     ce8:	0f 2e       	mov	r0, r31
     cea:	ff e0       	ldi	r31, 0x0F	; 15
     cec:	2f 2e       	mov	r2, r31
     cee:	f0 2d       	mov	r31, r0
			}
							
			if (!_tracks[i].deltaTime) //A DeltaTime has reached 0;
			{
					
				printf("Track %u send 0x%02x %u %u\r\n", i, _tracks[i].eventByte, _tracks[i].eventData1, _tracks[i].eventData2);
     cf0:	0f 2e       	mov	r0, r31
     cf2:	f2 e6       	ldi	r31, 0x62	; 98
     cf4:	8f 2e       	mov	r8, r31
     cf6:	f1 e2       	ldi	r31, 0x21	; 33
     cf8:	9f 2e       	mov	r9, r31
     cfa:	f0 2d       	mov	r31, r0
		
	_fileIndex = 0xFFFFFF; //so it rolls over to the correct file with the very first button click.
	
    while (1) 
    {
		if (_clockTickFlag)
     cfc:	80 91 e2 21 	lds	r24, 0x21E2	; 0x8021e2 <__data_end>
     d00:	88 23       	and	r24, r24
     d02:	09 f4       	brne	.+2      	; 0xd06 <main+0x78>
     d04:	5b c1       	rjmp	.+694    	; 0xfbc <main+0x32e>
	//3: goto 1.
	uint8_t prevEventByte;
	uint8_t prevNote;
	uint8_t out = 0;

	for(uint16_t i = 0; i < _tractCount; i++)
     d06:	80 91 e4 21 	lds	r24, 0x21E4	; 0x8021e4 <_tractCount>
     d0a:	90 91 e5 21 	lds	r25, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     d0e:	89 2b       	or	r24, r25
     d10:	09 f4       	brne	.+2      	; 0xd14 <main+0x86>
     d12:	52 c1       	rjmp	.+676    	; 0xfb8 <main+0x32a>
     d14:	e1 2c       	mov	r14, r1
     d16:	f1 2c       	mov	r15, r1
	{

		//getNextEvent requires the memory to be in continuous read mode. This is an optimization to speed up reading the next event
		waitForNotBusy();	
     d18:	0e 94 c8 01 	call	0x390	; 0x390 <waitForNotBusy>
		CS_DISABLE();
     d1c:	e0 e1       	ldi	r30, 0x10	; 16
     d1e:	d3 01       	movw	r26, r6
     d20:	15 96       	adiw	r26, 0x05	; 5
     d22:	ec 93       	st	X, r30
     d24:	15 97       	sbiw	r26, 0x05	; 5
		CS_ENABLE();
     d26:	f0 e1       	ldi	r31, 0x10	; 16
     d28:	16 96       	adiw	r26, 0x06	; 6
     d2a:	fc 93       	st	X, r31
		sendSPI(MEM_READ);
     d2c:	83 e0       	ldi	r24, 0x03	; 3
     d2e:	0e 94 8f 01 	call	0x31e	; 0x31e <sendSPI>
		memSendAddress(_tracks[i].startAddress + _tracks[i].addressOffset);
     d32:	2e 9c       	mul	r2, r14
     d34:	f0 01       	movw	r30, r0
     d36:	2f 9c       	mul	r2, r15
     d38:	f0 0d       	add	r31, r0
     d3a:	11 24       	eor	r1, r1
     d3c:	e0 51       	subi	r30, 0x10	; 16
     d3e:	fe 4d       	sbci	r31, 0xDE	; 222
     d40:	84 81       	ldd	r24, Z+4	; 0x04
     d42:	95 81       	ldd	r25, Z+5	; 0x05
     d44:	a6 81       	ldd	r26, Z+6	; 0x06
     d46:	b7 81       	ldd	r27, Z+7	; 0x07
     d48:	40 81       	ld	r20, Z
     d4a:	51 81       	ldd	r21, Z+1	; 0x01
     d4c:	62 81       	ldd	r22, Z+2	; 0x02
     d4e:	73 81       	ldd	r23, Z+3	; 0x03
     d50:	8a 01       	movw	r16, r20
     d52:	9b 01       	movw	r18, r22
     d54:	08 0f       	add	r16, r24
     d56:	19 1f       	adc	r17, r25
     d58:	2a 1f       	adc	r18, r26
     d5a:	3b 1f       	adc	r19, r27
     d5c:	c9 01       	movw	r24, r18
     d5e:	b8 01       	movw	r22, r16
     d60:	0e 94 9d 01 	call	0x33a	; 0x33a <memSendAddress>
												
		//Get the next event and keep sending as long as the deltatime is 0										
		while(1)
		{	
			if (!_tracks[i].eventByte) //if there is no event, skip ahead
     d64:	2e 9c       	mul	r2, r14
     d66:	80 01       	movw	r16, r0
     d68:	2f 9c       	mul	r2, r15
     d6a:	10 0d       	add	r17, r0
     d6c:	11 24       	eor	r1, r1
     d6e:	00 51       	subi	r16, 0x10	; 16
     d70:	1e 4d       	sbci	r17, 0xDE	; 222
     d72:	e8 01       	movw	r28, r16
     d74:	2c 96       	adiw	r28, 0x0c	; 12
			{
				break;
			}
							
			if (!_tracks[i].deltaTime) //A DeltaTime has reached 0;
     d76:	58 01       	movw	r10, r16
     d78:	28 e0       	ldi	r18, 0x08	; 8
     d7a:	a2 0e       	add	r10, r18
     d7c:	b1 1c       	adc	r11, r1
			{
					
				printf("Track %u send 0x%02x %u %u\r\n", i, _tracks[i].eventByte, _tracks[i].eventData1, _tracks[i].eventData2);
     d7e:	68 01       	movw	r12, r16
     d80:	3e e0       	ldi	r19, 0x0E	; 14
     d82:	c3 0e       	add	r12, r19
     d84:	d1 1c       	adc	r13, r1
     d86:	03 5f       	subi	r16, 0xF3	; 243
     d88:	1f 4f       	sbci	r17, 0xFF	; 255
				prevNote = _tracks[i].eventData1;
				sendMidi(_tracks[i].eventByte);
				sendMidi(_tracks[i].eventData1);
				sendMidi(_tracks[i].eventData2);
				
				out = getNextEvent(i);
     d8a:	4e 2c       	mov	r4, r14
		memSendAddress(_tracks[i].startAddress + _tracks[i].addressOffset);
												
		//Get the next event and keep sending as long as the deltatime is 0										
		while(1)
		{	
			if (!_tracks[i].eventByte) //if there is no event, skip ahead
     d8c:	88 81       	ld	r24, Y
     d8e:	88 23       	and	r24, r24
     d90:	09 f4       	brne	.+2      	; 0xd94 <main+0x106>
     d92:	79 c0       	rjmp	.+242    	; 0xe86 <main+0x1f8>
			{
				break;
			}
							
			if (!_tracks[i].deltaTime) //A DeltaTime has reached 0;
     d94:	f5 01       	movw	r30, r10
     d96:	80 81       	ld	r24, Z
     d98:	91 81       	ldd	r25, Z+1	; 0x01
     d9a:	a2 81       	ldd	r26, Z+2	; 0x02
     d9c:	b3 81       	ldd	r27, Z+3	; 0x03
     d9e:	89 2b       	or	r24, r25
     da0:	8a 2b       	or	r24, r26
     da2:	8b 2b       	or	r24, r27
     da4:	09 f0       	breq	.+2      	; 0xda8 <main+0x11a>
     da6:	6f c0       	rjmp	.+222    	; 0xe86 <main+0x1f8>
			{
					
				printf("Track %u send 0x%02x %u %u\r\n", i, _tracks[i].eventByte, _tracks[i].eventData1, _tracks[i].eventData2);
     da8:	d6 01       	movw	r26, r12
     daa:	2c 91       	ld	r18, X
     dac:	f8 01       	movw	r30, r16
     dae:	90 81       	ld	r25, Z
     db0:	88 81       	ld	r24, Y
     db2:	1f 92       	push	r1
     db4:	2f 93       	push	r18
     db6:	1f 92       	push	r1
     db8:	9f 93       	push	r25
     dba:	1f 92       	push	r1
     dbc:	8f 93       	push	r24
     dbe:	ff 92       	push	r15
     dc0:	ef 92       	push	r14
     dc2:	9f 92       	push	r9
     dc4:	8f 92       	push	r8
     dc6:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
				prevEventByte = _tracks[i].eventByte;
     dca:	58 80       	ld	r5, Y
				prevNote = _tracks[i].eventData1;
     dcc:	d8 01       	movw	r26, r16
     dce:	3c 90       	ld	r3, X
				sendMidi(_tracks[i].eventByte);
     dd0:	88 81       	ld	r24, Y
     dd2:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
				sendMidi(_tracks[i].eventData1);
     dd6:	f8 01       	movw	r30, r16
     dd8:	80 81       	ld	r24, Z
     dda:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
				sendMidi(_tracks[i].eventData2);
     dde:	d6 01       	movw	r26, r12
     de0:	8c 91       	ld	r24, X
     de2:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
				
				out = getNextEvent(i);
     de6:	84 2d       	mov	r24, r4
     de8:	0e 94 81 03 	call	0x702	; 0x702 <getNextEvent>
				if (out == 0)
     dec:	ed b7       	in	r30, 0x3d	; 61
     dee:	fe b7       	in	r31, 0x3e	; 62
     df0:	3a 96       	adiw	r30, 0x0a	; 10
     df2:	ed bf       	out	0x3d, r30	; 61
     df4:	fe bf       	out	0x3e, r31	; 62
     df6:	88 23       	and	r24, r24
     df8:	09 f4       	brne	.+2      	; 0xdfc <main+0x16e>
     dfa:	45 c0       	rjmp	.+138    	; 0xe86 <main+0x1f8>
				{
					break;
				}		
				
				if (out == 0x2F)
     dfc:	8f 32       	cpi	r24, 0x2F	; 47
     dfe:	91 f4       	brne	.+36     	; 0xe24 <main+0x196>
				{
					printf("End of track %u\r\n", i);
     e00:	ff 92       	push	r15
     e02:	ef 92       	push	r14
     e04:	af e7       	ldi	r26, 0x7F	; 127
     e06:	b1 e2       	ldi	r27, 0x21	; 33
     e08:	bf 93       	push	r27
     e0a:	af 93       	push	r26
     e0c:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
					_activeTracks--;
     e10:	80 91 e3 21 	lds	r24, 0x21E3	; 0x8021e3 <_activeTracks>
     e14:	81 50       	subi	r24, 0x01	; 1
     e16:	80 93 e3 21 	sts	0x21E3, r24	; 0x8021e3 <_activeTracks>
     e1a:	0f 90       	pop	r0
     e1c:	0f 90       	pop	r0
     e1e:	0f 90       	pop	r0
     e20:	0f 90       	pop	r0
     e22:	31 c0       	rjmp	.+98     	; 0xe86 <main+0x1f8>
					break;
				}
				//printf("prev %02x next %02x prev note %u next note %u next track len %lu\r\n",prevEventByte, _tracks[i].eventByte,  prevNote, _tracks[i].eventData1, _tracks[i].deltaTime);
				if ((prevEventByte & 0xF0) == MIDI_NOTE_ON_MASK && (_tracks[i].eventByte & 0xF0) == MIDI_NOTE_OFF_MASK && _tracks[i].deltaTime == 0 && prevNote == _tracks[i].eventData1) // Skipping a note off if it was 0 length since the last.
     e24:	85 2d       	mov	r24, r5
     e26:	80 7f       	andi	r24, 0xF0	; 240
     e28:	80 39       	cpi	r24, 0x90	; 144
     e2a:	09 f0       	breq	.+2      	; 0xe2e <main+0x1a0>
     e2c:	af cf       	rjmp	.-162    	; 0xd8c <main+0xfe>
     e2e:	88 81       	ld	r24, Y
     e30:	80 7f       	andi	r24, 0xF0	; 240
     e32:	80 38       	cpi	r24, 0x80	; 128
     e34:	09 f0       	breq	.+2      	; 0xe38 <main+0x1aa>
     e36:	aa cf       	rjmp	.-172    	; 0xd8c <main+0xfe>
     e38:	f5 01       	movw	r30, r10
     e3a:	80 81       	ld	r24, Z
     e3c:	91 81       	ldd	r25, Z+1	; 0x01
     e3e:	a2 81       	ldd	r26, Z+2	; 0x02
     e40:	b3 81       	ldd	r27, Z+3	; 0x03
     e42:	89 2b       	or	r24, r25
     e44:	8a 2b       	or	r24, r26
     e46:	8b 2b       	or	r24, r27
     e48:	09 f0       	breq	.+2      	; 0xe4c <main+0x1be>
     e4a:	a0 cf       	rjmp	.-192    	; 0xd8c <main+0xfe>
     e4c:	d8 01       	movw	r26, r16
     e4e:	8c 91       	ld	r24, X
     e50:	38 12       	cpse	r3, r24
     e52:	9c cf       	rjmp	.-200    	; 0xd8c <main+0xfe>
				{

					//printf("Note %u Off removed ", prevNote);
					//printf("Event was: Track %u send 0x%02x %u %u\r\n", i, _tracks[i].eventByte, _tracks[i].eventData1, _tracks[i].eventData2);
					out = getNextEvent(i);
     e54:	84 2d       	mov	r24, r4
     e56:	0e 94 81 03 	call	0x702	; 0x702 <getNextEvent>
					if (out == 0)
     e5a:	88 23       	and	r24, r24
     e5c:	a1 f0       	breq	.+40     	; 0xe86 <main+0x1f8>
					{
						break;
					}
					
					if (out == 0x2F)
     e5e:	8f 32       	cpi	r24, 0x2F	; 47
     e60:	09 f0       	breq	.+2      	; 0xe64 <main+0x1d6>
     e62:	94 cf       	rjmp	.-216    	; 0xd8c <main+0xfe>
					{
						printf("End of track %u\r\n", i);
     e64:	ff 92       	push	r15
     e66:	ef 92       	push	r14
     e68:	af e7       	ldi	r26, 0x7F	; 127
     e6a:	b1 e2       	ldi	r27, 0x21	; 33
     e6c:	bf 93       	push	r27
     e6e:	af 93       	push	r26
     e70:	0e 94 b8 09 	call	0x1370	; 0x1370 <printf>
						_activeTracks--;
     e74:	80 91 e3 21 	lds	r24, 0x21E3	; 0x8021e3 <_activeTracks>
     e78:	81 50       	subi	r24, 0x01	; 1
     e7a:	80 93 e3 21 	sts	0x21E3, r24	; 0x8021e3 <_activeTracks>
     e7e:	0f 90       	pop	r0
     e80:	0f 90       	pop	r0
     e82:	0f 90       	pop	r0
     e84:	0f 90       	pop	r0
			{
				break;
			}
		}
			//printf("offset: %lu, lenght %lu\r\n", _tracks[i].addressOffset , _tracks[i].trackLength);
		CS_DISABLE();
     e86:	e0 e1       	ldi	r30, 0x10	; 16
     e88:	d3 01       	movw	r26, r6
     e8a:	15 96       	adiw	r26, 0x05	; 5
     e8c:	ec 93       	st	X, r30

		//Just to avoid overflowing deltatime (since it's a 32 bit number). This may actually be slower and it may not matter in the end
		if(_tracks[i].deltaTime)						
     e8e:	2e 9c       	mul	r2, r14
     e90:	f0 01       	movw	r30, r0
     e92:	2f 9c       	mul	r2, r15
     e94:	f0 0d       	add	r31, r0
     e96:	11 24       	eor	r1, r1
     e98:	e0 51       	subi	r30, 0x10	; 16
     e9a:	fe 4d       	sbci	r31, 0xDE	; 222
     e9c:	80 85       	ldd	r24, Z+8	; 0x08
     e9e:	91 85       	ldd	r25, Z+9	; 0x09
     ea0:	a2 85       	ldd	r26, Z+10	; 0x0a
     ea2:	b3 85       	ldd	r27, Z+11	; 0x0b
     ea4:	89 2b       	or	r24, r25
     ea6:	8a 2b       	or	r24, r26
     ea8:	8b 2b       	or	r24, r27
     eaa:	91 f0       	breq	.+36     	; 0xed0 <main+0x242>
		{
			_tracks[i].deltaTime--;	
     eac:	2e 9c       	mul	r2, r14
     eae:	f0 01       	movw	r30, r0
     eb0:	2f 9c       	mul	r2, r15
     eb2:	f0 0d       	add	r31, r0
     eb4:	11 24       	eor	r1, r1
     eb6:	e0 51       	subi	r30, 0x10	; 16
     eb8:	fe 4d       	sbci	r31, 0xDE	; 222
     eba:	80 85       	ldd	r24, Z+8	; 0x08
     ebc:	91 85       	ldd	r25, Z+9	; 0x09
     ebe:	a2 85       	ldd	r26, Z+10	; 0x0a
     ec0:	b3 85       	ldd	r27, Z+11	; 0x0b
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	a1 09       	sbc	r26, r1
     ec6:	b1 09       	sbc	r27, r1
     ec8:	80 87       	std	Z+8, r24	; 0x08
     eca:	91 87       	std	Z+9, r25	; 0x09
     ecc:	a2 87       	std	Z+10, r26	; 0x0a
     ece:	b3 87       	std	Z+11, r27	; 0x0b
		}	
		
		//Here we are checking to see if any tracks are left playing and disabling the timer if there are none.
		//This also handles what to do next for play modes.
		if (!_activeTracks)
     ed0:	80 91 e3 21 	lds	r24, 0x21E3	; 0x8021e3 <_activeTracks>
     ed4:	81 11       	cpse	r24, r1
     ed6:	65 c0       	rjmp	.+202    	; 0xfa2 <main+0x314>
		{
			TIMER_DISABLE();
     ed8:	a0 e0       	ldi	r26, 0x00	; 0
     eda:	b8 e0       	ldi	r27, 0x08	; 8
     edc:	1c 92       	st	X, r1
	TIMER_ENABLE();
}

static inline void  stopMidi()
{
	sendMidi(MIDI_STOP);
     ede:	8c ef       	ldi	r24, 0xFC	; 252
     ee0:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_DISABLE();
     ee4:	e0 e0       	ldi	r30, 0x00	; 0
     ee6:	f8 e0       	ldi	r31, 0x08	; 8
     ee8:	10 82       	st	Z, r1
		{
			TIMER_DISABLE();
			//If mode 2, we just stop
			stopMidi();
			
			if ((_statusFlags & INPUT_PLAY_MODE_MASK) == 0x04) //Loop mode
     eea:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     eee:	8c 70       	andi	r24, 0x0C	; 12
     ef0:	84 30       	cpi	r24, 0x04	; 4
     ef2:	d9 f4       	brne	.+54     	; 0xf2a <main+0x29c>
			{
				loadFile(_fileIndex);
     ef4:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     ef8:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     efc:	0e 94 1f 06 	call	0xc3e	; 0xc3e <loadFile>

//The following static inline methods are made inline so less stack space is used, better performance, and have no internal variables. They are broken out for readability. May have to remove inline if code space is needed

static inline void  startMidi()
{
	sendMidi(MIDI_START);
     f00:	8a ef       	ldi	r24, 0xFA	; 250
     f02:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi((_fileIndex >> 8));
     f06:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     f0a:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f0e:	89 2f       	mov	r24, r25
     f10:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi(_fileIndex);
     f14:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     f18:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f1c:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_ENABLE();
     f20:	83 e0       	ldi	r24, 0x03	; 3
     f22:	a0 e0       	ldi	r26, 0x00	; 0
     f24:	b8 e0       	ldi	r27, 0x08	; 8
     f26:	8c 93       	st	X, r24
     f28:	3c c0       	rjmp	.+120    	; 0xfa2 <main+0x314>
			if ((_statusFlags & INPUT_PLAY_MODE_MASK) == 0x04) //Loop mode
			{
				loadFile(_fileIndex);
				startMidi();
			}
			else if ((_statusFlags & INPUT_PLAY_MODE_MASK) == 0) //Continuous mode
     f2a:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     f2e:	8c 70       	andi	r24, 0x0C	; 12
     f30:	c1 f5       	brne	.+112    	; 0xfa2 <main+0x314>
	TIMER_DISABLE();
}

static inline void  moveToNext()
{
	_fileIndex++;
     f32:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     f36:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f3a:	01 96       	adiw	r24, 0x01	; 1
     f3c:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
     f40:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
	if (_fileIndex >= _fileCount)
     f44:	20 91 ea 21 	lds	r18, 0x21EA	; 0x8021ea <_fileIndex>
     f48:	30 91 eb 21 	lds	r19, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f4c:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
     f50:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
     f54:	28 17       	cp	r18, r24
     f56:	39 07       	cpc	r19, r25
     f58:	20 f0       	brcs	.+8      	; 0xf62 <main+0x2d4>
	{
		_fileIndex = 0;
     f5a:	10 92 ea 21 	sts	0x21EA, r1	; 0x8021ea <_fileIndex>
     f5e:	10 92 eb 21 	sts	0x21EB, r1	; 0x8021eb <_fileIndex+0x1>
	TIMER_ENABLE();
}

static inline void  stopMidi()
{
	sendMidi(MIDI_STOP);
     f62:	8c ef       	ldi	r24, 0xFC	; 252
     f64:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_DISABLE();
     f68:	e0 e0       	ldi	r30, 0x00	; 0
     f6a:	f8 e0       	ldi	r31, 0x08	; 8
     f6c:	10 82       	st	Z, r1
	{
		_fileIndex = 0;
	}
			
	stopMidi(); //to stop the current notes that are playing
	loadFile(_fileIndex);
     f6e:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     f72:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f76:	0e 94 1f 06 	call	0xc3e	; 0xc3e <loadFile>

//The following static inline methods are made inline so less stack space is used, better performance, and have no internal variables. They are broken out for readability. May have to remove inline if code space is needed

static inline void  startMidi()
{
	sendMidi(MIDI_START);
     f7a:	8a ef       	ldi	r24, 0xFA	; 250
     f7c:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi((_fileIndex >> 8));
     f80:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     f84:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f88:	89 2f       	mov	r24, r25
     f8a:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi(_fileIndex);
     f8e:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
     f92:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
     f96:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_ENABLE();
     f9a:	83 e0       	ldi	r24, 0x03	; 3
     f9c:	a0 e0       	ldi	r26, 0x00	; 0
     f9e:	b8 e0       	ldi	r27, 0x08	; 8
     fa0:	8c 93       	st	X, r24
	//3: goto 1.
	uint8_t prevEventByte;
	uint8_t prevNote;
	uint8_t out = 0;

	for(uint16_t i = 0; i < _tractCount; i++)
     fa2:	bf ef       	ldi	r27, 0xFF	; 255
     fa4:	eb 1a       	sub	r14, r27
     fa6:	fb 0a       	sbc	r15, r27
     fa8:	80 91 e4 21 	lds	r24, 0x21E4	; 0x8021e4 <_tractCount>
     fac:	90 91 e5 21 	lds	r25, 0x21E5	; 0x8021e5 <_tractCount+0x1>
     fb0:	e8 16       	cp	r14, r24
     fb2:	f9 06       	cpc	r15, r25
     fb4:	08 f4       	brcc	.+2      	; 0xfb8 <main+0x32a>
     fb6:	b0 ce       	rjmp	.-672    	; 0xd18 <main+0x8a>
    while (1) 
    {
		if (_clockTickFlag)
		{
			handleClockTick();
			_clockTickFlag = 0x00;
     fb8:	10 92 e2 21 	sts	0x21E2, r1	; 0x8021e2 <__data_end>

static inline void checkButtons()
{
				
	//NOTE: Counts are guaranteed not to roll over
	if (_input0Counts >= 100) //approx 1000ms hold
     fbc:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <_input0Counts>
     fc0:	84 36       	cpi	r24, 0x64	; 100
     fc2:	08 f4       	brcc	.+2      	; 0xfc6 <main+0x338>
     fc4:	46 c0       	rjmp	.+140    	; 0x1052 <main+0x3c4>
	{
		if (!(_statusFlags & INPUT_PLAY_MODE_UPDATING_MASK)) //If already in updating mode, do nothing. Basically if the button is still being held, don't try to update play mode again.
     fc6:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     fca:	86 fd       	sbrc	r24, 6
     fcc:	b7 c0       	rjmp	.+366    	; 0x113c <main+0x4ae>
		{
			printf("Update midi play mode\r\n");
     fce:	81 e9       	ldi	r24, 0x91	; 145
     fd0:	91 e2       	ldi	r25, 0x21	; 33
     fd2:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
			_statusFlags &= ~INPUT_BUTTON_0_MASK; //Clear the button 0 flag to ensure this does not allow the midi to become immediately unpaused
     fd6:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     fda:	8e 7f       	andi	r24, 0xFE	; 254
     fdc:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
			_statusFlags |= INPUT_PLAY_MODE_UPDATING_MASK;
     fe0:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     fe4:	80 64       	ori	r24, 0x40	; 64
     fe6:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>

//Three play modes: 0 = continuous play, 1 = repeat, 2 = stop after finished with current
//Updates bits 3:2 of the status
static inline void  updateMidiPlayMode()
{
	if ((_statusFlags & INPUT_PLAY_MODE_MASK) == 0x08)
     fea:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     fee:	8c 70       	andi	r24, 0x0C	; 12
     ff0:	88 30       	cpi	r24, 0x08	; 8
     ff2:	31 f4       	brne	.+12     	; 0x1000 <main+0x372>
	{
		_statusFlags &= 0xF3; //Set the play mode to 0
     ff4:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
     ff8:	83 7f       	andi	r24, 0xF3	; 243
     ffa:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
     ffe:	1e c0       	rjmp	.+60     	; 0x103c <main+0x3ae>
	}
	else if ((_statusFlags & INPUT_PLAY_MODE_MASK) == 0x04)
    1000:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1004:	8c 70       	andi	r24, 0x0C	; 12
    1006:	84 30       	cpi	r24, 0x04	; 4
    1008:	59 f4       	brne	.+22     	; 0x1020 <main+0x392>
	{
		//first reset to 0
		_statusFlags &= 0xF3; //Clear the play mode bits
    100a:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    100e:	83 7f       	andi	r24, 0xF3	; 243
    1010:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
		_statusFlags |= 0x08; //Set the play mode to 2
    1014:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1018:	88 60       	ori	r24, 0x08	; 8
    101a:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
    101e:	0e c0       	rjmp	.+28     	; 0x103c <main+0x3ae>
		
	}
	else if ((_statusFlags & INPUT_PLAY_MODE_MASK) == 0)
    1020:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1024:	8c 70       	andi	r24, 0x0C	; 12
    1026:	51 f4       	brne	.+20     	; 0x103c <main+0x3ae>
	{
		_statusFlags &= 0xF3; //Clear the play mode bits
    1028:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    102c:	83 7f       	andi	r24, 0xF3	; 243
    102e:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
		_statusFlags |= 0x04; //Set the play mode to 1
    1032:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1036:	84 60       	ori	r24, 0x04	; 4
    1038:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
	}
	
	sendMidi(MIDI_UPDATE_MODE);
    103c:	8d ef       	ldi	r24, 0xFD	; 253
    103e:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi(((_statusFlags / 4) & 0x3));
    1042:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1046:	86 95       	lsr	r24
    1048:	86 95       	lsr	r24
    104a:	83 70       	andi	r24, 0x03	; 3
    104c:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
    1050:	75 c0       	rjmp	.+234    	; 0x113c <main+0x4ae>
			_statusFlags &= ~INPUT_BUTTON_0_MASK; //Clear the button 0 flag to ensure this does not allow the midi to become immediately unpaused
			_statusFlags |= INPUT_PLAY_MODE_UPDATING_MASK;
			updateMidiPlayMode();
		}
	}
	else if (_input0Counts > 5 && _input1Counts < 100) //approx 50ms hold
    1052:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <_input0Counts>
    1056:	86 30       	cpi	r24, 0x06	; 6
    1058:	50 f0       	brcs	.+20     	; 0x106e <main+0x3e0>
    105a:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    105e:	84 36       	cpi	r24, 0x64	; 100
    1060:	30 f4       	brcc	.+12     	; 0x106e <main+0x3e0>
	{
		_statusFlags |= INPUT_BUTTON_0_MASK; //second bit indicate button 0 is pressed
    1062:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1066:	81 60       	ori	r24, 0x01	; 1
    1068:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
    106c:	67 c0       	rjmp	.+206    	; 0x113c <main+0x4ae>

	}
	else if (_input0Counts == 0)
    106e:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <_input0Counts>
    1072:	81 11       	cpse	r24, r1
    1074:	63 c0       	rjmp	.+198    	; 0x113c <main+0x4ae>
	{
		if ((_statusFlags & INPUT_BUTTON_0_MASK) && !(_statusFlags & INPUT_PLAY_MODE_UPDATING_MASK)) //Only want to move forward or unpause if we didn't just release from a long button 0 hold to update play mode
    1076:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    107a:	80 ff       	sbrs	r24, 0
    107c:	55 c0       	rjmp	.+170    	; 0x1128 <main+0x49a>
    107e:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1082:	86 fd       	sbrc	r24, 6
    1084:	51 c0       	rjmp	.+162    	; 0x1128 <main+0x49a>
		{
			if ((_statusFlags & INPUT_PAUSE_MASK)) //In pause mode and button was pressed and released quickly so unpause instead of moving forward
    1086:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    108a:	88 23       	and	r24, r24
    108c:	8c f4       	brge	.+34     	; 0x10b0 <main+0x422>
			{
				printf("Continue midi\r\n");
    108e:	88 ea       	ldi	r24, 0xA8	; 168
    1090:	91 e2       	ldi	r25, 0x21	; 33
    1092:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
    1096:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    109a:	8f 77       	andi	r24, 0x7F	; 127
    109c:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
	TIMER_ENABLE();
}

static inline void  continueMidi()
{
	sendMidi(MIDI_CONTINUE);
    10a0:	8b ef       	ldi	r24, 0xFB	; 251
    10a2:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_ENABLE();
    10a6:	83 e0       	ldi	r24, 0x03	; 3
    10a8:	e0 e0       	ldi	r30, 0x00	; 0
    10aa:	f8 e0       	ldi	r31, 0x08	; 8
    10ac:	80 83       	st	Z, r24
    10ae:	3c c0       	rjmp	.+120    	; 0x1128 <main+0x49a>
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
				continueMidi();
			}
			else
			{
				printf("Move Forward\r\n");
    10b0:	87 eb       	ldi	r24, 0xB7	; 183
    10b2:	91 e2       	ldi	r25, 0x21	; 33
    10b4:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
	TIMER_DISABLE();
}

static inline void  moveToNext()
{
	_fileIndex++;
    10b8:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    10bc:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    10c0:	01 96       	adiw	r24, 0x01	; 1
    10c2:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
    10c6:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
	if (_fileIndex >= _fileCount)
    10ca:	20 91 ea 21 	lds	r18, 0x21EA	; 0x8021ea <_fileIndex>
    10ce:	30 91 eb 21 	lds	r19, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    10d2:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
    10d6:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
    10da:	28 17       	cp	r18, r24
    10dc:	39 07       	cpc	r19, r25
    10de:	20 f0       	brcs	.+8      	; 0x10e8 <main+0x45a>
	{
		_fileIndex = 0;
    10e0:	10 92 ea 21 	sts	0x21EA, r1	; 0x8021ea <_fileIndex>
    10e4:	10 92 eb 21 	sts	0x21EB, r1	; 0x8021eb <_fileIndex+0x1>
	TIMER_ENABLE();
}

static inline void  stopMidi()
{
	sendMidi(MIDI_STOP);
    10e8:	8c ef       	ldi	r24, 0xFC	; 252
    10ea:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_DISABLE();
    10ee:	a0 e0       	ldi	r26, 0x00	; 0
    10f0:	b8 e0       	ldi	r27, 0x08	; 8
    10f2:	1c 92       	st	X, r1
	{
		_fileIndex = 0;
	}
			
	stopMidi(); //to stop the current notes that are playing
	loadFile(_fileIndex);
    10f4:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    10f8:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    10fc:	0e 94 1f 06 	call	0xc3e	; 0xc3e <loadFile>

//The following static inline methods are made inline so less stack space is used, better performance, and have no internal variables. They are broken out for readability. May have to remove inline if code space is needed

static inline void  startMidi()
{
	sendMidi(MIDI_START);
    1100:	8a ef       	ldi	r24, 0xFA	; 250
    1102:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi((_fileIndex >> 8));
    1106:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    110a:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    110e:	89 2f       	mov	r24, r25
    1110:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi(_fileIndex);
    1114:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    1118:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    111c:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_ENABLE();
    1120:	83 e0       	ldi	r24, 0x03	; 3
    1122:	e0 e0       	ldi	r30, 0x00	; 0
    1124:	f8 e0       	ldi	r31, 0x08	; 8
    1126:	80 83       	st	Z, r24
				moveToNext();
			}
		}
			
		//Always reset button down status
		_statusFlags &= ~INPUT_BUTTON_0_MASK; //Clear the button 0 flag
    1128:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    112c:	8e 7f       	andi	r24, 0xFE	; 254
    112e:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
		//Always reset play mode update status
		_statusFlags &= ~INPUT_PLAY_MODE_UPDATING_MASK;
    1132:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1136:	8f 7b       	andi	r24, 0xBF	; 191
    1138:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
		
		
		
		
	//NOTE: Counts are guaranteed not to roll over
	if (_input1Counts >= 100) //approx 1000ms hold
    113c:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    1140:	84 36       	cpi	r24, 0x64	; 100
    1142:	d0 f0       	brcs	.+52     	; 0x1178 <main+0x4ea>
	{
		if (!(_statusFlags & INPUT_PAUSE_MASK))	//If already in pause mode, don't pause again
    1144:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1148:	88 23       	and	r24, r24
    114a:	0c f4       	brge	.+2      	; 0x114e <main+0x4c0>
    114c:	d7 cd       	rjmp	.-1106   	; 0xcfc <main+0x6e>
		{
			printf("Pause midi play\r\n");
    114e:	85 ec       	ldi	r24, 0xC5	; 197
    1150:	91 e2       	ldi	r25, 0x21	; 33
    1152:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
			_statusFlags |= INPUT_PAUSE_MASK; //set pause status
    1156:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    115a:	80 68       	ori	r24, 0x80	; 128
    115c:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
			_statusFlags &= ~INPUT_BUTTON_1_MASK; //Clear the button 1 flag to ensure this does not allow the midi to become immediately unpaused
    1160:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1164:	8d 7f       	andi	r24, 0xFD	; 253
    1166:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
	TIMER_ENABLE();
}

static inline void  stopMidi()
{
	sendMidi(MIDI_STOP);
    116a:	8c ef       	ldi	r24, 0xFC	; 252
    116c:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_DISABLE();
    1170:	a0 e0       	ldi	r26, 0x00	; 0
    1172:	b8 e0       	ldi	r27, 0x08	; 8
    1174:	1c 92       	st	X, r1
    1176:	c2 cd       	rjmp	.-1148   	; 0xcfc <main+0x6e>
			_statusFlags |= INPUT_PAUSE_MASK; //set pause status
			_statusFlags &= ~INPUT_BUTTON_1_MASK; //Clear the button 1 flag to ensure this does not allow the midi to become immediately unpaused
			stopMidi();
		}
	}
	else if (_input1Counts > 5 && _input1Counts < 100) //approx 50ms hold
    1178:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    117c:	86 30       	cpi	r24, 0x06	; 6
    117e:	50 f0       	brcs	.+20     	; 0x1194 <main+0x506>
    1180:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    1184:	84 36       	cpi	r24, 0x64	; 100
    1186:	30 f4       	brcc	.+12     	; 0x1194 <main+0x506>
	{
		_statusFlags |= INPUT_BUTTON_1_MASK; //second bit indicate button 1 is pressed
    1188:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    118c:	82 60       	ori	r24, 0x02	; 2
    118e:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
    1192:	b4 cd       	rjmp	.-1176   	; 0xcfc <main+0x6e>

	}
	else if (_input1Counts == 0)
    1194:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    1198:	81 11       	cpse	r24, r1
    119a:	b0 cd       	rjmp	.-1184   	; 0xcfc <main+0x6e>
	{
		if ( (_statusFlags & INPUT_BUTTON_1_MASK))
    119c:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    11a0:	81 ff       	sbrs	r24, 1
    11a2:	5d c0       	rjmp	.+186    	; 0x125e <main+0x5d0>
		{
			if ((_statusFlags & INPUT_PAUSE_MASK)) //In pause mode and button was pressed and released quickly so unpause instead of moving forward
    11a4:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    11a8:	88 23       	and	r24, r24
    11aa:	8c f4       	brge	.+34     	; 0x11ce <main+0x540>
			{
				printf("Continue midi\r\n");
    11ac:	88 ea       	ldi	r24, 0xA8	; 168
    11ae:	91 e2       	ldi	r25, 0x21	; 33
    11b0:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
    11b4:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    11b8:	8f 77       	andi	r24, 0x7F	; 127
    11ba:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
	TIMER_ENABLE();
}

static inline void  continueMidi()
{
	sendMidi(MIDI_CONTINUE);
    11be:	8b ef       	ldi	r24, 0xFB	; 251
    11c0:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_ENABLE();
    11c4:	83 e0       	ldi	r24, 0x03	; 3
    11c6:	e0 e0       	ldi	r30, 0x00	; 0
    11c8:	f8 e0       	ldi	r31, 0x08	; 8
    11ca:	80 83       	st	Z, r24
    11cc:	48 c0       	rjmp	.+144    	; 0x125e <main+0x5d0>
				_statusFlags &= ~INPUT_PAUSE_MASK; //clear midi flag
				continueMidi();
			}
			else
			{
				printf("Move Back\r\n");
    11ce:	86 ed       	ldi	r24, 0xD6	; 214
    11d0:	91 e2       	ldi	r25, 0x21	; 33
    11d2:	0e 94 cc 09 	call	0x1398	; 0x1398 <puts>
	startMidi();	
}

static inline void  moveToPrevious()
{
	if (_fileIndex == 0 || _fileIndex >= _fileCount)
    11d6:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    11da:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    11de:	89 2b       	or	r24, r25
    11e0:	59 f0       	breq	.+22     	; 0x11f8 <main+0x56a>
    11e2:	20 91 ea 21 	lds	r18, 0x21EA	; 0x8021ea <_fileIndex>
    11e6:	30 91 eb 21 	lds	r19, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    11ea:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
    11ee:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
    11f2:	28 17       	cp	r18, r24
    11f4:	39 07       	cpc	r19, r25
    11f6:	50 f0       	brcs	.+20     	; 0x120c <main+0x57e>
	{
		_fileIndex = _fileCount - 1;
    11f8:	80 91 ec 21 	lds	r24, 0x21EC	; 0x8021ec <_fileCount>
    11fc:	90 91 ed 21 	lds	r25, 0x21ED	; 0x8021ed <_fileCount+0x1>
    1200:	01 97       	sbiw	r24, 0x01	; 1
    1202:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
    1206:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
    120a:	09 c0       	rjmp	.+18     	; 0x121e <main+0x590>
	}
	else
	{
		_fileIndex--;
    120c:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    1210:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    1214:	01 97       	sbiw	r24, 0x01	; 1
    1216:	80 93 ea 21 	sts	0x21EA, r24	; 0x8021ea <_fileIndex>
    121a:	90 93 eb 21 	sts	0x21EB, r25	; 0x8021eb <_fileIndex+0x1>
	TIMER_ENABLE();
}

static inline void  stopMidi()
{
	sendMidi(MIDI_STOP);
    121e:	8c ef       	ldi	r24, 0xFC	; 252
    1220:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_DISABLE();
    1224:	a0 e0       	ldi	r26, 0x00	; 0
    1226:	b8 e0       	ldi	r27, 0x08	; 8
    1228:	1c 92       	st	X, r1
	{
		_fileIndex--;
	}
			
	stopMidi(); //to stop the current notes that are playing
	loadFile(_fileIndex);
    122a:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    122e:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    1232:	0e 94 1f 06 	call	0xc3e	; 0xc3e <loadFile>

//The following static inline methods are made inline so less stack space is used, better performance, and have no internal variables. They are broken out for readability. May have to remove inline if code space is needed

static inline void  startMidi()
{
	sendMidi(MIDI_START);
    1236:	8a ef       	ldi	r24, 0xFA	; 250
    1238:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi((_fileIndex >> 8));
    123c:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    1240:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    1244:	89 2f       	mov	r24, r25
    1246:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	sendMidi(_fileIndex);
    124a:	80 91 ea 21 	lds	r24, 0x21EA	; 0x8021ea <_fileIndex>
    124e:	90 91 eb 21 	lds	r25, 0x21EB	; 0x8021eb <_fileIndex+0x1>
    1252:	0e 94 87 01 	call	0x30e	; 0x30e <sendMidi>
	TIMER_ENABLE();
    1256:	83 e0       	ldi	r24, 0x03	; 3
    1258:	e0 e0       	ldi	r30, 0x00	; 0
    125a:	f8 e0       	ldi	r31, 0x08	; 8
    125c:	80 83       	st	Z, r24
				printf("Move Back\r\n");
				moveToPrevious();
			}
		}
		//Always reset button down status
		_statusFlags &= ~INPUT_BUTTON_1_MASK; //Clear the button 1 flag
    125e:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <_statusFlags>
    1262:	8d 7f       	andi	r24, 0xFD	; 253
    1264:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <_statusFlags>
    1268:	49 cd       	rjmp	.-1390   	; 0xcfc <main+0x6e>

0000126a <__vector_14>:
	
    }
}

ISR(TCC0_OVF_vect)
{
    126a:	1f 92       	push	r1
    126c:	0f 92       	push	r0
    126e:	0f b6       	in	r0, 0x3f	; 63
    1270:	0f 92       	push	r0
    1272:	11 24       	eor	r1, r1
    1274:	08 b6       	in	r0, 0x38	; 56
    1276:	0f 92       	push	r0
    1278:	18 be       	out	0x38, r1	; 56
    127a:	8f 93       	push	r24
	PORTA.OUTTGL = PIN5_bm;
    127c:	80 e2       	ldi	r24, 0x20	; 32
    127e:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <__TEXT_REGION_LENGTH__+0x700607>
	_clockTickFlag = 0xFF;
    1282:	8f ef       	ldi	r24, 0xFF	; 255
    1284:	80 93 e2 21 	sts	0x21E2, r24	; 0x8021e2 <__data_end>
}
    1288:	8f 91       	pop	r24
    128a:	0f 90       	pop	r0
    128c:	08 be       	out	0x38, r0	; 56
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63
    1292:	0f 90       	pop	r0
    1294:	1f 90       	pop	r1
    1296:	18 95       	reti

00001298 <__vector_20>:

ISR(TCC1_OVF_vect)
{
    1298:	1f 92       	push	r1
    129a:	0f 92       	push	r0
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	0f 92       	push	r0
    12a0:	11 24       	eor	r1, r1
    12a2:	08 b6       	in	r0, 0x38	; 56
    12a4:	0f 92       	push	r0
    12a6:	18 be       	out	0x38, r1	; 56
    12a8:	0b b6       	in	r0, 0x3b	; 59
    12aa:	0f 92       	push	r0
    12ac:	1b be       	out	0x3b, r1	; 59
    12ae:	8f 93       	push	r24
    12b0:	9f 93       	push	r25
    12b2:	ef 93       	push	r30
    12b4:	ff 93       	push	r31
	uint8_t res;
	ADCA.CH1.CTRL |= ADC_CH_START_bm;
    12b6:	e0 e0       	ldi	r30, 0x00	; 0
    12b8:	f2 e0       	ldi	r31, 0x02	; 2
    12ba:	80 a5       	ldd	r24, Z+40	; 0x28
    12bc:	80 68       	ori	r24, 0x80	; 128
    12be:	80 a7       	std	Z+40, r24	; 0x28
	
	while ((ADCA.CH1.CTRL & ADC_CH_START_bm)) {}
    12c0:	80 a5       	ldd	r24, Z+40	; 0x28
    12c2:	88 23       	and	r24, r24
    12c4:	ec f3       	brlt	.-6      	; 0x12c0 <__vector_20+0x28>
	
	res = 	ADCA.CH1.RES;
    12c6:	80 91 2c 02 	lds	r24, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
    12ca:	90 91 2d 02 	lds	r25, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
    12ce:	98 2f       	mov	r25, r24
	//printf("ADC: %u\r\n", ADCA.CH1.RES);
	
	
	
	if (res > 120 && res < 250)
    12d0:	89 57       	subi	r24, 0x79	; 121
    12d2:	81 38       	cpi	r24, 0x81	; 129
    12d4:	60 f4       	brcc	.+24     	; 0x12ee <__vector_20+0x56>
	{
		
		if(_input0Counts < 255)
    12d6:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <_input0Counts>
    12da:	8f 3f       	cpi	r24, 0xFF	; 255
    12dc:	29 f0       	breq	.+10     	; 0x12e8 <__vector_20+0x50>
		{

			_input0Counts++;
    12de:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <_input0Counts>
    12e2:	8f 5f       	subi	r24, 0xFF	; 255
    12e4:	80 93 6d 22 	sts	0x226D, r24	; 0x80226d <_input0Counts>
						//printf("Button 0 held: %u\r\n", _input0Counts);
		}
		_input1Counts = 0;
    12e8:	10 92 6c 22 	sts	0x226C, r1	; 0x80226c <_input1Counts>
    12ec:	12 c0       	rjmp	.+36     	; 0x1312 <__vector_20+0x7a>
	}
	else if (res >= 250)
    12ee:	9a 3f       	cpi	r25, 0xFA	; 250
    12f0:	60 f0       	brcs	.+24     	; 0x130a <__vector_20+0x72>
	{
		
		if(_input1Counts < 255)
    12f2:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    12f6:	8f 3f       	cpi	r24, 0xFF	; 255
    12f8:	29 f0       	breq	.+10     	; 0x1304 <__vector_20+0x6c>
		{

		  _input1Counts++;
    12fa:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <_input1Counts>
    12fe:	8f 5f       	subi	r24, 0xFF	; 255
    1300:	80 93 6c 22 	sts	0x226C, r24	; 0x80226c <_input1Counts>
		  			//printf("Button 1 held %u\r\n", _input1Counts);
		}
		_input0Counts = 0;
    1304:	10 92 6d 22 	sts	0x226D, r1	; 0x80226d <_input0Counts>
    1308:	04 c0       	rjmp	.+8      	; 0x1312 <__vector_20+0x7a>
	}
	else
	{
		_input0Counts = 0;
    130a:	10 92 6d 22 	sts	0x226D, r1	; 0x80226d <_input0Counts>
		_input1Counts = 0;		
    130e:	10 92 6c 22 	sts	0x226C, r1	; 0x80226c <_input1Counts>
	}
    1312:	ff 91       	pop	r31
    1314:	ef 91       	pop	r30
    1316:	9f 91       	pop	r25
    1318:	8f 91       	pop	r24
    131a:	0f 90       	pop	r0
    131c:	0b be       	out	0x3b, r0	; 59
    131e:	0f 90       	pop	r0
    1320:	08 be       	out	0x38, r0	; 56
    1322:	0f 90       	pop	r0
    1324:	0f be       	out	0x3f, r0	; 63
    1326:	0f 90       	pop	r0
    1328:	1f 90       	pop	r1
    132a:	18 95       	reti

0000132c <__udivmodsi4>:
    132c:	a1 e2       	ldi	r26, 0x21	; 33
    132e:	1a 2e       	mov	r1, r26
    1330:	aa 1b       	sub	r26, r26
    1332:	bb 1b       	sub	r27, r27
    1334:	fd 01       	movw	r30, r26
    1336:	0d c0       	rjmp	.+26     	; 0x1352 <__udivmodsi4_ep>

00001338 <__udivmodsi4_loop>:
    1338:	aa 1f       	adc	r26, r26
    133a:	bb 1f       	adc	r27, r27
    133c:	ee 1f       	adc	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	a2 17       	cp	r26, r18
    1342:	b3 07       	cpc	r27, r19
    1344:	e4 07       	cpc	r30, r20
    1346:	f5 07       	cpc	r31, r21
    1348:	20 f0       	brcs	.+8      	; 0x1352 <__udivmodsi4_ep>
    134a:	a2 1b       	sub	r26, r18
    134c:	b3 0b       	sbc	r27, r19
    134e:	e4 0b       	sbc	r30, r20
    1350:	f5 0b       	sbc	r31, r21

00001352 <__udivmodsi4_ep>:
    1352:	66 1f       	adc	r22, r22
    1354:	77 1f       	adc	r23, r23
    1356:	88 1f       	adc	r24, r24
    1358:	99 1f       	adc	r25, r25
    135a:	1a 94       	dec	r1
    135c:	69 f7       	brne	.-38     	; 0x1338 <__udivmodsi4_loop>
    135e:	60 95       	com	r22
    1360:	70 95       	com	r23
    1362:	80 95       	com	r24
    1364:	90 95       	com	r25
    1366:	9b 01       	movw	r18, r22
    1368:	ac 01       	movw	r20, r24
    136a:	bd 01       	movw	r22, r26
    136c:	cf 01       	movw	r24, r30
    136e:	08 95       	ret

00001370 <printf>:
    1370:	cf 93       	push	r28
    1372:	df 93       	push	r29
    1374:	cd b7       	in	r28, 0x3d	; 61
    1376:	de b7       	in	r29, 0x3e	; 62
    1378:	ae 01       	movw	r20, r28
    137a:	4a 5f       	subi	r20, 0xFA	; 250
    137c:	5f 4f       	sbci	r21, 0xFF	; 255
    137e:	fa 01       	movw	r30, r20
    1380:	61 91       	ld	r22, Z+
    1382:	71 91       	ld	r23, Z+
    1384:	af 01       	movw	r20, r30
    1386:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <__iob+0x2>
    138a:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <__iob+0x3>
    138e:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <vfprintf>
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	08 95       	ret

00001398 <puts>:
    1398:	0f 93       	push	r16
    139a:	1f 93       	push	r17
    139c:	cf 93       	push	r28
    139e:	df 93       	push	r29
    13a0:	e0 91 71 22 	lds	r30, 0x2271	; 0x802271 <__iob+0x2>
    13a4:	f0 91 72 22 	lds	r31, 0x2272	; 0x802272 <__iob+0x3>
    13a8:	23 81       	ldd	r18, Z+3	; 0x03
    13aa:	21 ff       	sbrs	r18, 1
    13ac:	1b c0       	rjmp	.+54     	; 0x13e4 <puts+0x4c>
    13ae:	8c 01       	movw	r16, r24
    13b0:	d0 e0       	ldi	r29, 0x00	; 0
    13b2:	c0 e0       	ldi	r28, 0x00	; 0
    13b4:	f8 01       	movw	r30, r16
    13b6:	81 91       	ld	r24, Z+
    13b8:	8f 01       	movw	r16, r30
    13ba:	60 91 71 22 	lds	r22, 0x2271	; 0x802271 <__iob+0x2>
    13be:	70 91 72 22 	lds	r23, 0x2272	; 0x802272 <__iob+0x3>
    13c2:	db 01       	movw	r26, r22
    13c4:	18 96       	adiw	r26, 0x08	; 8
    13c6:	ed 91       	ld	r30, X+
    13c8:	fc 91       	ld	r31, X
    13ca:	19 97       	sbiw	r26, 0x09	; 9
    13cc:	88 23       	and	r24, r24
    13ce:	31 f0       	breq	.+12     	; 0x13dc <puts+0x44>
    13d0:	19 95       	eicall
    13d2:	89 2b       	or	r24, r25
    13d4:	79 f3       	breq	.-34     	; 0x13b4 <puts+0x1c>
    13d6:	df ef       	ldi	r29, 0xFF	; 255
    13d8:	cf ef       	ldi	r28, 0xFF	; 255
    13da:	ec cf       	rjmp	.-40     	; 0x13b4 <puts+0x1c>
    13dc:	8a e0       	ldi	r24, 0x0A	; 10
    13de:	19 95       	eicall
    13e0:	89 2b       	or	r24, r25
    13e2:	19 f0       	breq	.+6      	; 0x13ea <puts+0x52>
    13e4:	8f ef       	ldi	r24, 0xFF	; 255
    13e6:	9f ef       	ldi	r25, 0xFF	; 255
    13e8:	02 c0       	rjmp	.+4      	; 0x13ee <puts+0x56>
    13ea:	8d 2f       	mov	r24, r29
    13ec:	9c 2f       	mov	r25, r28
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	1f 91       	pop	r17
    13f4:	0f 91       	pop	r16
    13f6:	08 95       	ret

000013f8 <vfprintf>:
    13f8:	2f 92       	push	r2
    13fa:	3f 92       	push	r3
    13fc:	4f 92       	push	r4
    13fe:	5f 92       	push	r5
    1400:	6f 92       	push	r6
    1402:	7f 92       	push	r7
    1404:	8f 92       	push	r8
    1406:	9f 92       	push	r9
    1408:	af 92       	push	r10
    140a:	bf 92       	push	r11
    140c:	cf 92       	push	r12
    140e:	df 92       	push	r13
    1410:	ef 92       	push	r14
    1412:	ff 92       	push	r15
    1414:	0f 93       	push	r16
    1416:	1f 93       	push	r17
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
    141c:	cd b7       	in	r28, 0x3d	; 61
    141e:	de b7       	in	r29, 0x3e	; 62
    1420:	2c 97       	sbiw	r28, 0x0c	; 12
    1422:	cd bf       	out	0x3d, r28	; 61
    1424:	de bf       	out	0x3e, r29	; 62
    1426:	7c 01       	movw	r14, r24
    1428:	6b 01       	movw	r12, r22
    142a:	8a 01       	movw	r16, r20
    142c:	fc 01       	movw	r30, r24
    142e:	16 82       	std	Z+6, r1	; 0x06
    1430:	17 82       	std	Z+7, r1	; 0x07
    1432:	83 81       	ldd	r24, Z+3	; 0x03
    1434:	81 ff       	sbrs	r24, 1
    1436:	bd c1       	rjmp	.+890    	; 0x17b2 <vfprintf+0x3ba>
    1438:	ce 01       	movw	r24, r28
    143a:	01 96       	adiw	r24, 0x01	; 1
    143c:	4c 01       	movw	r8, r24
    143e:	f7 01       	movw	r30, r14
    1440:	93 81       	ldd	r25, Z+3	; 0x03
    1442:	f6 01       	movw	r30, r12
    1444:	93 fd       	sbrc	r25, 3
    1446:	85 91       	lpm	r24, Z+
    1448:	93 ff       	sbrs	r25, 3
    144a:	81 91       	ld	r24, Z+
    144c:	6f 01       	movw	r12, r30
    144e:	88 23       	and	r24, r24
    1450:	09 f4       	brne	.+2      	; 0x1454 <vfprintf+0x5c>
    1452:	ab c1       	rjmp	.+854    	; 0x17aa <vfprintf+0x3b2>
    1454:	85 32       	cpi	r24, 0x25	; 37
    1456:	39 f4       	brne	.+14     	; 0x1466 <vfprintf+0x6e>
    1458:	93 fd       	sbrc	r25, 3
    145a:	85 91       	lpm	r24, Z+
    145c:	93 ff       	sbrs	r25, 3
    145e:	81 91       	ld	r24, Z+
    1460:	6f 01       	movw	r12, r30
    1462:	85 32       	cpi	r24, 0x25	; 37
    1464:	29 f4       	brne	.+10     	; 0x1470 <vfprintf+0x78>
    1466:	b7 01       	movw	r22, r14
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    146e:	e7 cf       	rjmp	.-50     	; 0x143e <vfprintf+0x46>
    1470:	51 2c       	mov	r5, r1
    1472:	31 2c       	mov	r3, r1
    1474:	20 e0       	ldi	r18, 0x00	; 0
    1476:	20 32       	cpi	r18, 0x20	; 32
    1478:	a0 f4       	brcc	.+40     	; 0x14a2 <vfprintf+0xaa>
    147a:	8b 32       	cpi	r24, 0x2B	; 43
    147c:	69 f0       	breq	.+26     	; 0x1498 <vfprintf+0xa0>
    147e:	30 f4       	brcc	.+12     	; 0x148c <vfprintf+0x94>
    1480:	80 32       	cpi	r24, 0x20	; 32
    1482:	59 f0       	breq	.+22     	; 0x149a <vfprintf+0xa2>
    1484:	83 32       	cpi	r24, 0x23	; 35
    1486:	69 f4       	brne	.+26     	; 0x14a2 <vfprintf+0xaa>
    1488:	20 61       	ori	r18, 0x10	; 16
    148a:	2c c0       	rjmp	.+88     	; 0x14e4 <vfprintf+0xec>
    148c:	8d 32       	cpi	r24, 0x2D	; 45
    148e:	39 f0       	breq	.+14     	; 0x149e <vfprintf+0xa6>
    1490:	80 33       	cpi	r24, 0x30	; 48
    1492:	39 f4       	brne	.+14     	; 0x14a2 <vfprintf+0xaa>
    1494:	21 60       	ori	r18, 0x01	; 1
    1496:	26 c0       	rjmp	.+76     	; 0x14e4 <vfprintf+0xec>
    1498:	22 60       	ori	r18, 0x02	; 2
    149a:	24 60       	ori	r18, 0x04	; 4
    149c:	23 c0       	rjmp	.+70     	; 0x14e4 <vfprintf+0xec>
    149e:	28 60       	ori	r18, 0x08	; 8
    14a0:	21 c0       	rjmp	.+66     	; 0x14e4 <vfprintf+0xec>
    14a2:	27 fd       	sbrc	r18, 7
    14a4:	27 c0       	rjmp	.+78     	; 0x14f4 <vfprintf+0xfc>
    14a6:	30 ed       	ldi	r19, 0xD0	; 208
    14a8:	38 0f       	add	r19, r24
    14aa:	3a 30       	cpi	r19, 0x0A	; 10
    14ac:	78 f4       	brcc	.+30     	; 0x14cc <vfprintf+0xd4>
    14ae:	26 ff       	sbrs	r18, 6
    14b0:	06 c0       	rjmp	.+12     	; 0x14be <vfprintf+0xc6>
    14b2:	fa e0       	ldi	r31, 0x0A	; 10
    14b4:	5f 9e       	mul	r5, r31
    14b6:	30 0d       	add	r19, r0
    14b8:	11 24       	eor	r1, r1
    14ba:	53 2e       	mov	r5, r19
    14bc:	13 c0       	rjmp	.+38     	; 0x14e4 <vfprintf+0xec>
    14be:	8a e0       	ldi	r24, 0x0A	; 10
    14c0:	38 9e       	mul	r3, r24
    14c2:	30 0d       	add	r19, r0
    14c4:	11 24       	eor	r1, r1
    14c6:	33 2e       	mov	r3, r19
    14c8:	20 62       	ori	r18, 0x20	; 32
    14ca:	0c c0       	rjmp	.+24     	; 0x14e4 <vfprintf+0xec>
    14cc:	8e 32       	cpi	r24, 0x2E	; 46
    14ce:	21 f4       	brne	.+8      	; 0x14d8 <vfprintf+0xe0>
    14d0:	26 fd       	sbrc	r18, 6
    14d2:	6b c1       	rjmp	.+726    	; 0x17aa <vfprintf+0x3b2>
    14d4:	20 64       	ori	r18, 0x40	; 64
    14d6:	06 c0       	rjmp	.+12     	; 0x14e4 <vfprintf+0xec>
    14d8:	8c 36       	cpi	r24, 0x6C	; 108
    14da:	11 f4       	brne	.+4      	; 0x14e0 <vfprintf+0xe8>
    14dc:	20 68       	ori	r18, 0x80	; 128
    14de:	02 c0       	rjmp	.+4      	; 0x14e4 <vfprintf+0xec>
    14e0:	88 36       	cpi	r24, 0x68	; 104
    14e2:	41 f4       	brne	.+16     	; 0x14f4 <vfprintf+0xfc>
    14e4:	f6 01       	movw	r30, r12
    14e6:	93 fd       	sbrc	r25, 3
    14e8:	85 91       	lpm	r24, Z+
    14ea:	93 ff       	sbrs	r25, 3
    14ec:	81 91       	ld	r24, Z+
    14ee:	6f 01       	movw	r12, r30
    14f0:	81 11       	cpse	r24, r1
    14f2:	c1 cf       	rjmp	.-126    	; 0x1476 <vfprintf+0x7e>
    14f4:	98 2f       	mov	r25, r24
    14f6:	9f 7d       	andi	r25, 0xDF	; 223
    14f8:	95 54       	subi	r25, 0x45	; 69
    14fa:	93 30       	cpi	r25, 0x03	; 3
    14fc:	28 f4       	brcc	.+10     	; 0x1508 <vfprintf+0x110>
    14fe:	0c 5f       	subi	r16, 0xFC	; 252
    1500:	1f 4f       	sbci	r17, 0xFF	; 255
    1502:	ff e3       	ldi	r31, 0x3F	; 63
    1504:	f9 83       	std	Y+1, r31	; 0x01
    1506:	0d c0       	rjmp	.+26     	; 0x1522 <vfprintf+0x12a>
    1508:	83 36       	cpi	r24, 0x63	; 99
    150a:	31 f0       	breq	.+12     	; 0x1518 <vfprintf+0x120>
    150c:	83 37       	cpi	r24, 0x73	; 115
    150e:	71 f0       	breq	.+28     	; 0x152c <vfprintf+0x134>
    1510:	83 35       	cpi	r24, 0x53	; 83
    1512:	09 f0       	breq	.+2      	; 0x1516 <vfprintf+0x11e>
    1514:	5b c0       	rjmp	.+182    	; 0x15cc <vfprintf+0x1d4>
    1516:	22 c0       	rjmp	.+68     	; 0x155c <vfprintf+0x164>
    1518:	f8 01       	movw	r30, r16
    151a:	80 81       	ld	r24, Z
    151c:	89 83       	std	Y+1, r24	; 0x01
    151e:	0e 5f       	subi	r16, 0xFE	; 254
    1520:	1f 4f       	sbci	r17, 0xFF	; 255
    1522:	44 24       	eor	r4, r4
    1524:	43 94       	inc	r4
    1526:	51 2c       	mov	r5, r1
    1528:	54 01       	movw	r10, r8
    152a:	15 c0       	rjmp	.+42     	; 0x1556 <vfprintf+0x15e>
    152c:	38 01       	movw	r6, r16
    152e:	f2 e0       	ldi	r31, 0x02	; 2
    1530:	6f 0e       	add	r6, r31
    1532:	71 1c       	adc	r7, r1
    1534:	f8 01       	movw	r30, r16
    1536:	a0 80       	ld	r10, Z
    1538:	b1 80       	ldd	r11, Z+1	; 0x01
    153a:	26 ff       	sbrs	r18, 6
    153c:	03 c0       	rjmp	.+6      	; 0x1544 <vfprintf+0x14c>
    153e:	65 2d       	mov	r22, r5
    1540:	70 e0       	ldi	r23, 0x00	; 0
    1542:	02 c0       	rjmp	.+4      	; 0x1548 <vfprintf+0x150>
    1544:	6f ef       	ldi	r22, 0xFF	; 255
    1546:	7f ef       	ldi	r23, 0xFF	; 255
    1548:	c5 01       	movw	r24, r10
    154a:	2c 87       	std	Y+12, r18	; 0x0c
    154c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <strnlen>
    1550:	2c 01       	movw	r4, r24
    1552:	83 01       	movw	r16, r6
    1554:	2c 85       	ldd	r18, Y+12	; 0x0c
    1556:	2f 77       	andi	r18, 0x7F	; 127
    1558:	22 2e       	mov	r2, r18
    155a:	17 c0       	rjmp	.+46     	; 0x158a <vfprintf+0x192>
    155c:	38 01       	movw	r6, r16
    155e:	f2 e0       	ldi	r31, 0x02	; 2
    1560:	6f 0e       	add	r6, r31
    1562:	71 1c       	adc	r7, r1
    1564:	f8 01       	movw	r30, r16
    1566:	a0 80       	ld	r10, Z
    1568:	b1 80       	ldd	r11, Z+1	; 0x01
    156a:	26 ff       	sbrs	r18, 6
    156c:	03 c0       	rjmp	.+6      	; 0x1574 <vfprintf+0x17c>
    156e:	65 2d       	mov	r22, r5
    1570:	70 e0       	ldi	r23, 0x00	; 0
    1572:	02 c0       	rjmp	.+4      	; 0x1578 <vfprintf+0x180>
    1574:	6f ef       	ldi	r22, 0xFF	; 255
    1576:	7f ef       	ldi	r23, 0xFF	; 255
    1578:	c5 01       	movw	r24, r10
    157a:	2c 87       	std	Y+12, r18	; 0x0c
    157c:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <strnlen_P>
    1580:	2c 01       	movw	r4, r24
    1582:	2c 85       	ldd	r18, Y+12	; 0x0c
    1584:	20 68       	ori	r18, 0x80	; 128
    1586:	22 2e       	mov	r2, r18
    1588:	83 01       	movw	r16, r6
    158a:	23 fc       	sbrc	r2, 3
    158c:	1b c0       	rjmp	.+54     	; 0x15c4 <vfprintf+0x1cc>
    158e:	83 2d       	mov	r24, r3
    1590:	90 e0       	ldi	r25, 0x00	; 0
    1592:	48 16       	cp	r4, r24
    1594:	59 06       	cpc	r5, r25
    1596:	b0 f4       	brcc	.+44     	; 0x15c4 <vfprintf+0x1cc>
    1598:	b7 01       	movw	r22, r14
    159a:	80 e2       	ldi	r24, 0x20	; 32
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    15a2:	3a 94       	dec	r3
    15a4:	f4 cf       	rjmp	.-24     	; 0x158e <vfprintf+0x196>
    15a6:	f5 01       	movw	r30, r10
    15a8:	27 fc       	sbrc	r2, 7
    15aa:	85 91       	lpm	r24, Z+
    15ac:	27 fe       	sbrs	r2, 7
    15ae:	81 91       	ld	r24, Z+
    15b0:	5f 01       	movw	r10, r30
    15b2:	b7 01       	movw	r22, r14
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    15ba:	31 10       	cpse	r3, r1
    15bc:	3a 94       	dec	r3
    15be:	f1 e0       	ldi	r31, 0x01	; 1
    15c0:	4f 1a       	sub	r4, r31
    15c2:	51 08       	sbc	r5, r1
    15c4:	41 14       	cp	r4, r1
    15c6:	51 04       	cpc	r5, r1
    15c8:	71 f7       	brne	.-36     	; 0x15a6 <vfprintf+0x1ae>
    15ca:	e5 c0       	rjmp	.+458    	; 0x1796 <vfprintf+0x39e>
    15cc:	84 36       	cpi	r24, 0x64	; 100
    15ce:	11 f0       	breq	.+4      	; 0x15d4 <vfprintf+0x1dc>
    15d0:	89 36       	cpi	r24, 0x69	; 105
    15d2:	39 f5       	brne	.+78     	; 0x1622 <vfprintf+0x22a>
    15d4:	f8 01       	movw	r30, r16
    15d6:	27 ff       	sbrs	r18, 7
    15d8:	07 c0       	rjmp	.+14     	; 0x15e8 <vfprintf+0x1f0>
    15da:	60 81       	ld	r22, Z
    15dc:	71 81       	ldd	r23, Z+1	; 0x01
    15de:	82 81       	ldd	r24, Z+2	; 0x02
    15e0:	93 81       	ldd	r25, Z+3	; 0x03
    15e2:	0c 5f       	subi	r16, 0xFC	; 252
    15e4:	1f 4f       	sbci	r17, 0xFF	; 255
    15e6:	08 c0       	rjmp	.+16     	; 0x15f8 <vfprintf+0x200>
    15e8:	60 81       	ld	r22, Z
    15ea:	71 81       	ldd	r23, Z+1	; 0x01
    15ec:	07 2e       	mov	r0, r23
    15ee:	00 0c       	add	r0, r0
    15f0:	88 0b       	sbc	r24, r24
    15f2:	99 0b       	sbc	r25, r25
    15f4:	0e 5f       	subi	r16, 0xFE	; 254
    15f6:	1f 4f       	sbci	r17, 0xFF	; 255
    15f8:	2f 76       	andi	r18, 0x6F	; 111
    15fa:	72 2e       	mov	r7, r18
    15fc:	97 ff       	sbrs	r25, 7
    15fe:	09 c0       	rjmp	.+18     	; 0x1612 <vfprintf+0x21a>
    1600:	90 95       	com	r25
    1602:	80 95       	com	r24
    1604:	70 95       	com	r23
    1606:	61 95       	neg	r22
    1608:	7f 4f       	sbci	r23, 0xFF	; 255
    160a:	8f 4f       	sbci	r24, 0xFF	; 255
    160c:	9f 4f       	sbci	r25, 0xFF	; 255
    160e:	20 68       	ori	r18, 0x80	; 128
    1610:	72 2e       	mov	r7, r18
    1612:	2a e0       	ldi	r18, 0x0A	; 10
    1614:	30 e0       	ldi	r19, 0x00	; 0
    1616:	a4 01       	movw	r20, r8
    1618:	0e 94 3f 0c 	call	0x187e	; 0x187e <__ultoa_invert>
    161c:	a8 2e       	mov	r10, r24
    161e:	a8 18       	sub	r10, r8
    1620:	44 c0       	rjmp	.+136    	; 0x16aa <vfprintf+0x2b2>
    1622:	85 37       	cpi	r24, 0x75	; 117
    1624:	29 f4       	brne	.+10     	; 0x1630 <vfprintf+0x238>
    1626:	2f 7e       	andi	r18, 0xEF	; 239
    1628:	b2 2e       	mov	r11, r18
    162a:	2a e0       	ldi	r18, 0x0A	; 10
    162c:	30 e0       	ldi	r19, 0x00	; 0
    162e:	25 c0       	rjmp	.+74     	; 0x167a <vfprintf+0x282>
    1630:	f2 2f       	mov	r31, r18
    1632:	f9 7f       	andi	r31, 0xF9	; 249
    1634:	bf 2e       	mov	r11, r31
    1636:	8f 36       	cpi	r24, 0x6F	; 111
    1638:	c1 f0       	breq	.+48     	; 0x166a <vfprintf+0x272>
    163a:	18 f4       	brcc	.+6      	; 0x1642 <vfprintf+0x24a>
    163c:	88 35       	cpi	r24, 0x58	; 88
    163e:	79 f0       	breq	.+30     	; 0x165e <vfprintf+0x266>
    1640:	b4 c0       	rjmp	.+360    	; 0x17aa <vfprintf+0x3b2>
    1642:	80 37       	cpi	r24, 0x70	; 112
    1644:	19 f0       	breq	.+6      	; 0x164c <vfprintf+0x254>
    1646:	88 37       	cpi	r24, 0x78	; 120
    1648:	21 f0       	breq	.+8      	; 0x1652 <vfprintf+0x25a>
    164a:	af c0       	rjmp	.+350    	; 0x17aa <vfprintf+0x3b2>
    164c:	2f 2f       	mov	r18, r31
    164e:	20 61       	ori	r18, 0x10	; 16
    1650:	b2 2e       	mov	r11, r18
    1652:	b4 fe       	sbrs	r11, 4
    1654:	0d c0       	rjmp	.+26     	; 0x1670 <vfprintf+0x278>
    1656:	8b 2d       	mov	r24, r11
    1658:	84 60       	ori	r24, 0x04	; 4
    165a:	b8 2e       	mov	r11, r24
    165c:	09 c0       	rjmp	.+18     	; 0x1670 <vfprintf+0x278>
    165e:	24 ff       	sbrs	r18, 4
    1660:	0a c0       	rjmp	.+20     	; 0x1676 <vfprintf+0x27e>
    1662:	9f 2f       	mov	r25, r31
    1664:	96 60       	ori	r25, 0x06	; 6
    1666:	b9 2e       	mov	r11, r25
    1668:	06 c0       	rjmp	.+12     	; 0x1676 <vfprintf+0x27e>
    166a:	28 e0       	ldi	r18, 0x08	; 8
    166c:	30 e0       	ldi	r19, 0x00	; 0
    166e:	05 c0       	rjmp	.+10     	; 0x167a <vfprintf+0x282>
    1670:	20 e1       	ldi	r18, 0x10	; 16
    1672:	30 e0       	ldi	r19, 0x00	; 0
    1674:	02 c0       	rjmp	.+4      	; 0x167a <vfprintf+0x282>
    1676:	20 e1       	ldi	r18, 0x10	; 16
    1678:	32 e0       	ldi	r19, 0x02	; 2
    167a:	f8 01       	movw	r30, r16
    167c:	b7 fe       	sbrs	r11, 7
    167e:	07 c0       	rjmp	.+14     	; 0x168e <vfprintf+0x296>
    1680:	60 81       	ld	r22, Z
    1682:	71 81       	ldd	r23, Z+1	; 0x01
    1684:	82 81       	ldd	r24, Z+2	; 0x02
    1686:	93 81       	ldd	r25, Z+3	; 0x03
    1688:	0c 5f       	subi	r16, 0xFC	; 252
    168a:	1f 4f       	sbci	r17, 0xFF	; 255
    168c:	06 c0       	rjmp	.+12     	; 0x169a <vfprintf+0x2a2>
    168e:	60 81       	ld	r22, Z
    1690:	71 81       	ldd	r23, Z+1	; 0x01
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	0e 5f       	subi	r16, 0xFE	; 254
    1698:	1f 4f       	sbci	r17, 0xFF	; 255
    169a:	a4 01       	movw	r20, r8
    169c:	0e 94 3f 0c 	call	0x187e	; 0x187e <__ultoa_invert>
    16a0:	a8 2e       	mov	r10, r24
    16a2:	a8 18       	sub	r10, r8
    16a4:	fb 2d       	mov	r31, r11
    16a6:	ff 77       	andi	r31, 0x7F	; 127
    16a8:	7f 2e       	mov	r7, r31
    16aa:	76 fe       	sbrs	r7, 6
    16ac:	0b c0       	rjmp	.+22     	; 0x16c4 <vfprintf+0x2cc>
    16ae:	37 2d       	mov	r19, r7
    16b0:	3e 7f       	andi	r19, 0xFE	; 254
    16b2:	a5 14       	cp	r10, r5
    16b4:	50 f4       	brcc	.+20     	; 0x16ca <vfprintf+0x2d2>
    16b6:	74 fe       	sbrs	r7, 4
    16b8:	0a c0       	rjmp	.+20     	; 0x16ce <vfprintf+0x2d6>
    16ba:	72 fc       	sbrc	r7, 2
    16bc:	08 c0       	rjmp	.+16     	; 0x16ce <vfprintf+0x2d6>
    16be:	37 2d       	mov	r19, r7
    16c0:	3e 7e       	andi	r19, 0xEE	; 238
    16c2:	05 c0       	rjmp	.+10     	; 0x16ce <vfprintf+0x2d6>
    16c4:	ba 2c       	mov	r11, r10
    16c6:	37 2d       	mov	r19, r7
    16c8:	03 c0       	rjmp	.+6      	; 0x16d0 <vfprintf+0x2d8>
    16ca:	ba 2c       	mov	r11, r10
    16cc:	01 c0       	rjmp	.+2      	; 0x16d0 <vfprintf+0x2d8>
    16ce:	b5 2c       	mov	r11, r5
    16d0:	34 ff       	sbrs	r19, 4
    16d2:	0d c0       	rjmp	.+26     	; 0x16ee <vfprintf+0x2f6>
    16d4:	fe 01       	movw	r30, r28
    16d6:	ea 0d       	add	r30, r10
    16d8:	f1 1d       	adc	r31, r1
    16da:	80 81       	ld	r24, Z
    16dc:	80 33       	cpi	r24, 0x30	; 48
    16de:	11 f4       	brne	.+4      	; 0x16e4 <vfprintf+0x2ec>
    16e0:	39 7e       	andi	r19, 0xE9	; 233
    16e2:	09 c0       	rjmp	.+18     	; 0x16f6 <vfprintf+0x2fe>
    16e4:	32 ff       	sbrs	r19, 2
    16e6:	06 c0       	rjmp	.+12     	; 0x16f4 <vfprintf+0x2fc>
    16e8:	b3 94       	inc	r11
    16ea:	b3 94       	inc	r11
    16ec:	04 c0       	rjmp	.+8      	; 0x16f6 <vfprintf+0x2fe>
    16ee:	83 2f       	mov	r24, r19
    16f0:	86 78       	andi	r24, 0x86	; 134
    16f2:	09 f0       	breq	.+2      	; 0x16f6 <vfprintf+0x2fe>
    16f4:	b3 94       	inc	r11
    16f6:	33 fd       	sbrc	r19, 3
    16f8:	13 c0       	rjmp	.+38     	; 0x1720 <vfprintf+0x328>
    16fa:	30 ff       	sbrs	r19, 0
    16fc:	06 c0       	rjmp	.+12     	; 0x170a <vfprintf+0x312>
    16fe:	5a 2c       	mov	r5, r10
    1700:	b3 14       	cp	r11, r3
    1702:	18 f4       	brcc	.+6      	; 0x170a <vfprintf+0x312>
    1704:	53 0c       	add	r5, r3
    1706:	5b 18       	sub	r5, r11
    1708:	b3 2c       	mov	r11, r3
    170a:	b3 14       	cp	r11, r3
    170c:	68 f4       	brcc	.+26     	; 0x1728 <vfprintf+0x330>
    170e:	b7 01       	movw	r22, r14
    1710:	80 e2       	ldi	r24, 0x20	; 32
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	3c 87       	std	Y+12, r19	; 0x0c
    1716:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    171a:	b3 94       	inc	r11
    171c:	3c 85       	ldd	r19, Y+12	; 0x0c
    171e:	f5 cf       	rjmp	.-22     	; 0x170a <vfprintf+0x312>
    1720:	b3 14       	cp	r11, r3
    1722:	10 f4       	brcc	.+4      	; 0x1728 <vfprintf+0x330>
    1724:	3b 18       	sub	r3, r11
    1726:	01 c0       	rjmp	.+2      	; 0x172a <vfprintf+0x332>
    1728:	31 2c       	mov	r3, r1
    172a:	34 ff       	sbrs	r19, 4
    172c:	12 c0       	rjmp	.+36     	; 0x1752 <vfprintf+0x35a>
    172e:	b7 01       	movw	r22, r14
    1730:	80 e3       	ldi	r24, 0x30	; 48
    1732:	90 e0       	ldi	r25, 0x00	; 0
    1734:	3c 87       	std	Y+12, r19	; 0x0c
    1736:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    173a:	3c 85       	ldd	r19, Y+12	; 0x0c
    173c:	32 ff       	sbrs	r19, 2
    173e:	17 c0       	rjmp	.+46     	; 0x176e <vfprintf+0x376>
    1740:	31 fd       	sbrc	r19, 1
    1742:	03 c0       	rjmp	.+6      	; 0x174a <vfprintf+0x352>
    1744:	88 e7       	ldi	r24, 0x78	; 120
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	02 c0       	rjmp	.+4      	; 0x174e <vfprintf+0x356>
    174a:	88 e5       	ldi	r24, 0x58	; 88
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	b7 01       	movw	r22, r14
    1750:	0c c0       	rjmp	.+24     	; 0x176a <vfprintf+0x372>
    1752:	83 2f       	mov	r24, r19
    1754:	86 78       	andi	r24, 0x86	; 134
    1756:	59 f0       	breq	.+22     	; 0x176e <vfprintf+0x376>
    1758:	31 ff       	sbrs	r19, 1
    175a:	02 c0       	rjmp	.+4      	; 0x1760 <vfprintf+0x368>
    175c:	8b e2       	ldi	r24, 0x2B	; 43
    175e:	01 c0       	rjmp	.+2      	; 0x1762 <vfprintf+0x36a>
    1760:	80 e2       	ldi	r24, 0x20	; 32
    1762:	37 fd       	sbrc	r19, 7
    1764:	8d e2       	ldi	r24, 0x2D	; 45
    1766:	b7 01       	movw	r22, r14
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    176e:	a5 14       	cp	r10, r5
    1770:	38 f4       	brcc	.+14     	; 0x1780 <vfprintf+0x388>
    1772:	b7 01       	movw	r22, r14
    1774:	80 e3       	ldi	r24, 0x30	; 48
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    177c:	5a 94       	dec	r5
    177e:	f7 cf       	rjmp	.-18     	; 0x176e <vfprintf+0x376>
    1780:	aa 94       	dec	r10
    1782:	f4 01       	movw	r30, r8
    1784:	ea 0d       	add	r30, r10
    1786:	f1 1d       	adc	r31, r1
    1788:	80 81       	ld	r24, Z
    178a:	b7 01       	movw	r22, r14
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    1792:	a1 10       	cpse	r10, r1
    1794:	f5 cf       	rjmp	.-22     	; 0x1780 <vfprintf+0x388>
    1796:	33 20       	and	r3, r3
    1798:	09 f4       	brne	.+2      	; 0x179c <vfprintf+0x3a4>
    179a:	51 ce       	rjmp	.-862    	; 0x143e <vfprintf+0x46>
    179c:	b7 01       	movw	r22, r14
    179e:	80 e2       	ldi	r24, 0x20	; 32
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	0e 94 07 0c 	call	0x180e	; 0x180e <fputc>
    17a6:	3a 94       	dec	r3
    17a8:	f6 cf       	rjmp	.-20     	; 0x1796 <vfprintf+0x39e>
    17aa:	f7 01       	movw	r30, r14
    17ac:	86 81       	ldd	r24, Z+6	; 0x06
    17ae:	97 81       	ldd	r25, Z+7	; 0x07
    17b0:	02 c0       	rjmp	.+4      	; 0x17b6 <vfprintf+0x3be>
    17b2:	8f ef       	ldi	r24, 0xFF	; 255
    17b4:	9f ef       	ldi	r25, 0xFF	; 255
    17b6:	2c 96       	adiw	r28, 0x0c	; 12
    17b8:	cd bf       	out	0x3d, r28	; 61
    17ba:	de bf       	out	0x3e, r29	; 62
    17bc:	df 91       	pop	r29
    17be:	cf 91       	pop	r28
    17c0:	1f 91       	pop	r17
    17c2:	0f 91       	pop	r16
    17c4:	ff 90       	pop	r15
    17c6:	ef 90       	pop	r14
    17c8:	df 90       	pop	r13
    17ca:	cf 90       	pop	r12
    17cc:	bf 90       	pop	r11
    17ce:	af 90       	pop	r10
    17d0:	9f 90       	pop	r9
    17d2:	8f 90       	pop	r8
    17d4:	7f 90       	pop	r7
    17d6:	6f 90       	pop	r6
    17d8:	5f 90       	pop	r5
    17da:	4f 90       	pop	r4
    17dc:	3f 90       	pop	r3
    17de:	2f 90       	pop	r2
    17e0:	08 95       	ret

000017e2 <strnlen_P>:
    17e2:	fc 01       	movw	r30, r24
    17e4:	05 90       	lpm	r0, Z+
    17e6:	61 50       	subi	r22, 0x01	; 1
    17e8:	70 40       	sbci	r23, 0x00	; 0
    17ea:	01 10       	cpse	r0, r1
    17ec:	d8 f7       	brcc	.-10     	; 0x17e4 <strnlen_P+0x2>
    17ee:	80 95       	com	r24
    17f0:	90 95       	com	r25
    17f2:	8e 0f       	add	r24, r30
    17f4:	9f 1f       	adc	r25, r31
    17f6:	08 95       	ret

000017f8 <strnlen>:
    17f8:	fc 01       	movw	r30, r24
    17fa:	61 50       	subi	r22, 0x01	; 1
    17fc:	70 40       	sbci	r23, 0x00	; 0
    17fe:	01 90       	ld	r0, Z+
    1800:	01 10       	cpse	r0, r1
    1802:	d8 f7       	brcc	.-10     	; 0x17fa <strnlen+0x2>
    1804:	80 95       	com	r24
    1806:	90 95       	com	r25
    1808:	8e 0f       	add	r24, r30
    180a:	9f 1f       	adc	r25, r31
    180c:	08 95       	ret

0000180e <fputc>:
    180e:	0f 93       	push	r16
    1810:	1f 93       	push	r17
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
    1816:	fb 01       	movw	r30, r22
    1818:	23 81       	ldd	r18, Z+3	; 0x03
    181a:	21 fd       	sbrc	r18, 1
    181c:	03 c0       	rjmp	.+6      	; 0x1824 <fputc+0x16>
    181e:	8f ef       	ldi	r24, 0xFF	; 255
    1820:	9f ef       	ldi	r25, 0xFF	; 255
    1822:	28 c0       	rjmp	.+80     	; 0x1874 <fputc+0x66>
    1824:	22 ff       	sbrs	r18, 2
    1826:	16 c0       	rjmp	.+44     	; 0x1854 <fputc+0x46>
    1828:	46 81       	ldd	r20, Z+6	; 0x06
    182a:	57 81       	ldd	r21, Z+7	; 0x07
    182c:	24 81       	ldd	r18, Z+4	; 0x04
    182e:	35 81       	ldd	r19, Z+5	; 0x05
    1830:	42 17       	cp	r20, r18
    1832:	53 07       	cpc	r21, r19
    1834:	44 f4       	brge	.+16     	; 0x1846 <fputc+0x38>
    1836:	a0 81       	ld	r26, Z
    1838:	b1 81       	ldd	r27, Z+1	; 0x01
    183a:	9d 01       	movw	r18, r26
    183c:	2f 5f       	subi	r18, 0xFF	; 255
    183e:	3f 4f       	sbci	r19, 0xFF	; 255
    1840:	20 83       	st	Z, r18
    1842:	31 83       	std	Z+1, r19	; 0x01
    1844:	8c 93       	st	X, r24
    1846:	26 81       	ldd	r18, Z+6	; 0x06
    1848:	37 81       	ldd	r19, Z+7	; 0x07
    184a:	2f 5f       	subi	r18, 0xFF	; 255
    184c:	3f 4f       	sbci	r19, 0xFF	; 255
    184e:	26 83       	std	Z+6, r18	; 0x06
    1850:	37 83       	std	Z+7, r19	; 0x07
    1852:	10 c0       	rjmp	.+32     	; 0x1874 <fputc+0x66>
    1854:	eb 01       	movw	r28, r22
    1856:	09 2f       	mov	r16, r25
    1858:	18 2f       	mov	r17, r24
    185a:	00 84       	ldd	r0, Z+8	; 0x08
    185c:	f1 85       	ldd	r31, Z+9	; 0x09
    185e:	e0 2d       	mov	r30, r0
    1860:	19 95       	eicall
    1862:	89 2b       	or	r24, r25
    1864:	e1 f6       	brne	.-72     	; 0x181e <fputc+0x10>
    1866:	8e 81       	ldd	r24, Y+6	; 0x06
    1868:	9f 81       	ldd	r25, Y+7	; 0x07
    186a:	01 96       	adiw	r24, 0x01	; 1
    186c:	8e 83       	std	Y+6, r24	; 0x06
    186e:	9f 83       	std	Y+7, r25	; 0x07
    1870:	81 2f       	mov	r24, r17
    1872:	90 2f       	mov	r25, r16
    1874:	df 91       	pop	r29
    1876:	cf 91       	pop	r28
    1878:	1f 91       	pop	r17
    187a:	0f 91       	pop	r16
    187c:	08 95       	ret

0000187e <__ultoa_invert>:
    187e:	fa 01       	movw	r30, r20
    1880:	aa 27       	eor	r26, r26
    1882:	28 30       	cpi	r18, 0x08	; 8
    1884:	51 f1       	breq	.+84     	; 0x18da <__ultoa_invert+0x5c>
    1886:	20 31       	cpi	r18, 0x10	; 16
    1888:	81 f1       	breq	.+96     	; 0x18ea <__ultoa_invert+0x6c>
    188a:	e8 94       	clt
    188c:	6f 93       	push	r22
    188e:	6e 7f       	andi	r22, 0xFE	; 254
    1890:	6e 5f       	subi	r22, 0xFE	; 254
    1892:	7f 4f       	sbci	r23, 0xFF	; 255
    1894:	8f 4f       	sbci	r24, 0xFF	; 255
    1896:	9f 4f       	sbci	r25, 0xFF	; 255
    1898:	af 4f       	sbci	r26, 0xFF	; 255
    189a:	b1 e0       	ldi	r27, 0x01	; 1
    189c:	3e d0       	rcall	.+124    	; 0x191a <__ultoa_invert+0x9c>
    189e:	b4 e0       	ldi	r27, 0x04	; 4
    18a0:	3c d0       	rcall	.+120    	; 0x191a <__ultoa_invert+0x9c>
    18a2:	67 0f       	add	r22, r23
    18a4:	78 1f       	adc	r23, r24
    18a6:	89 1f       	adc	r24, r25
    18a8:	9a 1f       	adc	r25, r26
    18aa:	a1 1d       	adc	r26, r1
    18ac:	68 0f       	add	r22, r24
    18ae:	79 1f       	adc	r23, r25
    18b0:	8a 1f       	adc	r24, r26
    18b2:	91 1d       	adc	r25, r1
    18b4:	a1 1d       	adc	r26, r1
    18b6:	6a 0f       	add	r22, r26
    18b8:	71 1d       	adc	r23, r1
    18ba:	81 1d       	adc	r24, r1
    18bc:	91 1d       	adc	r25, r1
    18be:	a1 1d       	adc	r26, r1
    18c0:	20 d0       	rcall	.+64     	; 0x1902 <__ultoa_invert+0x84>
    18c2:	09 f4       	brne	.+2      	; 0x18c6 <__ultoa_invert+0x48>
    18c4:	68 94       	set
    18c6:	3f 91       	pop	r19
    18c8:	2a e0       	ldi	r18, 0x0A	; 10
    18ca:	26 9f       	mul	r18, r22
    18cc:	11 24       	eor	r1, r1
    18ce:	30 19       	sub	r19, r0
    18d0:	30 5d       	subi	r19, 0xD0	; 208
    18d2:	31 93       	st	Z+, r19
    18d4:	de f6       	brtc	.-74     	; 0x188c <__ultoa_invert+0xe>
    18d6:	cf 01       	movw	r24, r30
    18d8:	08 95       	ret
    18da:	46 2f       	mov	r20, r22
    18dc:	47 70       	andi	r20, 0x07	; 7
    18de:	40 5d       	subi	r20, 0xD0	; 208
    18e0:	41 93       	st	Z+, r20
    18e2:	b3 e0       	ldi	r27, 0x03	; 3
    18e4:	0f d0       	rcall	.+30     	; 0x1904 <__ultoa_invert+0x86>
    18e6:	c9 f7       	brne	.-14     	; 0x18da <__ultoa_invert+0x5c>
    18e8:	f6 cf       	rjmp	.-20     	; 0x18d6 <__ultoa_invert+0x58>
    18ea:	46 2f       	mov	r20, r22
    18ec:	4f 70       	andi	r20, 0x0F	; 15
    18ee:	40 5d       	subi	r20, 0xD0	; 208
    18f0:	4a 33       	cpi	r20, 0x3A	; 58
    18f2:	18 f0       	brcs	.+6      	; 0x18fa <__ultoa_invert+0x7c>
    18f4:	49 5d       	subi	r20, 0xD9	; 217
    18f6:	31 fd       	sbrc	r19, 1
    18f8:	40 52       	subi	r20, 0x20	; 32
    18fa:	41 93       	st	Z+, r20
    18fc:	02 d0       	rcall	.+4      	; 0x1902 <__ultoa_invert+0x84>
    18fe:	a9 f7       	brne	.-22     	; 0x18ea <__ultoa_invert+0x6c>
    1900:	ea cf       	rjmp	.-44     	; 0x18d6 <__ultoa_invert+0x58>
    1902:	b4 e0       	ldi	r27, 0x04	; 4
    1904:	a6 95       	lsr	r26
    1906:	97 95       	ror	r25
    1908:	87 95       	ror	r24
    190a:	77 95       	ror	r23
    190c:	67 95       	ror	r22
    190e:	ba 95       	dec	r27
    1910:	c9 f7       	brne	.-14     	; 0x1904 <__ultoa_invert+0x86>
    1912:	00 97       	sbiw	r24, 0x00	; 0
    1914:	61 05       	cpc	r22, r1
    1916:	71 05       	cpc	r23, r1
    1918:	08 95       	ret
    191a:	9b 01       	movw	r18, r22
    191c:	ac 01       	movw	r20, r24
    191e:	0a 2e       	mov	r0, r26
    1920:	06 94       	lsr	r0
    1922:	57 95       	ror	r21
    1924:	47 95       	ror	r20
    1926:	37 95       	ror	r19
    1928:	27 95       	ror	r18
    192a:	ba 95       	dec	r27
    192c:	c9 f7       	brne	.-14     	; 0x1920 <__ultoa_invert+0xa2>
    192e:	62 0f       	add	r22, r18
    1930:	73 1f       	adc	r23, r19
    1932:	84 1f       	adc	r24, r20
    1934:	95 1f       	adc	r25, r21
    1936:	a0 1d       	adc	r26, r0
    1938:	08 95       	ret

0000193a <_exit>:
    193a:	f8 94       	cli

0000193c <__stop_program>:
    193c:	ff cf       	rjmp	.-2      	; 0x193c <__stop_program>
